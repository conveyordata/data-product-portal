// Code generated by oapi-codegen. DO NOT EDIT.

package portalsdk

import (
	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/google/uuid"
)

type CheckAccessQuery struct {
	Resource *uuid.UUID `json:"resource,omitempty"`
	Domain   *uuid.UUID `json:"domain,omitempty"`
}

func (c CheckAccessQuery) Validate() error {
	var errors runtime.ValidationErrors
	if c.Resource != nil {
		if v, ok := any(c.Resource).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Resource", err)
			}
		}
	}
	if c.Domain != nil {
		if v, ok := any(c.Domain).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Domain", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchOutputPortsQuery struct {
	Query string `json:"query" validate:"required,min=3"`
	Limit *int   `json:"limit,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchOutputPortsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetOutputPortQueryStatsQuery struct {
	Granularity *QueryStatsGranularity `json:"granularity,omitempty"`
	DayRange    *int                   `json:"day_range,omitempty" validate:"omitempty,gte=1"`
}

func (g GetOutputPortQueryStatsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if g.Granularity != nil {
		if v, ok := any(g.Granularity).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Granularity", err)
			}
		}
	}
	if g.DayRange != nil {
		if err := typesValidator.Var(g.DayRange, "omitempty,gte=1"); err != nil {
			errors = errors.Append("DayRange", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortGraphDataQuery struct {
	Level *int `json:"level,omitempty"`
}

type SetValueForOutputPortQuery struct {
	Value string `json:"value" validate:"required"`
}

func (s SetValueForOutputPortQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetDataProductsQuery struct {
	FilterToUserWithAssigment *uuid.UUID `json:"filter_to_user_with_assigment,omitempty"`
}

func (g GetDataProductsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if g.FilterToUserWithAssigment != nil {
		if v, ok := any(g.FilterToUserWithAssigment).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("FilterToUserWithAssigment", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductGraphDataQuery struct {
	Level *int `json:"level,omitempty"`
}

type SetValueForDataProductQuery struct {
	Value string `json:"value" validate:"required"`
}

func (s SetValueForDataProductQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetSigninURLQuery struct {
	Environment string `json:"environment" validate:"required"`
}

func (g GetSigninURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetDatabricksWorkspaceURLQuery struct {
	Environment string `json:"environment" validate:"required"`
}

func (g GetDatabricksWorkspaceURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetSnowflakeURLQuery struct {
	Environment string `json:"environment" validate:"required"`
}

func (g GetSnowflakeURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetTechnicalAssetGraphDataQuery struct {
	Level *int `json:"level,omitempty"`
}

type ListGlobalRoleAssignmentsQuery struct {
	UserID *uuid.UUID `json:"user_id,omitempty"`
	RoleID *uuid.UUID `json:"role_id,omitempty"`
}

func (l ListGlobalRoleAssignmentsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if l.UserID != nil {
		if v, ok := any(l.UserID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("UserID", err)
			}
		}
	}
	if l.RoleID != nil {
		if v, ok := any(l.RoleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RoleID", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ListDataProductRoleAssignmentsQuery struct {
	DataProductID *uuid.UUID      `json:"data_product_id,omitempty"`
	UserID        *uuid.UUID      `json:"user_id,omitempty"`
	RoleID        *uuid.UUID      `json:"role_id,omitempty"`
	Decision      *DecisionStatus `json:"decision,omitempty"`
}

func (l ListDataProductRoleAssignmentsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if l.DataProductID != nil {
		if v, ok := any(l.DataProductID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataProductID", err)
			}
		}
	}
	if l.UserID != nil {
		if v, ok := any(l.UserID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("UserID", err)
			}
		}
	}
	if l.RoleID != nil {
		if v, ok := any(l.RoleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RoleID", err)
			}
		}
	}
	if l.Decision != nil {
		if v, ok := any(l.Decision).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Decision", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ListOutputPortRoleAssignmentsQuery struct {
	OutputPortID *uuid.UUID      `json:"output_port_id,omitempty"`
	UserID       *uuid.UUID      `json:"user_id,omitempty"`
	RoleID       *uuid.UUID      `json:"role_id,omitempty"`
	Decision     *DecisionStatus `json:"decision,omitempty"`
}

func (l ListOutputPortRoleAssignmentsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if l.OutputPortID != nil {
		if v, ok := any(l.OutputPortID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("OutputPortID", err)
			}
		}
	}
	if l.UserID != nil {
		if v, ok := any(l.UserID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("UserID", err)
			}
		}
	}
	if l.RoleID != nil {
		if v, ok := any(l.RoleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RoleID", err)
			}
		}
	}
	if l.Decision != nil {
		if v, ok := any(l.Decision).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Decision", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetGraphDataQuery struct {
	DomainNodesEnabled      *bool `json:"domain_nodes_enabled,omitempty"`
	DataProductNodesEnabled *bool `json:"data_product_nodes_enabled,omitempty"`
	DatasetNodesEnabled     *bool `json:"dataset_nodes_enabled,omitempty"`
}

type SanitizeResourceNameQuery struct {
	Name string `json:"name" validate:"required"`
}

func (s SanitizeResourceNameQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetDeviceTokenQuery struct {
	ClientID string  `json:"client_id" validate:"required"`
	Scope    *string `json:"scope,omitempty"`
}

func (g GetDeviceTokenQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetJwtTokenQuery struct {
	ClientID   string `json:"client_id" validate:"required"`
	DeviceCode string `json:"device_code" validate:"required"`
	GrantType  string `json:"grant_type" validate:"required"`
}

func (g GetJwtTokenQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAwsCredentialsQuery struct {
	DataProductName string `json:"data_product_name" validate:"required"`
	Environment     string `json:"environment" validate:"required"`
}

func (g GetAwsCredentialsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}
