// Code generated by oapi-codegen. DO NOT EDIT.

package portalsdk

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/google/uuid"
)

type AWSCredentials struct {
	AccessKeyID     string    `json:"AccessKeyId" validate:"required"`
	SecretAccessKey string    `json:"SecretAccessKey" validate:"required"`
	SessionToken    string    `json:"SessionToken" validate:"required"`
	Expiration      time.Time `json:"Expiration" validate:"required"`
}

func (a AWSCredentials) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AWSEnvironmentPlatformConfiguration struct {
	AccountID   string   `json:"account_id" validate:"required"`
	Region      string   `json:"region" validate:"required"`
	CanReadFrom []string `json:"can_read_from" validate:"required"`
}

func (a AWSEnvironmentPlatformConfiguration) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AWSGlueConfig struct {
	Identifier       string `json:"identifier" validate:"required"`
	DatabaseName     string `json:"database_name" validate:"required"`
	BucketIdentifier string `json:"bucket_identifier" validate:"required"`
	S3Path           string `json:"s3_path" validate:"required"`
}

func (a AWSGlueConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AWSS3Config struct {
	Identifier string `json:"identifier" validate:"required"`
	BucketName string `json:"bucket_name" validate:"required"`
	BucketArn  string `json:"bucket_arn" validate:"required"`
	KmsKeyArn  string `json:"kms_key_arn" validate:"required"`
	IsDefault  bool   `json:"is_default"`
}

func (a AWSS3Config) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AccessResponse struct {
	Allowed bool `json:"allowed"`
}

type ApproveLinkBetweenTechnicalAssetAndOutputPortRequest struct {
	TechnicalAssetID uuid.UUID `json:"technical_asset_id" validate:"required"`
}

func (a ApproveLinkBetweenTechnicalAssetAndOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ApproveOutputPortAsInputPortRequest struct {
	ConsumingDataProductID uuid.UUID `json:"consuming_data_product_id" validate:"required"`
}

func (a ApproveOutputPortAsInputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ConsumingDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumingDataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type BecomeAdmin struct {
	Expiry string `json:"expiry" validate:"required"`
}

func (b BecomeAdmin) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(b))
}

type CanBecomeAdminUpdate struct {
	UserID         string `json:"user_id" validate:"required"`
	CanBecomeAdmin bool   `json:"can_become_admin"`
}

func (c CanBecomeAdminUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type CreateDataProductLifeCycleResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductLifeCycleResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductRoleAssignment struct {
	UserID        uuid.UUID `json:"user_id" validate:"required"`
	RoleID        uuid.UUID `json:"role_id" validate:"required"`
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (c CreateDataProductRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(c.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(c.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductSettingResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductSettingResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductTypeResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductTypeResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDomainResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDomainResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateGlobalRoleAssignment struct {
	UserID uuid.UUID                         `json:"user_id" validate:"required"`
	RoleID CreateGlobalRoleAssignment_RoleID `json:"role_id"`
}

func (c CreateGlobalRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(c.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateGlobalRoleAssignment_RoleID struct {
	CreateGlobalRoleAssignment_RoleID_AnyOf *CreateGlobalRoleAssignment_RoleID_AnyOf `json:"-"`
}

func (c CreateGlobalRoleAssignment_RoleID) Validate() error {
	var errors runtime.ValidationErrors
	if c.CreateGlobalRoleAssignment_RoleID_AnyOf != nil {
		if v, ok := any(c.CreateGlobalRoleAssignment_RoleID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("CreateGlobalRoleAssignment_RoleID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (c CreateGlobalRoleAssignment_RoleID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(c.CreateGlobalRoleAssignment_RoleID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("CreateGlobalRoleAssignment_RoleID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (c *CreateGlobalRoleAssignment_RoleID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if c.CreateGlobalRoleAssignment_RoleID_AnyOf == nil {
		c.CreateGlobalRoleAssignment_RoleID_AnyOf = &CreateGlobalRoleAssignment_RoleID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, c.CreateGlobalRoleAssignment_RoleID_AnyOf); err != nil {
		return fmt.Errorf("CreateGlobalRoleAssignment_RoleID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type CreateOutputPortRequest struct {
	Name        string               `json:"name" validate:"required"`
	Namespace   string               `json:"namespace" validate:"required"`
	Description string               `json:"description" validate:"required"`
	AccessType  OutputPortAccessType `json:"access_type" validate:"required"`
	About       *string              `json:"about,omitempty"`
	LifecycleID *uuid.UUID           `json:"lifecycle_id,omitempty"`
	TagIds      []uuid.UUID          `json:"tag_ids" validate:"required"`
	Owners      []uuid.UUID          `json:"owners" validate:"required"`
}

func (c CreateOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(c.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(c.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(c.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if c.LifecycleID != nil {
		if v, ok := any(c.LifecycleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LifecycleID", err)
			}
		}
	}
	for i, item := range c.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	for i, item := range c.Owners {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Owners[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateOutputPortResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateOutputPortRoleAssignment struct {
	UserID       uuid.UUID `json:"user_id" validate:"required"`
	RoleID       uuid.UUID `json:"role_id" validate:"required"`
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
}

func (c CreateOutputPortRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(c.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(c.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateRole struct {
	Name        string                `json:"name" validate:"required"`
	Scope       Scope                 `json:"scope" validate:"required"`
	Description string                `json:"description" validate:"required"`
	Permissions []AuthorizationAction `json:"permissions" validate:"required"`
}

func (c CreateRole) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(c.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if err := typesValidator.Var(c.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	for i, item := range c.Permissions {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Permissions[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTagResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateTagResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTechnicalAssetRequest struct {
	Name          string                                    `json:"name" validate:"required"`
	Description   string                                    `json:"description" validate:"required"`
	Namespace     string                                    `json:"namespace" validate:"required"`
	PlatformID    uuid.UUID                                 `json:"platform_id" validate:"required"`
	ServiceID     uuid.UUID                                 `json:"service_id" validate:"required"`
	Status        TechnicalAssetStatus                      `json:"status" validate:"required"`
	Configuration CreateTechnicalAssetRequest_Configuration `json:"configuration"`

	// SourceAligned DEPRECATED: Use 'technical_mapping' instead. This field will be removed in a future version.
	// Deprecated:
	SourceAligned    *bool             `json:"sourceAligned,omitempty"`
	TechnicalMapping *TechnicalMapping `json:"technical_mapping,omitempty"`
	TagIds           []uuid.UUID       `json:"tag_ids" validate:"required"`
}

func (c CreateTechnicalAssetRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(c.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(c.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(c.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(c.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if v, ok := any(c.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(c.Configuration).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Configuration", err)
		}
	}
	if c.TechnicalMapping != nil {
		if v, ok := any(c.TechnicalMapping).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TechnicalMapping", err)
			}
		}
	}
	for i, item := range c.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTechnicalAssetRequest_Configuration struct {
	CreateTechnicalAssetRequest_Configuration_OneOf *CreateTechnicalAssetRequest_Configuration_OneOf `json:"-"`
}

func (c CreateTechnicalAssetRequest_Configuration) Validate() error {
	var errors runtime.ValidationErrors
	if c.CreateTechnicalAssetRequest_Configuration_OneOf != nil {
		if v, ok := any(c.CreateTechnicalAssetRequest_Configuration_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("CreateTechnicalAssetRequest_Configuration_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (c CreateTechnicalAssetRequest_Configuration) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(c.CreateTechnicalAssetRequest_Configuration_OneOf)
		if err != nil {
			return nil, fmt.Errorf("CreateTechnicalAssetRequest_Configuration_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (c *CreateTechnicalAssetRequest_Configuration) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if c.CreateTechnicalAssetRequest_Configuration_OneOf == nil {
		c.CreateTechnicalAssetRequest_Configuration_OneOf = &CreateTechnicalAssetRequest_Configuration_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, c.CreateTechnicalAssetRequest_Configuration_OneOf); err != nil {
		return fmt.Errorf("CreateTechnicalAssetRequest_Configuration_OneOf unmarshal: %w", err)
	}

	return nil
}

type CreateTechnicalAssetResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateTechnicalAssetResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataOutputStatusUpdate struct {
	Status TechnicalAssetStatus `json:"status" validate:"required"`
}

func (d DataOutputStatusUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProduct struct {
	ID          uuid.UUID         `json:"id" validate:"required"`
	Name        string            `json:"name" validate:"required"`
	Namespace   string            `json:"namespace" validate:"required"`
	Description string            `json:"description" validate:"required"`
	Status      DataProductStatus `json:"status" validate:"required"`
	Type        DataProductType   `json:"type"`
}

func (d DataProduct) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductAboutUpdate struct {
	About string `json:"about" validate:"required"`
}

func (d DataProductAboutUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DataProductCreate struct {
	Name        string      `json:"name" validate:"required"`
	Namespace   string      `json:"namespace" validate:"required"`
	Description string      `json:"description" validate:"required"`
	TypeID      uuid.UUID   `json:"type_id" validate:"required"`
	About       *string     `json:"about,omitempty"`
	DomainID    uuid.UUID   `json:"domain_id" validate:"required"`
	TagIds      []uuid.UUID `json:"tag_ids" validate:"required"`
	LifecycleID uuid.UUID   `json:"lifecycle_id" validate:"required"`
	Owners      []uuid.UUID `json:"owners" validate:"required"`
}

func (d DataProductCreate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.TypeID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TypeID", err)
		}
	}
	if v, ok := any(d.DomainID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DomainID", err)
		}
	}
	for i, item := range d.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if v, ok := any(d.LifecycleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("LifecycleID", err)
		}
	}
	for i, item := range d.Owners {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Owners[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductLifeCycle struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Value     int       `json:"value" validate:"required"`
	Color     string    `json:"color" validate:"required"`
	IsDefault bool      `json:"is_default"`
}

func (d DataProductLifeCycle) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(d.Color, "required"); err != nil {
		errors = errors.Append("Color", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductLifeCycleCreate struct {
	Value     int    `json:"value" validate:"required"`
	Name      string `json:"name" validate:"required"`
	Color     string `json:"color" validate:"required"`
	IsDefault *bool  `json:"is_default,omitempty"`
}

func (d DataProductLifeCycleCreate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DataProductLifeCycleUpdate struct {
	Value     int    `json:"value" validate:"required"`
	Name      string `json:"name" validate:"required"`
	Color     string `json:"color" validate:"required"`
	IsDefault *bool  `json:"is_default,omitempty"`
}

func (d DataProductLifeCycleUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DataProductLifeCyclesGet struct {
	DataProductLifeCycles []DataProductLifeCyclesGetItem `json:"data_product_life_cycles" validate:"required"`
}

func (d DataProductLifeCyclesGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.DataProductLifeCycles {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductLifeCycles[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductLifeCyclesGetItem struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Value     int       `json:"value" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Color     string    `json:"color" validate:"required"`
	IsDefault bool      `json:"is_default"`
}

func (d DataProductLifeCyclesGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Color, "required"); err != nil {
		errors = errors.Append("Color", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductOutputPortPendingAction struct {
	ID                uuid.UUID      `json:"id" validate:"required"`
	Justification     string         `json:"justification" validate:"required"`
	DataProductID     uuid.UUID      `json:"data_product_id" validate:"required"`
	OutputPortID      uuid.UUID      `json:"output_port_id" validate:"required"`
	Status            DecisionStatus `json:"status" validate:"required"`
	RequestedOn       time.Time      `json:"requested_on" validate:"required"`
	OutputPort        OutputPort     `json:"output_port"`
	DataProduct       DataProduct    `json:"data_product"`
	RequestedBy       User           `json:"requested_by"`
	DeniedBy          User           `json:"denied_by"`
	ApprovedBy        User           `json:"approved_by"`
	PendingActionType *string        `json:"pending_action_type,omitempty"`
}

func (d DataProductOutputPortPendingAction) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Justification, "required"); err != nil {
		errors = errors.Append("Justification", err)
	}
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(d.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if err := typesValidator.Var(d.RequestedOn, "required"); err != nil {
		errors = errors.Append("RequestedOn", err)
	}
	if v, ok := any(d.OutputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPort", err)
		}
	}
	if v, ok := any(d.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(d.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(d.DeniedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DeniedBy", err)
		}
	}
	if v, ok := any(d.ApprovedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ApprovedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductRoleAssignmentPendingAction struct {
	ID                uuid.UUID      `json:"id" validate:"required"`
	DataProduct       DataProduct    `json:"data_product"`
	User              User           `json:"user"`
	Role              Role           `json:"role"`
	Decision          DecisionStatus `json:"decision" validate:"required"`
	RequestedOn       time.Time      `json:"requested_on"`
	RequestedBy       User           `json:"requested_by"`
	DecidedOn         time.Time      `json:"decided_on"`
	DecidedBy         User           `json:"decided_by"`
	PendingActionType *string        `json:"pending_action_type,omitempty"`
}

func (d DataProductRoleAssignmentPendingAction) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(d.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(d.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(d.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(d.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductRoleAssignmentResponse struct {
	ID          uuid.UUID      `json:"id" validate:"required"`
	DataProduct DataProduct    `json:"data_product"`
	User        User           `json:"user"`
	Role        Role           `json:"role"`
	Decision    DecisionStatus `json:"decision" validate:"required"`
	RequestedOn time.Time      `json:"requested_on"`
	RequestedBy User           `json:"requested_by"`
	DecidedOn   time.Time      `json:"decided_on"`
	DecidedBy   User           `json:"decided_by"`
}

func (d DataProductRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(d.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(d.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(d.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(d.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSetting struct {
	ID        uuid.UUID               `json:"id" validate:"required"`
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSetting) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingCreate struct {
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSettingCreate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingUpdate struct {
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSettingUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingValue struct {
	ID                   uuid.UUID          `json:"id" validate:"required"`
	DataProductSettingID uuid.UUID          `json:"data_product_setting_id" validate:"required"`
	Value                string             `json:"value" validate:"required"`
	DataProductSetting   DataProductSetting `json:"data_product_setting"`
	DataProductID        uuid.UUID          `json:"data_product_id" validate:"required"`
}

func (d DataProductSettingValue) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.DataProductSettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSettingID", err)
		}
	}
	if err := typesValidator.Var(d.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if v, ok := any(d.DataProductSetting).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSetting", err)
		}
	}
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingsGet struct {
	DataProductSettings []DataProductSettingsGetItem `json:"data_product_settings" validate:"required"`
}

func (d DataProductSettingsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingsGetItem struct {
	ID        uuid.UUID               `json:"id" validate:"required"`
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSettingsGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductStatusUpdate struct {
	Status DataProductStatus `json:"status" validate:"required"`
}

func (d DataProductStatusUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductType struct {
	ID          uuid.UUID          `json:"id" validate:"required"`
	Name        string             `json:"name" validate:"required"`
	Description string             `json:"description" validate:"required"`
	IconKey     DataProductIconKey `json:"icon_key" validate:"required"`
}

func (d DataProductType) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypeCreate struct {
	Name        string             `json:"name" validate:"required"`
	Description string             `json:"description" validate:"required"`
	IconKey     DataProductIconKey `json:"icon_key" validate:"required"`
}

func (d DataProductTypeCreate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypeGet struct {
	ID           uuid.UUID          `json:"id" validate:"required"`
	Name         string             `json:"name" validate:"required"`
	Description  string             `json:"description" validate:"required"`
	IconKey      DataProductIconKey `json:"icon_key" validate:"required"`
	DataProducts []DataProduct      `json:"data_products" validate:"required"`
}

func (d DataProductTypeGet) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	for i, item := range d.DataProducts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProducts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypeUpdate struct {
	Name        string             `json:"name" validate:"required"`
	Description string             `json:"description" validate:"required"`
	IconKey     DataProductIconKey `json:"icon_key" validate:"required"`
}

func (d DataProductTypeUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypesGet struct {
	DataProductTypes []DataProductTypesGetItem `json:"data_product_types" validate:"required"`
}

func (d DataProductTypesGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.DataProductTypes {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductTypes[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypesGetItem struct {
	ID               uuid.UUID          `json:"id" validate:"required"`
	Name             string             `json:"name" validate:"required"`
	Description      string             `json:"description" validate:"required"`
	IconKey          DataProductIconKey `json:"icon_key" validate:"required"`
	DataProductCount int                `json:"data_product_count" validate:"required"`
}

func (d DataProductTypesGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if err := typesValidator.Var(d.DataProductCount, "required"); err != nil {
		errors = errors.Append("DataProductCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductUpdate struct {
	Name        string      `json:"name" validate:"required"`
	Namespace   string      `json:"namespace" validate:"required"`
	Description string      `json:"description" validate:"required"`
	TypeID      uuid.UUID   `json:"type_id" validate:"required"`
	About       *string     `json:"about,omitempty"`
	DomainID    uuid.UUID   `json:"domain_id" validate:"required"`
	TagIds      []uuid.UUID `json:"tag_ids" validate:"required"`
	LifecycleID uuid.UUID   `json:"lifecycle_id" validate:"required"`
}

func (d DataProductUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.TypeID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TypeID", err)
		}
	}
	if v, ok := any(d.DomainID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DomainID", err)
		}
	}
	for i, item := range d.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if v, ok := any(d.LifecycleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("LifecycleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductUsageUpdate struct {
	Usage string `json:"usage" validate:"required"`
}

func (d DataProductUsageUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatabricksConfig struct {
	Identifier string `json:"identifier" validate:"required"`
}

func (d DatabricksConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatabricksDataOutput struct {
	ConfigurationType string            `json:"configuration_type" validate:"required"`
	Catalog           string            `json:"catalog" validate:"required"`
	Schema            *string           `json:"schema,omitempty"`
	Table             *string           `json:"table,omitempty"`
	BucketIdentifier  *string           `json:"bucket_identifier,omitempty"`
	CatalogPath       *string           `json:"catalog_path,omitempty"`
	TablePath         *string           `json:"table_path,omitempty"`
	AccessGranularity AccessGranularity `json:"access_granularity" validate:"required"`
}

func (d DatabricksDataOutput) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.ConfigurationType, "required"); err != nil {
		errors = errors.Append("ConfigurationType", err)
	}
	if err := typesValidator.Var(d.Catalog, "required"); err != nil {
		errors = errors.Append("Catalog", err)
	}
	if v, ok := any(d.AccessGranularity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessGranularity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DatabricksEnvironmentPlatformConfiguration struct {
	WorkspaceUrls  map[string]string `json:"workspace_urls"`
	AccountID      string            `json:"account_id" validate:"required"`
	MetastoreID    string            `json:"metastore_id" validate:"required"`
	CredentialName string            `json:"credential_name" validate:"required"`
}

func (d DatabricksEnvironmentPlatformConfiguration) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatasetAboutUpdate struct {
	About string `json:"about" validate:"required"`
}

func (d DatasetAboutUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatasetStatusUpdate struct {
	Status OutputPortStatus `json:"status" validate:"required"`
}

func (d DatasetStatusUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DatasetUpdate struct {
	Name        string               `json:"name" validate:"required"`
	Namespace   string               `json:"namespace" validate:"required"`
	Description string               `json:"description" validate:"required"`
	AccessType  OutputPortAccessType `json:"access_type" validate:"required"`
	About       *string              `json:"about,omitempty"`
	LifecycleID *uuid.UUID           `json:"lifecycle_id,omitempty"`
	TagIds      []uuid.UUID          `json:"tag_ids" validate:"required"`
}

func (d DatasetUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if d.LifecycleID != nil {
		if v, ok := any(d.LifecycleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LifecycleID", err)
			}
		}
	}
	for i, item := range d.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideDataProductRoleAssignment struct {
	Decision DecisionStatus `json:"decision" validate:"required"`
}

func (d DecideDataProductRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideGlobalRoleAssignment struct {
	Decision DecisionStatus `json:"decision" validate:"required"`
}

func (d DecideGlobalRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideOutputPortRoleAssignment struct {
	Decision DecisionStatus `json:"decision" validate:"required"`
}

func (d DecideOutputPortRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteDataProductRoleAssignmentResponse struct {
	ID            uuid.UUID `json:"id" validate:"required"`
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (d DeleteDataProductRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteGlobalRoleAssignmentResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteGlobalRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteOutputPortRoleAssignmentResponse struct {
	ID           uuid.UUID `json:"id" validate:"required"`
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
}

func (d DeleteOutputPortRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DenyLinkBetweenTechnicalAssetAndOutputPortRequest struct {
	TechnicalAssetID uuid.UUID `json:"technical_asset_id" validate:"required"`
}

func (d DenyLinkBetweenTechnicalAssetAndOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DenyOutputPortAsInputPortRequest struct {
	ConsumingDataProductID uuid.UUID `json:"consuming_data_product_id" validate:"required"`
}

func (d DenyOutputPortAsInputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ConsumingDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumingDataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Domain struct {
	ID          uuid.UUID `json:"id" validate:"required"`
	Name        string    `json:"name" validate:"required"`
	Description string    `json:"description" validate:"required"`
}

func (d Domain) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DomainCreate struct {
	Name        string `json:"name" validate:"required"`
	Description string `json:"description" validate:"required"`
}

func (d DomainCreate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DomainUpdate struct {
	Name        string `json:"name" validate:"required"`
	Description string `json:"description" validate:"required"`
}

func (d DomainUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type Edge struct {
	ID           Edge_ID     `json:"id"`
	Source       Edge_Source `json:"source"`
	Target       Edge_Target `json:"target"`
	Animated     bool        `json:"animated"`
	SourceHandle *string     `json:"sourceHandle,omitempty"`
	TargetHandle *string     `json:"targetHandle,omitempty"`
}

func (e Edge) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(e.Source).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Source", err)
		}
	}
	if v, ok := any(e.Target).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Target", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Edge_ID struct {
	Edge_ID_AnyOf *Edge_ID_AnyOf `json:"-"`
}

func (e Edge_ID) Validate() error {
	var errors runtime.ValidationErrors
	if e.Edge_ID_AnyOf != nil {
		if v, ok := any(e.Edge_ID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Edge_ID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e Edge_ID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.Edge_ID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Edge_ID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *Edge_ID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.Edge_ID_AnyOf == nil {
		e.Edge_ID_AnyOf = &Edge_ID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.Edge_ID_AnyOf); err != nil {
		return fmt.Errorf("Edge_ID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Edge_Source struct {
	Edge_Source_AnyOf *Edge_Source_AnyOf `json:"-"`
}

func (e Edge_Source) Validate() error {
	var errors runtime.ValidationErrors
	if e.Edge_Source_AnyOf != nil {
		if v, ok := any(e.Edge_Source_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Edge_Source_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e Edge_Source) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.Edge_Source_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Edge_Source_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *Edge_Source) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.Edge_Source_AnyOf == nil {
		e.Edge_Source_AnyOf = &Edge_Source_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.Edge_Source_AnyOf); err != nil {
		return fmt.Errorf("Edge_Source_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Edge_Target struct {
	Edge_Target_AnyOf *Edge_Target_AnyOf `json:"-"`
}

func (e Edge_Target) Validate() error {
	var errors runtime.ValidationErrors
	if e.Edge_Target_AnyOf != nil {
		if v, ok := any(e.Edge_Target_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Edge_Target_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e Edge_Target) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.Edge_Target_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Edge_Target_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *Edge_Target) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.Edge_Target_AnyOf == nil {
		e.Edge_Target_AnyOf = &Edge_Target_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.Edge_Target_AnyOf); err != nil {
		return fmt.Errorf("Edge_Target_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Environment struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Acronym   string    `json:"acronym" validate:"required"`
	Context   string    `json:"context" validate:"required"`
	IsDefault *bool     `json:"is_default,omitempty"`
}

func (e Environment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(e.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(e.Acronym, "required"); err != nil {
		errors = errors.Append("Acronym", err)
	}
	if err := typesValidator.Var(e.Context, "required"); err != nil {
		errors = errors.Append("Context", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGet struct {
	EnvironmentConfigs []EnvironmentConfigsGetItem `json:"environment_configs" validate:"required"`
}

func (e EnvironmentConfigsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e.EnvironmentConfigs {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("EnvironmentConfigs[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGetItem struct {
	Config      EnvironmentConfigsGetItem_Config `json:"config" validate:"required"`
	ID          uuid.UUID                        `json:"id" validate:"required"`
	Platform    Platform                         `json:"platform"`
	Environment Environment                      `json:"environment"`
	Service     PlatformService                  `json:"service"`
}

func (e EnvironmentConfigsGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Config).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Config", err)
		}
	}
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(e.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if v, ok := any(e.Environment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Environment", err)
		}
	}
	if v, ok := any(e.Service).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Service", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGetItem_Config []EnvironmentConfigsGetItem_Config_Item

func (e EnvironmentConfigsGetItem_Config) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGetItem_Config_Item struct {
	EnvironmentConfigsGetItem_Config_AnyOf *EnvironmentConfigsGetItem_Config_AnyOf `json:"-"`
}

func (e EnvironmentConfigsGetItem_Config_Item) Validate() error {
	var errors runtime.ValidationErrors
	if e.EnvironmentConfigsGetItem_Config_AnyOf != nil {
		if v, ok := any(e.EnvironmentConfigsGetItem_Config_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("EnvironmentConfigsGetItem_Config_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e EnvironmentConfigsGetItem_Config_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.EnvironmentConfigsGetItem_Config_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("EnvironmentConfigsGetItem_Config_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *EnvironmentConfigsGetItem_Config_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.EnvironmentConfigsGetItem_Config_AnyOf == nil {
		e.EnvironmentConfigsGetItem_Config_AnyOf = &EnvironmentConfigsGetItem_Config_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.EnvironmentConfigsGetItem_Config_AnyOf); err != nil {
		return fmt.Errorf("EnvironmentConfigsGetItem_Config_AnyOf unmarshal: %w", err)
	}

	return nil
}

type EnvironmentGetItem struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Acronym   string    `json:"acronym" validate:"required"`
	Context   string    `json:"context" validate:"required"`
	IsDefault *bool     `json:"is_default,omitempty"`
}

func (e EnvironmentGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(e.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(e.Acronym, "required"); err != nil {
		errors = errors.Append("Acronym", err)
	}
	if err := typesValidator.Var(e.Context, "required"); err != nil {
		errors = errors.Append("Context", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentPlatformConfigGet struct {
	Config      EnvironmentPlatformConfigGet_Config `json:"config"`
	ID          uuid.UUID                           `json:"id" validate:"required"`
	Environment Environment                         `json:"environment"`
	Platform    Platform                            `json:"platform"`
}

func (e EnvironmentPlatformConfigGet) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Config).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Config", err)
		}
	}
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(e.Environment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Environment", err)
		}
	}
	if v, ok := any(e.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentPlatformConfigGet_Config struct {
	EnvironmentPlatformConfigGet_Config_AnyOf *EnvironmentPlatformConfigGet_Config_AnyOf `json:"-"`
}

func (e EnvironmentPlatformConfigGet_Config) Validate() error {
	var errors runtime.ValidationErrors
	if e.EnvironmentPlatformConfigGet_Config_AnyOf != nil {
		if v, ok := any(e.EnvironmentPlatformConfigGet_Config_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("EnvironmentPlatformConfigGet_Config_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e EnvironmentPlatformConfigGet_Config) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.EnvironmentPlatformConfigGet_Config_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("EnvironmentPlatformConfigGet_Config_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *EnvironmentPlatformConfigGet_Config) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.EnvironmentPlatformConfigGet_Config_AnyOf == nil {
		e.EnvironmentPlatformConfigGet_Config_AnyOf = &EnvironmentPlatformConfigGet_Config_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.EnvironmentPlatformConfigGet_Config_AnyOf); err != nil {
		return fmt.Errorf("EnvironmentPlatformConfigGet_Config_AnyOf unmarshal: %w", err)
	}

	return nil
}

type EnvironmentsGet struct {
	Environments []EnvironmentGetItem `json:"environments" validate:"required"`
}

func (e EnvironmentsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e.Environments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Environments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// FieldDependency Represents a field dependency for conditional visibility.
// e.g. if field A has depends_on(field_name=B, value=Y), then field A is only shown when field B has value Y
// In practice this is often used with checkbox fields having value=True
type FieldDependency struct {
	FieldName string   `json:"field_name" validate:"required"`
	Value     struct{} `json:"value"`
}

func (f FieldDependency) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(f))
}

type GetAllPlatformServiceConfigurationsResponse struct {
	PlatformServiceConfigurations []PlatformServiceConfiguration `json:"platform_service_configurations" validate:"required"`
}

func (g GetAllPlatformServiceConfigurationsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.PlatformServiceConfigurations {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("PlatformServiceConfigurations[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAllPlatformsResponse struct {
	Platforms []Platform `json:"platforms" validate:"required"`
}

func (g GetAllPlatformsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Platforms {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Platforms[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetConveyorIdeURLResponse struct {
	IdeURL string `json:"ide_url" validate:"required"`
}

func (g GetConveyorIdeURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetDataProductInputPortsResponse struct {
	InputPorts []InputPort `json:"input_ports" validate:"required"`
}

func (g GetDataProductInputPortsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.InputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("InputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductOutputPortsResponse struct {
	OutputPorts []OutputPort `json:"output_ports" validate:"required"`
}

func (g GetDataProductOutputPortsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.OutputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductResponse struct {
	ID                  uuid.UUID                 `json:"id" validate:"required"`
	Name                string                    `json:"name" validate:"required"`
	Description         string                    `json:"description" validate:"required"`
	Namespace           string                    `json:"namespace" validate:"required"`
	Status              DataProductStatus         `json:"status" validate:"required"`
	Tags                []Tag                     `json:"tags" validate:"required"`
	Usage               string                    `json:"usage"`
	Domain              Domain                    `json:"domain"`
	Type                DataProductType           `json:"type"`
	Lifecycle           DataProductLifeCycle      `json:"lifecycle"`
	DataProductSettings []DataProductSettingValue `json:"data_product_settings" validate:"required"`
	About               string                    `json:"about"`
}

func (g GetDataProductResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(g.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(g.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range g.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductRolledUpTagsResponse struct {
	RolledUpTags []Tag `json:"rolled_up_tags" validate:"required"`
}

func (g GetDataProductRolledUpTagsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.RolledUpTags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RolledUpTags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductsResponse struct {
	DataProducts []GetDataProductsResponseItem `json:"data_products" validate:"required"`
}

func (g GetDataProductsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.DataProducts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProducts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductsResponseItem struct {
	ID                  uuid.UUID                 `json:"id" validate:"required"`
	Name                string                    `json:"name" validate:"required"`
	Description         string                    `json:"description" validate:"required"`
	Namespace           string                    `json:"namespace" validate:"required"`
	Status              DataProductStatus         `json:"status" validate:"required"`
	Tags                []Tag                     `json:"tags" validate:"required"`
	Usage               string                    `json:"usage"`
	Domain              Domain                    `json:"domain"`
	Type                DataProductType           `json:"type"`
	Lifecycle           DataProductLifeCycle      `json:"lifecycle"`
	DataProductSettings []DataProductSettingValue `json:"data_product_settings" validate:"required"`
	UserCount           int                       `json:"user_count" validate:"required"`
	OutputPortCount     int                       `json:"output_port_count" validate:"required"`
	TechnicalAssetCount int                       `json:"technical_asset_count" validate:"required"`
}

func (g GetDataProductsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(g.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(g.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range g.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(g.UserCount, "required"); err != nil {
		errors = errors.Append("UserCount", err)
	}
	if err := typesValidator.Var(g.OutputPortCount, "required"); err != nil {
		errors = errors.Append("OutputPortCount", err)
	}
	if err := typesValidator.Var(g.TechnicalAssetCount, "required"); err != nil {
		errors = errors.Append("TechnicalAssetCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDatabricksWorkspaceURLResponse struct {
	DatabricksWorkspaceURL string `json:"databricks_workspace_url" validate:"required"`
}

func (g GetDatabricksWorkspaceURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetDomainResponse struct {
	ID           uuid.UUID     `json:"id" validate:"required"`
	Name         string        `json:"name" validate:"required"`
	Description  string        `json:"description" validate:"required"`
	DataProducts []DataProduct `json:"data_products" validate:"required"`
}

func (g GetDomainResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	for i, item := range g.DataProducts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProducts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDomainsItem struct {
	ID               uuid.UUID `json:"id" validate:"required"`
	Name             string    `json:"name" validate:"required"`
	Description      string    `json:"description" validate:"required"`
	DataProductCount int       `json:"data_product_count" validate:"required"`
}

func (g GetDomainsItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.DataProductCount, "required"); err != nil {
		errors = errors.Append("DataProductCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDomainsResponse struct {
	Domains []GetDomainsItem `json:"domains" validate:"required"`
}

func (g GetDomainsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Domains {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Domains[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEventHistoryResponse struct {
	Events []GetEventHistoryResponseItem `json:"events" validate:"required"`
}

func (g GetEventHistoryResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Events {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Events[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEventHistoryResponseItem struct {
	ID                       uuid.UUID        `json:"id" validate:"required"`
	Name                     string           `json:"name" validate:"required"`
	SubjectID                uuid.UUID        `json:"subject_id" validate:"required"`
	TargetID                 *uuid.UUID       `json:"target_id,omitempty"`
	SubjectType              EventEntityType  `json:"subject_type" validate:"required"`
	TargetType               *EventEntityType `json:"target_type,omitempty"`
	ActorID                  uuid.UUID        `json:"actor_id" validate:"required"`
	CreatedOn                time.Time        `json:"created_on" validate:"required"`
	DeletedSubjectIdentifier *string          `json:"deleted_subject_identifier,omitempty"`
	DeletedTargetIdentifier  *string          `json:"deleted_target_identifier,omitempty"`
	Actor                    User             `json:"actor"`
	DataProduct              *DataProduct     `json:"data_product,omitempty"`
	User                     *User            `json:"user,omitempty"`
	OutputPort               *OutputPort      `json:"output_port,omitempty"`
	TechnicalAsset           *TechnicalAsset  `json:"technical_asset,omitempty"`
}

func (g GetEventHistoryResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(g.SubjectID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SubjectID", err)
		}
	}
	if g.TargetID != nil {
		if v, ok := any(g.TargetID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TargetID", err)
			}
		}
	}
	if v, ok := any(g.SubjectType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SubjectType", err)
		}
	}
	if g.TargetType != nil {
		if v, ok := any(g.TargetType).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TargetType", err)
			}
		}
	}
	if v, ok := any(g.ActorID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ActorID", err)
		}
	}
	if err := typesValidator.Var(g.CreatedOn, "required"); err != nil {
		errors = errors.Append("CreatedOn", err)
	}
	if v, ok := any(g.Actor).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Actor", err)
		}
	}
	if g.DataProduct != nil {
		if v, ok := any(g.DataProduct).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataProduct", err)
			}
		}
	}
	if g.User != nil {
		if v, ok := any(g.User).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("User", err)
			}
		}
	}
	if g.OutputPort != nil {
		if v, ok := any(g.OutputPort).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("OutputPort", err)
			}
		}
	}
	if g.TechnicalAsset != nil {
		if v, ok := any(g.TechnicalAsset).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TechnicalAsset", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortResponse struct {
	ID                  uuid.UUID                `json:"id" validate:"required"`
	Namespace           string                   `json:"namespace" validate:"required"`
	Name                string                   `json:"name" validate:"required"`
	Description         string                   `json:"description" validate:"required"`
	Status              OutputPortStatus         `json:"status" validate:"required"`
	Usage               string                   `json:"usage"`
	AccessType          OutputPortAccessType     `json:"access_type" validate:"required"`
	DataProductID       uuid.UUID                `json:"data_product_id" validate:"required"`
	Tags                []Tag                    `json:"tags" validate:"required"`
	Domain              Domain                   `json:"domain"`
	Lifecycle           DataProductLifeCycle     `json:"lifecycle"`
	DataProductSettings []OutputPortSettingValue `json:"data_product_settings" validate:"required"`
	TechnicalAssetLinks []TechnicalAssetLink     `json:"technical_asset_links" validate:"required"`
	About               string                   `json:"about"`
	RolledUpTags        []Tag                    `json:"rolled_up_tags" validate:"required"`
}

func (g GetOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(g.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(g.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(g.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range g.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	for i, item := range g.TechnicalAssetLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalAssetLinks[%d]", i), err)
			}
		}
	}
	for i, item := range g.RolledUpTags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RolledUpTags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetPlatformServicesResponse struct {
	PlatformServices []PlatformService `json:"platform_services" validate:"required"`
}

func (g GetPlatformServicesResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.PlatformServices {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("PlatformServices[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRolesResponse struct {
	Roles []Role `json:"roles" validate:"required"`
}

func (g GetRolesResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Roles {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Roles[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSigninURLResponse struct {
	SigninURL string `json:"signin_url" validate:"required"`
}

func (g GetSigninURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetSnowflakeURLResponse struct {
	SnowflakeURL string `json:"snowflake_url" validate:"required"`
}

func (g GetSnowflakeURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetTechnicalAssetsResponse struct {
	TechnicalAssets []GetTechnicalAssetsResponseItem `json:"technical_assets" validate:"required"`
}

func (g GetTechnicalAssetsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.TechnicalAssets {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalAssets[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetsResponseItem struct {
	ID               uuid.UUID                                    `json:"id" validate:"required"`
	Name             string                                       `json:"name" validate:"required"`
	Description      string                                       `json:"description" validate:"required"`
	Namespace        string                                       `json:"namespace" validate:"required"`
	OwnerID          uuid.UUID                                    `json:"owner_id" validate:"required"`
	PlatformID       uuid.UUID                                    `json:"platform_id" validate:"required"`
	ServiceID        uuid.UUID                                    `json:"service_id" validate:"required"`
	Status           TechnicalAssetStatus                         `json:"status" validate:"required"`
	TechnicalMapping TechnicalMapping                             `json:"technical_mapping" validate:"required"`
	Configuration    GetTechnicalAssetsResponseItem_Configuration `json:"configuration"`
	Owner            DataProduct                                  `json:"owner"`
	OutputPortLinks  []OutputPortLink                             `json:"output_port_links" validate:"required"`
	Tags             []Tag                                        `json:"tags" validate:"required"`

	// SourceAligned DEPRECATED: Use 'technical_mapping' instead. This field will be removed in a future version.
	SourceAligned *bool           `json:"sourceAligned,omitempty"`
	ResultString  *string         `json:"result_string,omitempty"`
	TechnicalInfo []TechnicalInfo `json:"technical_info,omitempty"`
}

func (g GetTechnicalAssetsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(g.OwnerID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OwnerID", err)
		}
	}
	if v, ok := any(g.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(g.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(g.TechnicalMapping).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalMapping", err)
		}
	}
	if v, ok := any(g.Configuration).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Configuration", err)
		}
	}
	if v, ok := any(g.Owner).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Owner", err)
		}
	}
	for i, item := range g.OutputPortLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortLinks[%d]", i), err)
			}
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	for i, item := range g.TechnicalInfo {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalInfo[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetsResponseItem_Configuration struct {
	GetTechnicalAssetsResponseItem_Configuration_OneOf *GetTechnicalAssetsResponseItem_Configuration_OneOf `json:"-"`
}

func (g GetTechnicalAssetsResponseItem_Configuration) Validate() error {
	var errors runtime.ValidationErrors
	if g.GetTechnicalAssetsResponseItem_Configuration_OneOf != nil {
		if v, ok := any(g.GetTechnicalAssetsResponseItem_Configuration_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("GetTechnicalAssetsResponseItem_Configuration_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (g GetTechnicalAssetsResponseItem_Configuration) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(g.GetTechnicalAssetsResponseItem_Configuration_OneOf)
		if err != nil {
			return nil, fmt.Errorf("GetTechnicalAssetsResponseItem_Configuration_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (g *GetTechnicalAssetsResponseItem_Configuration) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if g.GetTechnicalAssetsResponseItem_Configuration_OneOf == nil {
		g.GetTechnicalAssetsResponseItem_Configuration_OneOf = &GetTechnicalAssetsResponseItem_Configuration_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, g.GetTechnicalAssetsResponseItem_Configuration_OneOf); err != nil {
		return fmt.Errorf("GetTechnicalAssetsResponseItem_Configuration_OneOf unmarshal: %w", err)
	}

	return nil
}

type GetUserNotificationsResponse struct {
	Notifications []GetUserNotificationsResponseItem `json:"notifications" validate:"required"`
}

func (g GetUserNotificationsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Notifications {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Notifications[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetUserNotificationsResponseItem struct {
	ID      uuid.UUID                   `json:"id" validate:"required"`
	EventID uuid.UUID                   `json:"event_id" validate:"required"`
	UserID  uuid.UUID                   `json:"user_id" validate:"required"`
	Event   GetEventHistoryResponseItem `json:"event"`
	User    User                        `json:"user"`
}

func (g GetUserNotificationsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.EventID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("EventID", err)
		}
	}
	if v, ok := any(g.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(g.Event).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Event", err)
		}
	}
	if v, ok := any(g.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetUsersResponse struct {
	Users []UsersGet `json:"users" validate:"required"`
}

func (g GetUsersResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Users {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Users[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GlobalRoleAssignmentResponse struct {
	ID          uuid.UUID      `json:"id" validate:"required"`
	User        User           `json:"user"`
	Role        Role           `json:"role"`
	Decision    DecisionStatus `json:"decision" validate:"required"`
	RequestedOn time.Time      `json:"requested_on"`
	RequestedBy User           `json:"requested_by"`
	DecidedOn   time.Time      `json:"decided_on"`
	DecidedBy   User           `json:"decided_by"`
}

func (g GlobalRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(g.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(g.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(g.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(g.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GlueDataOutput struct {
	ConfigurationType string            `json:"configuration_type" validate:"required"`
	Database          string            `json:"database" validate:"required"`
	DatabaseSuffix    *string           `json:"database_suffix,omitempty"`
	Table             *string           `json:"table,omitempty"`
	BucketIdentifier  *string           `json:"bucket_identifier,omitempty"`
	DatabasePath      *string           `json:"database_path,omitempty"`
	TablePath         *string           `json:"table_path,omitempty"`
	AccessGranularity AccessGranularity `json:"access_granularity" validate:"required"`
}

func (g GlueDataOutput) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ConfigurationType, "required"); err != nil {
		errors = errors.Append("ConfigurationType", err)
	}
	if err := typesValidator.Var(g.Database, "required"); err != nil {
		errors = errors.Append("Database", err)
	}
	if v, ok := any(g.AccessGranularity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessGranularity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Graph struct {
	Edges []Edge `json:"edges" validate:"required"`
	Nodes []Node `json:"nodes" validate:"required"`
}

func (g Graph) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Edges {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Edges[%d]", i), err)
			}
		}
	}
	for i, item := range g.Nodes {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Nodes[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type HTTPValidationError struct {
	Detail []ValidationError `json:"detail,omitempty"`
}

func (h HTTPValidationError) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range h.Detail {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Detail[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (s HTTPValidationError) Error() string {
	return "unmapped client error"
}

type InputPort struct {
	ID            uuid.UUID      `json:"id" validate:"required"`
	Justification string         `json:"justification" validate:"required"`
	DataProductID uuid.UUID      `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID      `json:"output_port_id" validate:"required"`
	Status        DecisionStatus `json:"status" validate:"required"`
	InputPort     OutputPort     `json:"input_port"`
}

func (i InputPort) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(i.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(i.Justification, "required"); err != nil {
		errors = errors.Append("Justification", err)
	}
	if v, ok := any(i.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(i.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(i.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(i.InputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("InputPort", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type IsAdminResponse struct {
	IsAdmin bool    `json:"is_admin"`
	Time    *string `json:"time,omitempty"`
}

type LinkInputPortsToDataProduct struct {
	InputPorts    []uuid.UUID `json:"input_ports" validate:"required"`
	Justification string      `json:"justification" validate:"required"`
}

func (l LinkInputPortsToDataProduct) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.InputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("InputPorts[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(l.Justification, "required"); err != nil {
		errors = errors.Append("Justification", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkInputPortsToDataProductPost struct {
	InputPortLinks []uuid.UUID `json:"input_port_links" validate:"required"`
}

func (l LinkInputPortsToDataProductPost) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.InputPortLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("InputPortLinks[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkTechnicalAssetToOutputPortRequest struct {
	TechnicalAssetID uuid.UUID `json:"technical_asset_id" validate:"required"`
}

func (l LinkTechnicalAssetToOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkTechnicalAssetsToOutputPortResponse struct {
	LinkID uuid.UUID `json:"link_id" validate:"required"`
}

func (l LinkTechnicalAssetsToOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.LinkID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("LinkID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyDataProductRoleAssignment struct {
	RoleID uuid.UUID `json:"role_id" validate:"required"`
}

func (m ModifyDataProductRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyGlobalRoleAssignment struct {
	RoleID ModifyGlobalRoleAssignment_RoleID `json:"role_id"`
}

func (m ModifyGlobalRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyGlobalRoleAssignment_RoleID struct {
	ModifyGlobalRoleAssignment_RoleID_AnyOf *ModifyGlobalRoleAssignment_RoleID_AnyOf `json:"-"`
}

func (m ModifyGlobalRoleAssignment_RoleID) Validate() error {
	var errors runtime.ValidationErrors
	if m.ModifyGlobalRoleAssignment_RoleID_AnyOf != nil {
		if v, ok := any(m.ModifyGlobalRoleAssignment_RoleID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("ModifyGlobalRoleAssignment_RoleID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (m ModifyGlobalRoleAssignment_RoleID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(m.ModifyGlobalRoleAssignment_RoleID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("ModifyGlobalRoleAssignment_RoleID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (m *ModifyGlobalRoleAssignment_RoleID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if m.ModifyGlobalRoleAssignment_RoleID_AnyOf == nil {
		m.ModifyGlobalRoleAssignment_RoleID_AnyOf = &ModifyGlobalRoleAssignment_RoleID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, m.ModifyGlobalRoleAssignment_RoleID_AnyOf); err != nil {
		return fmt.Errorf("ModifyGlobalRoleAssignment_RoleID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type ModifyOutputPortRoleAssignment struct {
	RoleID uuid.UUID `json:"role_id" validate:"required"`
}

func (m ModifyOutputPortRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Node struct {
	ID     Node_ID  `json:"id"`
	Data   NodeData `json:"data"`
	Type   NodeType `json:"type" validate:"required"`
	IsMain *bool    `json:"isMain,omitempty"`
}

func (n Node) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(n.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(n.Data).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Data", err)
		}
	}
	if v, ok := any(n.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Node_ID struct {
	Node_ID_AnyOf *Node_ID_AnyOf `json:"-"`
}

func (n Node_ID) Validate() error {
	var errors runtime.ValidationErrors
	if n.Node_ID_AnyOf != nil {
		if v, ok := any(n.Node_ID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Node_ID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n Node_ID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.Node_ID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Node_ID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *Node_ID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.Node_ID_AnyOf == nil {
		n.Node_ID_AnyOf = &Node_ID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.Node_ID_AnyOf); err != nil {
		return fmt.Errorf("Node_ID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData struct {
	ID          NodeData_ID           `json:"id"`
	Name        string                `json:"name" validate:"required"`
	LinkToID    *NodeData_LinkToID    `json:"link_to_id,omitempty"`
	IconKey     *string               `json:"icon_key,omitempty"`
	Domain      *string               `json:"domain,omitempty"`
	DomainID    *NodeData_DomainID    `json:"domain_id,omitempty"`
	Description *string               `json:"description,omitempty"`
	Assignments *NodeData_Assignments `json:"assignments,omitempty"`
}

func (n NodeData) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(n.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(n.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if n.LinkToID != nil {
		if v, ok := any(n.LinkToID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LinkToID", err)
			}
		}
	}
	if n.DomainID != nil {
		if v, ok := any(n.DomainID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DomainID", err)
			}
		}
	}
	if n.Assignments != nil {
		if v, ok := any(n.Assignments).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Assignments", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NodeData_ID struct {
	NodeData_ID_AnyOf *NodeData_ID_AnyOf `json:"-"`
}

func (n NodeData_ID) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_ID_AnyOf != nil {
		if v, ok := any(n.NodeData_ID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_ID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_ID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_ID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_ID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_ID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_ID_AnyOf == nil {
		n.NodeData_ID_AnyOf = &NodeData_ID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_ID_AnyOf); err != nil {
		return fmt.Errorf("NodeData_ID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData_LinkToID struct {
	NodeData_LinkToID_AnyOf *NodeData_LinkToID_AnyOf `json:"-"`
}

func (n NodeData_LinkToID) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_LinkToID_AnyOf != nil {
		if v, ok := any(n.NodeData_LinkToID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_LinkToID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_LinkToID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_LinkToID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_LinkToID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_LinkToID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_LinkToID_AnyOf == nil {
		n.NodeData_LinkToID_AnyOf = &NodeData_LinkToID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_LinkToID_AnyOf); err != nil {
		return fmt.Errorf("NodeData_LinkToID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData_DomainID struct {
	NodeData_DomainID_AnyOf *NodeData_DomainID_AnyOf `json:"-"`
}

func (n NodeData_DomainID) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_DomainID_AnyOf != nil {
		if v, ok := any(n.NodeData_DomainID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_DomainID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_DomainID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_DomainID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_DomainID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_DomainID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_DomainID_AnyOf == nil {
		n.NodeData_DomainID_AnyOf = &NodeData_DomainID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_DomainID_AnyOf); err != nil {
		return fmt.Errorf("NodeData_DomainID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData_Assignments []NodeData_Assignments_AnyOf_Item

func (n NodeData_Assignments) Validate() error {
	if n == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	for i, item := range n {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NodeData_Assignments_AnyOf_Item struct {
	NodeData_Assignments_AnyOf_AnyOf *NodeData_Assignments_AnyOf_AnyOf `json:"-"`
}

func (n NodeData_Assignments_AnyOf_Item) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_Assignments_AnyOf_AnyOf != nil {
		if v, ok := any(n.NodeData_Assignments_AnyOf_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_Assignments_AnyOf_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_Assignments_AnyOf_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_Assignments_AnyOf_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_Assignments_AnyOf_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_Assignments_AnyOf_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_Assignments_AnyOf_AnyOf == nil {
		n.NodeData_Assignments_AnyOf_AnyOf = &NodeData_Assignments_AnyOf_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_Assignments_AnyOf_AnyOf); err != nil {
		return fmt.Errorf("NodeData_Assignments_AnyOf_AnyOf unmarshal: %w", err)
	}

	return nil
}

type OutputPort struct {
	ID            uuid.UUID            `json:"id" validate:"required"`
	Name          string               `json:"name" validate:"required"`
	Namespace     string               `json:"namespace" validate:"required"`
	Description   string               `json:"description" validate:"required"`
	Status        OutputPortStatus     `json:"status" validate:"required"`
	AccessType    OutputPortAccessType `json:"access_type" validate:"required"`
	DataProductID uuid.UUID            `json:"data_product_id" validate:"required"`
	Tags          []Tag                `json:"tags" validate:"required"`
}

func (o OutputPort) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(o.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(o.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(o.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(o.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(o.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if v, ok := any(o.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	for i, item := range o.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQueries struct {
	OutputPortCuratedQueries []OutputPortCuratedQuery `json:"output_port_curated_queries" validate:"required"`
}

func (o OutputPortCuratedQueries) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range o.OutputPortCuratedQueries {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortCuratedQueries[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQueriesUpdate struct {
	CuratedQueries []OutputPortCuratedQueryInput `json:"curated_queries" validate:"required"`
}

func (o OutputPortCuratedQueriesUpdate) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range o.CuratedQueries {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("CuratedQueries[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQuery struct {
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
	SortOrder    int       `json:"sort_order" validate:"required"`
	Title        string    `json:"title" validate:"required"`
	Description  string    `json:"description"`
	QueryText    string    `json:"query_text" validate:"required"`
	CreatedAt    time.Time `json:"created_at" validate:"required"`
	UpdatedAt    time.Time `json:"updated_at"`
}

func (o OutputPortCuratedQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if err := typesValidator.Var(o.SortOrder, "required"); err != nil {
		errors = errors.Append("SortOrder", err)
	}
	if err := typesValidator.Var(o.Title, "required"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(o.QueryText, "required"); err != nil {
		errors = errors.Append("QueryText", err)
	}
	if err := typesValidator.Var(o.CreatedAt, "required"); err != nil {
		errors = errors.Append("CreatedAt", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQueryInput struct {
	Title       string  `json:"title" validate:"required"`
	Description *string `json:"description,omitempty"`
	QueryText   string  `json:"query_text" validate:"required"`
}

func (o OutputPortCuratedQueryInput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(o))
}

type OutputPortLink struct {
	ID               uuid.UUID      `json:"id" validate:"required"`
	OutputPortID     uuid.UUID      `json:"output_port_id" validate:"required"`
	TechnicalAssetID uuid.UUID      `json:"technical_asset_id" validate:"required"`
	Status           DecisionStatus `json:"status" validate:"required"`
	Output           OutputPort     `json:"output"`
}

func (o OutputPortLink) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(o.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(o.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if v, ok := any(o.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(o.Output).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Output", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsDelete struct {
	Date                  string    `json:"date" validate:"required"`
	ConsumerDataProductID uuid.UUID `json:"consumer_data_product_id" validate:"required"`
}

func (o OutputPortQueryStatsDelete) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.Date, "required"); err != nil {
		errors = errors.Append("Date", err)
	}
	if v, ok := any(o.ConsumerDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumerDataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsResponse struct {
	Date                    runtime.Date `json:"date" validate:"required"`
	ConsumerDataProductID   uuid.UUID    `json:"consumer_data_product_id" validate:"required"`
	QueryCount              int          `json:"query_count" validate:"required"`
	ConsumerDataProductName *string      `json:"consumer_data_product_name,omitempty"`
}

func (o OutputPortQueryStatsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.Date).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Date", err)
		}
	}
	if v, ok := any(o.ConsumerDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumerDataProductID", err)
		}
	}
	if err := typesValidator.Var(o.QueryCount, "required"); err != nil {
		errors = errors.Append("QueryCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsResponses struct {
	OutputPortQueryStatsResponses []OutputPortQueryStatsResponse `json:"output_port_query_stats_responses" validate:"required"`
}

func (o OutputPortQueryStatsResponses) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range o.OutputPortQueryStatsResponses {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortQueryStatsResponses[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsUpdate struct {
	Date                  string    `json:"date" validate:"required"`
	ConsumerDataProductID uuid.UUID `json:"consumer_data_product_id" validate:"required"`
	QueryCount            int       `json:"query_count" validate:"required"`
}

func (o OutputPortQueryStatsUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.Date, "required"); err != nil {
		errors = errors.Append("Date", err)
	}
	if v, ok := any(o.ConsumerDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumerDataProductID", err)
		}
	}
	if err := typesValidator.Var(o.QueryCount, "required"); err != nil {
		errors = errors.Append("QueryCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortRoleAssignmentResponse struct {
	ID          uuid.UUID      `json:"id" validate:"required"`
	OutputPort  OutputPort     `json:"output_port"`
	User        User           `json:"user"`
	Role        Role           `json:"role"`
	Decision    DecisionStatus `json:"decision" validate:"required"`
	RequestedOn time.Time      `json:"requested_on"`
	RequestedBy User           `json:"requested_by"`
	DecidedOn   time.Time      `json:"decided_on"`
	DecidedBy   User           `json:"decided_by"`
}

func (o OutputPortRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(o.OutputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPort", err)
		}
	}
	if v, ok := any(o.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(o.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(o.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(o.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(o.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortSettingValue struct {
	ID                   uuid.UUID          `json:"id" validate:"required"`
	DataProductSettingID uuid.UUID          `json:"data_product_setting_id" validate:"required"`
	Value                string             `json:"value" validate:"required"`
	DataProductSetting   DataProductSetting `json:"data_product_setting"`
	OutputPortID         uuid.UUID          `json:"output_port_id" validate:"required"`
}

func (o OutputPortSettingValue) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(o.DataProductSettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSettingID", err)
		}
	}
	if err := typesValidator.Var(o.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if v, ok := any(o.DataProductSetting).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSetting", err)
		}
	}
	if v, ok := any(o.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PendingActionResponse struct {
	PendingActions PendingActionResponse_PendingActions `json:"pending_actions" validate:"required"`
}

func (p PendingActionResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.PendingActions).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PendingActions", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PendingActionResponse_PendingActions []PendingActionResponse_PendingActions_Item

func (p PendingActionResponse_PendingActions) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PendingActionResponse_PendingActions_Item struct {
	PendingActionResponse_PendingActions_AnyOf *PendingActionResponse_PendingActions_AnyOf `json:"-"`
}

func (p PendingActionResponse_PendingActions_Item) Validate() error {
	var errors runtime.ValidationErrors
	if p.PendingActionResponse_PendingActions_AnyOf != nil {
		if v, ok := any(p.PendingActionResponse_PendingActions_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PendingActionResponse_PendingActions_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (p PendingActionResponse_PendingActions_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(p.PendingActionResponse_PendingActions_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("PendingActionResponse_PendingActions_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (p *PendingActionResponse_PendingActions_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if p.PendingActionResponse_PendingActions_AnyOf == nil {
		p.PendingActionResponse_PendingActions_AnyOf = &PendingActionResponse_PendingActions_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, p.PendingActionResponse_PendingActions_AnyOf); err != nil {
		return fmt.Errorf("PendingActionResponse_PendingActions_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Platform struct {
	ID   uuid.UUID `json:"id" validate:"required"`
	Name string    `json:"name" validate:"required"`
}

func (p Platform) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(p.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PlatformService struct {
	ID                    uuid.UUID `json:"id" validate:"required"`
	Name                  string    `json:"name" validate:"required"`
	Platform              Platform  `json:"platform"`
	ResultStringTemplate  string    `json:"result_string_template" validate:"required"`
	TechnicalInfoTemplate string    `json:"technical_info_template" validate:"required"`
}

func (p PlatformService) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(p.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(p.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if err := typesValidator.Var(p.ResultStringTemplate, "required"); err != nil {
		errors = errors.Append("ResultStringTemplate", err)
	}
	if err := typesValidator.Var(p.TechnicalInfoTemplate, "required"); err != nil {
		errors = errors.Append("TechnicalInfoTemplate", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PlatformServiceConfiguration struct {
	ID       uuid.UUID       `json:"id" validate:"required"`
	Platform Platform        `json:"platform"`
	Service  PlatformService `json:"service"`
	Config   []string        `json:"config" validate:"required"`
}

func (p PlatformServiceConfiguration) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(p.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if v, ok := any(p.Service).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Service", err)
		}
	}
	if err := typesValidator.Var(p.Config, "required"); err != nil {
		errors = errors.Append("Config", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// PlatformTile Represents a platform tile in the UI
type PlatformTile struct {
	Label     string         `json:"label" validate:"required"`
	Value     string         `json:"value" validate:"required"`
	IconName  string         `json:"icon_name" validate:"required"`
	HasMenu   *bool          `json:"has_menu,omitempty"`
	HasConfig *bool          `json:"has_config,omitempty"`
	Children  []PlatformTile `json:"children,omitempty"`
}

func (p PlatformTile) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(p.Label, "required"); err != nil {
		errors = errors.Append("Label", err)
	}
	if err := typesValidator.Var(p.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(p.IconName, "required"); err != nil {
		errors = errors.Append("IconName", err)
	}
	for i, item := range p.Children {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Children[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// PlatformTileResponse Response model for platform tiles
type PlatformTileResponse struct {
	PlatformTiles []PlatformTile `json:"platform_tiles" validate:"required"`
}

func (p PlatformTileResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range p.PlatformTiles {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("PlatformTiles[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// PluginResponse Response model for listing available plugins
type PluginResponse struct {
	Plugins []UIElementMetadataResponse `json:"plugins" validate:"required"`
}

func (p PluginResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range p.Plugins {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Plugins[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RedshiftConfig struct {
	Identifier       string `json:"identifier" validate:"required"`
	DatabaseName     string `json:"database_name" validate:"required"`
	BucketIdentifier string `json:"bucket_identifier" validate:"required"`
	S3Path           string `json:"s3_path" validate:"required"`
}

func (r RedshiftConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type RedshiftDataOutput struct {
	ConfigurationType string            `json:"configuration_type" validate:"required"`
	Database          string            `json:"database" validate:"required"`
	Schema            *string           `json:"schema,omitempty"`
	Table             *string           `json:"table,omitempty"`
	BucketIdentifier  *string           `json:"bucket_identifier,omitempty"`
	DatabasePath      *string           `json:"database_path,omitempty"`
	TablePath         *string           `json:"table_path,omitempty"`
	AccessGranularity AccessGranularity `json:"access_granularity" validate:"required"`
}

func (r RedshiftDataOutput) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(r.ConfigurationType, "required"); err != nil {
		errors = errors.Append("ConfigurationType", err)
	}
	if err := typesValidator.Var(r.Database, "required"); err != nil {
		errors = errors.Append("Database", err)
	}
	if v, ok := any(r.AccessGranularity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessGranularity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveOutputPortAsInputPortRequest struct {
	ConsumingDataProductID uuid.UUID `json:"consuming_data_product_id" validate:"required"`
}

func (r RemoveOutputPortAsInputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ConsumingDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumingDataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RequestDataProductRoleAssignment struct {
	UserID        uuid.UUID `json:"user_id" validate:"required"`
	RoleID        uuid.UUID `json:"role_id" validate:"required"`
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (r RequestDataProductRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(r.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(r.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RequestOutputPortRoleAssignment struct {
	UserID       uuid.UUID `json:"user_id" validate:"required"`
	RoleID       uuid.UUID `json:"role_id" validate:"required"`
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
}

func (r RequestOutputPortRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(r.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(r.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ResourceNameLengthLimits struct {
	MaxLength int `json:"max_length" validate:"required"`
}

func (r ResourceNameLengthLimits) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type ResourceNameSuggestion struct {
	ResourceName string `json:"resource_name" validate:"required"`
}

func (r ResourceNameSuggestion) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type ResourceNameValidation struct {
	Validity ResourceNameValidityType `json:"validity" validate:"required"`
}

func (r ResourceNameValidation) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.Validity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Validity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ResourceNameValidationRequest struct {
	ResourceName  string            `json:"resource_name" validate:"required"`
	DataProductID *uuid.UUID        `json:"data_product_id,omitempty"`
	Model         ResourceNameModel `json:"model" validate:"required"`
}

func (r ResourceNameValidationRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(r.ResourceName, "required"); err != nil {
		errors = errors.Append("ResourceName", err)
	}
	if r.DataProductID != nil {
		if v, ok := any(r.DataProductID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataProductID", err)
			}
		}
	}
	if v, ok := any(r.Model).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Model", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Role struct {
	Name        string                `json:"name" validate:"required"`
	Scope       Scope                 `json:"scope" validate:"required"`
	Description string                `json:"description" validate:"required"`
	Permissions []AuthorizationAction `json:"permissions" validate:"required"`
	ID          uuid.UUID             `json:"id" validate:"required"`
	Prototype   Prototype             `json:"prototype" validate:"required"`
}

func (r Role) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(r.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(r.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if err := typesValidator.Var(r.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	for i, item := range r.Permissions {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Permissions[%d]", i), err)
			}
		}
	}
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(r.Prototype).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Prototype", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type S3DataOutput struct {
	ConfigurationType string  `json:"configuration_type" validate:"required"`
	Bucket            string  `json:"bucket" validate:"required"`
	Suffix            *string `json:"suffix,omitempty"`
	Path              string  `json:"path" validate:"required"`
}

func (s S3DataOutput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchOutputPortsResponse struct {
	OutputPorts []SearchOutputPortsResponseItem `json:"output_ports" validate:"required"`
}

func (s SearchOutputPortsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range s.OutputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchOutputPortsResponseItem struct {
	ID                  uuid.UUID                `json:"id" validate:"required"`
	Namespace           string                   `json:"namespace" validate:"required"`
	Name                string                   `json:"name" validate:"required"`
	Description         string                   `json:"description" validate:"required"`
	Status              OutputPortStatus         `json:"status" validate:"required"`
	Usage               string                   `json:"usage"`
	AccessType          OutputPortAccessType     `json:"access_type" validate:"required"`
	DataProductID       uuid.UUID                `json:"data_product_id" validate:"required"`
	Tags                []Tag                    `json:"tags" validate:"required"`
	Domain              Domain                   `json:"domain"`
	Lifecycle           DataProductLifeCycle     `json:"lifecycle"`
	DataProductSettings []OutputPortSettingValue `json:"data_product_settings" validate:"required"`
	TechnicalAssetLinks []TechnicalAssetLink     `json:"technical_asset_links" validate:"required"`
	DataProductCount    int                      `json:"data_product_count" validate:"required"`
	DataProductName     string                   `json:"data_product_name" validate:"required"`
}

func (s SearchOutputPortsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(s.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(s.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(s.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(s.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(s.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if v, ok := any(s.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	for i, item := range s.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(s.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(s.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range s.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	for i, item := range s.TechnicalAssetLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalAssetLinks[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(s.DataProductCount, "required"); err != nil {
		errors = errors.Append("DataProductCount", err)
	}
	if err := typesValidator.Var(s.DataProductName, "required"); err != nil {
		errors = errors.Append("DataProductName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// SelectOption Option for select UI elements
type SelectOption struct {
	Label string             `json:"label" validate:"required"`
	Value SelectOption_Value `json:"value"`
}

func (s SelectOption) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.Label, "required"); err != nil {
		errors = errors.Append("Label", err)
	}
	if v, ok := any(s.Value).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Value", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SelectOption_Value struct {
	SelectOption_Value_AnyOf *SelectOption_Value_AnyOf `json:"-"`
}

func (s SelectOption_Value) Validate() error {
	var errors runtime.ValidationErrors
	if s.SelectOption_Value_AnyOf != nil {
		if v, ok := any(s.SelectOption_Value_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("SelectOption_Value_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (s SelectOption_Value) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(s.SelectOption_Value_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("SelectOption_Value_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (s *SelectOption_Value) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if s.SelectOption_Value_AnyOf == nil {
		s.SelectOption_Value_AnyOf = &SelectOption_Value_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, s.SelectOption_Value_AnyOf); err != nil {
		return fmt.Errorf("SelectOption_Value_AnyOf unmarshal: %w", err)
	}

	return nil
}

type SnowflakeConfig struct {
	Identifier   string `json:"identifier" validate:"required"`
	DatabaseName string `json:"database_name" validate:"required"`
}

func (s SnowflakeConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SnowflakeDataOutput struct {
	ConfigurationType string            `json:"configuration_type" validate:"required"`
	Database          string            `json:"database" validate:"required"`
	Schema            *string           `json:"schema,omitempty"`
	Table             *string           `json:"table,omitempty"`
	BucketIdentifier  *string           `json:"bucket_identifier,omitempty"`
	DatabasePath      *string           `json:"database_path,omitempty"`
	TablePath         *string           `json:"table_path,omitempty"`
	AccessGranularity AccessGranularity `json:"access_granularity" validate:"required"`
}

func (s SnowflakeDataOutput) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.ConfigurationType, "required"); err != nil {
		errors = errors.Append("ConfigurationType", err)
	}
	if err := typesValidator.Var(s.Database, "required"); err != nil {
		errors = errors.Append("Database", err)
	}
	if v, ok := any(s.AccessGranularity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessGranularity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Tag struct {
	ID    uuid.UUID `json:"id" validate:"required"`
	Value string    `json:"value" validate:"required"`
}

func (t Tag) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(t.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TagCreate struct {
	Value string `json:"value" validate:"required"`
}

func (t TagCreate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type TagUpdate struct {
	Value string `json:"value" validate:"required"`
}

func (t TagUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type TagsGet struct {
	Tags []TagsGetItem `json:"tags" validate:"required"`
}

func (t TagsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range t.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TagsGetItem struct {
	ID    uuid.UUID `json:"id" validate:"required"`
	Value string    `json:"value" validate:"required"`
}

func (t TagsGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(t.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalAsset struct {
	ID               uuid.UUID                    `json:"id" validate:"required"`
	Name             string                       `json:"name" validate:"required"`
	Namespace        string                       `json:"namespace" validate:"required"`
	Description      string                       `json:"description" validate:"required"`
	Status           TechnicalAssetStatus         `json:"status" validate:"required"`
	TechnicalMapping TechnicalMapping             `json:"technical_mapping" validate:"required"`
	OwnerID          uuid.UUID                    `json:"owner_id" validate:"required"`
	PlatformID       uuid.UUID                    `json:"platform_id" validate:"required"`
	ServiceID        uuid.UUID                    `json:"service_id" validate:"required"`
	Configuration    TechnicalAsset_Configuration `json:"configuration"`
}

func (t TechnicalAsset) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(t.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(t.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(t.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(t.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(t.TechnicalMapping).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalMapping", err)
		}
	}
	if v, ok := any(t.OwnerID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OwnerID", err)
		}
	}
	if v, ok := any(t.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(t.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if v, ok := any(t.Configuration).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Configuration", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalAsset_Configuration struct {
	TechnicalAsset_Configuration_OneOf *TechnicalAsset_Configuration_OneOf `json:"-"`
}

func (t TechnicalAsset_Configuration) Validate() error {
	var errors runtime.ValidationErrors
	if t.TechnicalAsset_Configuration_OneOf != nil {
		if v, ok := any(t.TechnicalAsset_Configuration_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TechnicalAsset_Configuration_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (t TechnicalAsset_Configuration) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(t.TechnicalAsset_Configuration_OneOf)
		if err != nil {
			return nil, fmt.Errorf("TechnicalAsset_Configuration_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (t *TechnicalAsset_Configuration) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if t.TechnicalAsset_Configuration_OneOf == nil {
		t.TechnicalAsset_Configuration_OneOf = &TechnicalAsset_Configuration_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, t.TechnicalAsset_Configuration_OneOf); err != nil {
		return fmt.Errorf("TechnicalAsset_Configuration_OneOf unmarshal: %w", err)
	}

	return nil
}

type TechnicalAssetLink struct {
	ID               uuid.UUID      `json:"id" validate:"required"`
	OutputPortID     uuid.UUID      `json:"output_port_id" validate:"required"`
	TechnicalAssetID uuid.UUID      `json:"technical_asset_id" validate:"required"`
	Status           DecisionStatus `json:"status" validate:"required"`
	TechnicalAsset   TechnicalAsset `json:"technical_asset"`
}

func (t TechnicalAssetLink) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(t.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(t.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if v, ok := any(t.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(t.TechnicalAsset).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAsset", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalAssetOutputPortPendingAction struct {
	ID                uuid.UUID      `json:"id" validate:"required"`
	OutputPortID      uuid.UUID      `json:"output_port_id" validate:"required"`
	TechnicalAssetID  uuid.UUID      `json:"technical_asset_id" validate:"required"`
	Status            DecisionStatus `json:"status" validate:"required"`
	RequestedOn       time.Time      `json:"requested_on" validate:"required"`
	DeniedOn          time.Time      `json:"denied_on"`
	ApprovedOn        time.Time      `json:"approved_on"`
	RequestedBy       User           `json:"requested_by"`
	DeniedBy          User           `json:"denied_by"`
	ApprovedBy        User           `json:"approved_by"`
	PendingActionType *string        `json:"pending_action_type,omitempty"`
}

func (t TechnicalAssetOutputPortPendingAction) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(t.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(t.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if v, ok := any(t.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if err := typesValidator.Var(t.RequestedOn, "required"); err != nil {
		errors = errors.Append("RequestedOn", err)
	}
	if v, ok := any(t.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(t.DeniedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DeniedBy", err)
		}
	}
	if v, ok := any(t.ApprovedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ApprovedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalInfo struct {
	EnvironmentID uuid.UUID `json:"environment_id" validate:"required"`
	Environment   string    `json:"environment" validate:"required"`
	Info          string    `json:"info"`
}

func (t TechnicalInfo) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.EnvironmentID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("EnvironmentID", err)
		}
	}
	if err := typesValidator.Var(t.Environment, "required"); err != nil {
		errors = errors.Append("Environment", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ThemeSettings struct {
	PortalName string `json:"portal_name" validate:"required"`
}

func (t ThemeSettings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type UIElementCheckbox struct {
	InitialValue *bool `json:"initial_value,omitempty"`
}

type UIElementMetadata struct {
	Label                            string             `json:"label" validate:"required"`
	Type                             UIElementType      `json:"type" validate:"required"`
	Required                         bool               `json:"required"`
	Name                             string             `json:"name" validate:"required"`
	Tooltip                          *string            `json:"tooltip,omitempty"`
	Hidden                           *bool              `json:"hidden,omitempty"`
	Checkbox                         *UIElementCheckbox `json:"checkbox,omitempty"`
	Select                           *UIElementSelect   `json:"select,omitempty"`
	String                           *UIElementString   `json:"string,omitempty"`
	Radio                            *UIElementRadio    `json:"radio,omitempty"`
	DependsOn                        []FieldDependency  `json:"depends_on,omitempty"`
	Disabled                         *bool              `json:"disabled,omitempty"`
	UseNamespaceWhenNotSourceAligned *bool              `json:"use_namespace_when_not_source_aligned,omitempty"`
}

func (u UIElementMetadata) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(u.Label, "required"); err != nil {
		errors = errors.Append("Label", err)
	}
	if v, ok := any(u.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(u.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if u.Checkbox != nil {
		if v, ok := any(u.Checkbox).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Checkbox", err)
			}
		}
	}
	if u.Select != nil {
		if v, ok := any(u.Select).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Select", err)
			}
		}
	}
	if u.String != nil {
		if v, ok := any(u.String).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("String", err)
			}
		}
	}
	if u.Radio != nil {
		if v, ok := any(u.Radio).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Radio", err)
			}
		}
	}
	for i, item := range u.DependsOn {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DependsOn[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UIElementMetadataResponse struct {
	NotConfigured  *bool               `json:"not_configured,omitempty"`
	UIMetadata     []UIElementMetadata `json:"ui_metadata" validate:"required"`
	Plugin         string              `json:"plugin" validate:"required"`
	ResultLabel    *string             `json:"result_label,omitempty"`
	ResultTooltip  *string             `json:"result_tooltip,omitempty"`
	Platform       string              `json:"platform" validate:"required"`
	DisplayName    string              `json:"display_name" validate:"required"`
	IconName       string              `json:"icon_name" validate:"required"`
	ParentPlatform *string             `json:"parent_platform,omitempty"`
	PlatformTile   *PlatformTile       `json:"platform_tile,omitempty"`
	DetailedName   string              `json:"detailed_name" validate:"required"`
}

func (u UIElementMetadataResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.UIMetadata {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("UIMetadata[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(u.Plugin, "required"); err != nil {
		errors = errors.Append("Plugin", err)
	}
	if err := typesValidator.Var(u.Platform, "required"); err != nil {
		errors = errors.Append("Platform", err)
	}
	if err := typesValidator.Var(u.DisplayName, "required"); err != nil {
		errors = errors.Append("DisplayName", err)
	}
	if err := typesValidator.Var(u.IconName, "required"); err != nil {
		errors = errors.Append("IconName", err)
	}
	if u.PlatformTile != nil {
		if v, ok := any(u.PlatformTile).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PlatformTile", err)
			}
		}
	}
	if err := typesValidator.Var(u.DetailedName, "required"); err != nil {
		errors = errors.Append("DetailedName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UIElementRadio struct {
	MaxCount     *int           `json:"max_count,omitempty"`
	InitialValue *string        `json:"initial_value,omitempty"`
	Options      []SelectOption `json:"options,omitempty"`
}

func (u UIElementRadio) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.Options {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Options[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UIElementSelect struct {
	MaxCount *int           `json:"max_count,omitempty"`
	Options  []SelectOption `json:"options,omitempty"`
}

func (u UIElementSelect) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.Options {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Options[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UIElementString struct {
	InitialValue *string `json:"initial_value,omitempty"`
}

type UnLinkTechnicalAssetToOutputPortRequest struct {
	TechnicalAssetID uuid.UUID `json:"technical_asset_id" validate:"required"`
}

func (u UnLinkTechnicalAssetToOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductLifeCycleResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductLifeCycleResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductSettingResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductSettingResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductTypeResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductTypeResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDomainResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDomainResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortQueryStatus struct {
	OutputPortQueryStatsUpdates []OutputPortQueryStatsUpdate `json:"output_port_query_stats_updates" validate:"required"`
}

func (u UpdateOutputPortQueryStatus) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.OutputPortQueryStatsUpdates {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortQueryStatsUpdates[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateRole struct {
	Name        *string               `json:"name,omitempty"`
	Description *string               `json:"description,omitempty"`
	Permissions []AuthorizationAction `json:"permissions,omitempty"`
}

func (u UpdateRole) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.Permissions {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Permissions[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateTagResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateTagResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type User struct {
	ID             uuid.UUID     `json:"id" validate:"required"`
	Email          runtime.Email `json:"email" validate:"required"`
	ExternalID     string        `json:"external_id" validate:"required"`
	FirstName      string        `json:"first_name" validate:"required"`
	LastName       string        `json:"last_name" validate:"required"`
	HasSeenTour    bool          `json:"has_seen_tour"`
	CanBecomeAdmin bool          `json:"can_become_admin"`
	AdminExpiry    *time.Time    `json:"admin_expiry,omitempty"`
}

func (u User) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.ExternalID, "required"); err != nil {
		errors = errors.Append("ExternalID", err)
	}
	if err := typesValidator.Var(u.FirstName, "required"); err != nil {
		errors = errors.Append("FirstName", err)
	}
	if err := typesValidator.Var(u.LastName, "required"); err != nil {
		errors = errors.Append("LastName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserCreate struct {
	Email      runtime.Email `json:"email" validate:"required"`
	ExternalID string        `json:"external_id" validate:"required"`
	FirstName  string        `json:"first_name" validate:"required"`
	LastName   string        `json:"last_name" validate:"required"`
}

func (u UserCreate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.ExternalID, "required"); err != nil {
		errors = errors.Append("ExternalID", err)
	}
	if err := typesValidator.Var(u.FirstName, "required"); err != nil {
		errors = errors.Append("FirstName", err)
	}
	if err := typesValidator.Var(u.LastName, "required"); err != nil {
		errors = errors.Append("LastName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserCreateResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UserCreateResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UsersGet struct {
	ID             uuid.UUID                    `json:"id" validate:"required"`
	Email          runtime.Email                `json:"email" validate:"required"`
	ExternalID     string                       `json:"external_id" validate:"required"`
	FirstName      string                       `json:"first_name" validate:"required"`
	LastName       string                       `json:"last_name" validate:"required"`
	HasSeenTour    bool                         `json:"has_seen_tour"`
	CanBecomeAdmin bool                         `json:"can_become_admin"`
	AdminExpiry    *time.Time                   `json:"admin_expiry,omitempty"`
	GlobalRole     GlobalRoleAssignmentResponse `json:"global_role"`
}

func (u UsersGet) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.ExternalID, "required"); err != nil {
		errors = errors.Append("ExternalID", err)
	}
	if err := typesValidator.Var(u.FirstName, "required"); err != nil {
		errors = errors.Append("FirstName", err)
	}
	if err := typesValidator.Var(u.LastName, "required"); err != nil {
		errors = errors.Append("LastName", err)
	}
	if v, ok := any(u.GlobalRole).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("GlobalRole", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError struct {
	Loc  ValidationError_Loc `json:"loc" validate:"required"`
	Msg  string              `json:"msg" validate:"required"`
	Type string              `json:"type" validate:"required"`
}

func (v ValidationError) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(v.Loc).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Loc", err)
		}
	}
	if err := typesValidator.Var(v.Msg, "required"); err != nil {
		errors = errors.Append("Msg", err)
	}
	if err := typesValidator.Var(v.Type, "required"); err != nil {
		errors = errors.Append("Type", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError_Loc []ValidationError_Loc_Item

func (v ValidationError_Loc) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range v {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError_Loc_Item struct {
	ValidationError_Loc_AnyOf *ValidationError_Loc_AnyOf `json:"-"`
}

func (v ValidationError_Loc_Item) Validate() error {
	var errors runtime.ValidationErrors
	if v.ValidationError_Loc_AnyOf != nil {
		if v, ok := any(v.ValidationError_Loc_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("ValidationError_Loc_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (v ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(v.ValidationError_Loc_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("ValidationError_Loc_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (v *ValidationError_Loc_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if v.ValidationError_Loc_AnyOf == nil {
		v.ValidationError_Loc_AnyOf = &ValidationError_Loc_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, v.ValidationError_Loc_AnyOf); err != nil {
		return fmt.Errorf("ValidationError_Loc_AnyOf unmarshal: %w", err)
	}

	return nil
}

type AppAuthorizationRoleAssignmentsDataProductSchemaListRoleAssignmentsResponse struct {
	RoleAssignments []DataProductRoleAssignmentResponse `json:"role_assignments" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaListRoleAssignmentsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range a.RoleAssignments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RoleAssignments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignment struct {
	ID            uuid.UUID      `json:"id" validate:"required"`
	DataProduct   DataProduct    `json:"data_product"`
	User          User           `json:"user"`
	Role          Role           `json:"role"`
	Decision      DecisionStatus `json:"decision" validate:"required"`
	RequestedOn   time.Time      `json:"requested_on"`
	RequestedBy   User           `json:"requested_by"`
	DecidedOn     time.Time      `json:"decided_on"`
	DecidedBy     User           `json:"decided_by"`
	DataProductID uuid.UUID      `json:"data_product_id" validate:"required"`
	UserID        uuid.UUID      `json:"user_id" validate:"required"`
	RoleID        uuid.UUID      `json:"role_id"`
	RequestedByID uuid.UUID      `json:"requested_by_id"`
	DecidedByID   uuid.UUID      `json:"decided_by_id"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(a.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(a.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(a.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(a.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(a.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if v, ok := any(a.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.RequestedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedByID", err)
		}
	}
	if v, ok := any(a.DecidedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedByID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsGlobalSchemaListRoleAssignmentsResponse struct {
	RoleAssignments []GlobalRoleAssignmentResponse `json:"role_assignments" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaListRoleAssignmentsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range a.RoleAssignments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RoleAssignments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaListRoleAssignmentsResponse struct {
	RoleAssignments []OutputPortRoleAssignmentResponse `json:"role_assignments" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaListRoleAssignmentsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range a.RoleAssignments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RoleAssignments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignment struct {
	ID            uuid.UUID      `json:"id" validate:"required"`
	OutputPort    OutputPort     `json:"output_port"`
	User          User           `json:"user"`
	Role          Role           `json:"role"`
	Decision      DecisionStatus `json:"decision" validate:"required"`
	RequestedOn   time.Time      `json:"requested_on"`
	RequestedBy   User           `json:"requested_by"`
	DecidedOn     time.Time      `json:"decided_on"`
	DecidedBy     User           `json:"decided_by"`
	OutputPortID  uuid.UUID      `json:"output_port_id" validate:"required"`
	UserID        uuid.UUID      `json:"user_id" validate:"required"`
	RoleID        uuid.UUID      `json:"role_id"`
	RequestedByID uuid.UUID      `json:"requested_by_id"`
	DecidedByID   uuid.UUID      `json:"decided_by_id"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(a.OutputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPort", err)
		}
	}
	if v, ok := any(a.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(a.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(a.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(a.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if v, ok := any(a.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.RequestedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedByID", err)
		}
	}
	if v, ok := any(a.DecidedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedByID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}
