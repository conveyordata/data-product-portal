// Code generated by oapi-codegen. DO NOT EDIT.

package portalsdk

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
)

// Client is the client for the API implementing the Client interface.
type Client struct {
	apiClient runtime.APIClient
}

// NewClient creates a new instance of the Client client.
func NewClient(apiClient runtime.APIClient) *Client {
	return &Client{apiClient: apiClient}
}

// NewDefaultClient creates a new instance of the Client client with default api client.
func NewDefaultClient(baseURL string, opts ...runtime.APIClientOption) (*Client, error) {
	apiClient, err := runtime.NewAPIClient(baseURL, opts...)
	if err != nil {
		return nil, fmt.Errorf("error creating API client: %w", err)
	}
	return &Client{apiClient: apiClient}, nil
}

// ClientInterface is the interface for the API client.
type ClientInterface interface {
	// CheckAccess Check Access
	CheckAccess(ctx context.Context, options *CheckAccessRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CheckAccessResponse, error)

	// IsAdmin Is Admin
	IsAdmin(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*IsAdminResponseJSON, error)

	// SearchOutputPorts Search Output Ports
	SearchOutputPorts(ctx context.Context, options *SearchOutputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SearchOutputPortsResponseJSON, error)

	// GetOutputPortQueryStats Get Output Port Query Stats
	GetOutputPortQueryStats(ctx context.Context, options *GetOutputPortQueryStatsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortQueryStatsResponse, error)

	// UpdateOutputPortQueryStats Update Output Port Query Stats
	UpdateOutputPortQueryStats(ctx context.Context, options *UpdateOutputPortQueryStatsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortQueryStatsResponse, error)

	// DeleteOutputPortQueryStat Delete Output Port Query Stat
	DeleteOutputPortQueryStat(ctx context.Context, options *DeleteOutputPortQueryStatRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteOutputPortQueryStatResponse, error)

	// GetOutputPortCuratedQueries Get Output Port Curated Queries
	GetOutputPortCuratedQueries(ctx context.Context, options *GetOutputPortCuratedQueriesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortCuratedQueriesResponse, error)

	// ReplaceOutputPortCuratedQueries Replace Output Port Curated Queries
	ReplaceOutputPortCuratedQueries(ctx context.Context, options *ReplaceOutputPortCuratedQueriesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ReplaceOutputPortCuratedQueriesResponse, error)

	// GetDataProductOutputPorts Get Data Product Output Ports
	GetDataProductOutputPorts(ctx context.Context, options *GetDataProductOutputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductOutputPortsResponseJSON, error)

	// CreateOutputPort Create Output Port
	CreateOutputPort(ctx context.Context, options *CreateOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateOutputPortResponseJSON, error)

	// GetOutputPort Get Output Port
	GetOutputPort(ctx context.Context, options *GetOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortResponseJSON, error)

	// RemoveDataset Remove Dataset
	RemoveDataset(ctx context.Context, options *RemoveDatasetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDatasetResponse, error)

	// UpdateOutputPort Update Output Port
	UpdateOutputPort(ctx context.Context, options *UpdateOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortResponseJSON, error)

	// GetOutputPortsEventHistory Get Output Ports Event History
	GetOutputPortsEventHistory(ctx context.Context, options *GetOutputPortsEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortsEventHistoryResponse, error)

	// UpdateOutputPortAbout Update Output Port About
	UpdateOutputPortAbout(ctx context.Context, options *UpdateOutputPortAboutRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortAboutResponse, error)

	// UpdateOutputPortStatus Update Output Port Status
	UpdateOutputPortStatus(ctx context.Context, options *UpdateOutputPortStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortStatusResponse, error)

	// GetOutputPortGraphData Get Output Port Graph Data
	GetOutputPortGraphData(ctx context.Context, options *GetOutputPortGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortGraphDataResponse, error)

	// SetValueForOutputPort Set Value For Output Port
	SetValueForOutputPort(ctx context.Context, options *SetValueForOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetValueForOutputPortResponse, error)

	// CreateDataProduct Create Data Product
	CreateDataProduct(ctx context.Context, options *CreateDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductResponseJSON, error)

	// GetDataProducts Get Data Products
	GetDataProducts(ctx context.Context, options *GetDataProductsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsResponseJSON, error)

	// RemoveDataProduct Remove Data Product
	RemoveDataProduct(ctx context.Context, options *RemoveDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductResponse, error)

	// UpdateDataProduct Update Data Product
	UpdateDataProduct(ctx context.Context, options *UpdateDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductResponseJSON, error)

	// GetDataProduct Get Data Product
	GetDataProduct(ctx context.Context, options *GetDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductResponseJSON, error)

	// UpdateDataProductAbout Update Data Product About
	UpdateDataProductAbout(ctx context.Context, options *UpdateDataProductAboutRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductAboutResponse, error)

	// UpdateDataProductStatus Update Data Product Status
	UpdateDataProductStatus(ctx context.Context, options *UpdateDataProductStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductStatusResponse, error)

	// UpdateDataProductUsage Update Data Product Usage
	UpdateDataProductUsage(ctx context.Context, options *UpdateDataProductUsageRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductUsageResponse, error)

	// GetDataProductGraphData Get Data Product Graph Data
	GetDataProductGraphData(ctx context.Context, options *GetDataProductGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductGraphDataResponse, error)

	// SetValueForDataProduct Set Value For Data Product
	SetValueForDataProduct(ctx context.Context, options *SetValueForDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetValueForDataProductResponse, error)

	// LinkInputPortsToDataProduct Link Input Ports To Data Product
	LinkInputPortsToDataProduct(ctx context.Context, options *LinkInputPortsToDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*LinkInputPortsToDataProductResponse, error)

	// GetDataProductEventHistory Get Data Product Event History
	GetDataProductEventHistory(ctx context.Context, options *GetDataProductEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductEventHistoryResponse, error)

	// CreateTechnicalAsset Create Technical Asset
	CreateTechnicalAsset(ctx context.Context, options *CreateTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateTechnicalAssetResponseJSON, error)

	// GetSigninURL Get Signin Url
	GetSigninURL(ctx context.Context, options *GetSigninURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSigninURLResponseJSON, error)

	// GetConveyorIdeURL Get Conveyor Ide Url
	GetConveyorIdeURL(ctx context.Context, options *GetConveyorIdeURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetConveyorIdeURLResponseJSON, error)

	// GetDatabricksWorkspaceURL Get Databricks Workspace Url
	GetDatabricksWorkspaceURL(ctx context.Context, options *GetDatabricksWorkspaceURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDatabricksWorkspaceURLResponseJSON, error)

	// GetSnowflakeURL Get Snowflake Url
	GetSnowflakeURL(ctx context.Context, options *GetSnowflakeURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSnowflakeURLResponseJSON, error)

	// GetTechnicalAssets Get Technical Assets
	GetTechnicalAssets(ctx context.Context, options *GetTechnicalAssetsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetsResponseJSON, error)

	// GetDataProductInputPorts Get Data Product Input Ports
	GetDataProductInputPorts(ctx context.Context, options *GetDataProductInputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductInputPortsResponseJSON, error)

	// GetDataProductRolledUpTags Get Data Product Rolled Up Tags
	GetDataProductRolledUpTags(ctx context.Context, options *GetDataProductRolledUpTagsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductRolledUpTagsResponseJSON, error)

	// UnlinkInputPortFromDataProduct Unlink Input Port From Data Product
	UnlinkInputPortFromDataProduct(ctx context.Context, options *UnlinkInputPortFromDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UnlinkInputPortFromDataProductResponse, error)

	// GetDataProductType Get Data Product Type
	GetDataProductType(ctx context.Context, options *GetDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductTypeResponse, error)

	// UpdateDataProductType Update Data Product Type
	UpdateDataProductType(ctx context.Context, options *UpdateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductTypeResponseJSON, error)

	// RemoveDataProductType Remove Data Product Type
	RemoveDataProductType(ctx context.Context, options *RemoveDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductTypeResponse, error)

	// GetDataProductsTypes Get Data Products Types
	GetDataProductsTypes(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsTypesResponse, error)

	// CreateDataProductType Create Data Product Type
	CreateDataProductType(ctx context.Context, options *CreateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductTypeResponseJSON, error)

	// MigrateDataProductType Migrate Data Product Type
	MigrateDataProductType(ctx context.Context, options *MigrateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*MigrateDataProductTypeResponse, error)

	// GetDataProductsLifecycles Get Data Products Lifecycles
	GetDataProductsLifecycles(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsLifecyclesResponse, error)

	// CreateDataProductLifecycle Create Data Product Lifecycle
	CreateDataProductLifecycle(ctx context.Context, options *CreateDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductLifecycleResponse, error)

	// UpdateDataProductLifecycle Update Data Product Lifecycle
	UpdateDataProductLifecycle(ctx context.Context, options *UpdateDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductLifecycleResponse, error)

	// RemoveDataProductLifecycle Remove Data Product Lifecycle
	RemoveDataProductLifecycle(ctx context.Context, options *RemoveDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductLifecycleResponse, error)

	// GetDataProductsSettings Get Data Products Settings
	GetDataProductsSettings(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsSettingsResponse, error)

	// CreateDataProductSetting Create Data Product Setting
	CreateDataProductSetting(ctx context.Context, options *CreateDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductSettingResponseJSON, error)

	// UpdateDataProductSetting Update Data Product Setting
	UpdateDataProductSetting(ctx context.Context, options *UpdateDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductSettingResponseJSON, error)

	// RemoveDataProductSetting Remove Data Product Setting
	RemoveDataProductSetting(ctx context.Context, options *RemoveDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductSettingResponse, error)

	// ApproveOutputPortAsInputPort Approve Output Port As Input Port
	ApproveOutputPortAsInputPort(ctx context.Context, options *ApproveOutputPortAsInputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ApproveOutputPortAsInputPortResponse, error)

	// DenyOutputPortAsInputPort Deny Output Port As Input Port
	DenyOutputPortAsInputPort(ctx context.Context, options *DenyOutputPortAsInputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DenyOutputPortAsInputPortResponse, error)

	// RemoveOutputPortAsInputPort Remove Output Port As Input Port
	RemoveOutputPortAsInputPort(ctx context.Context, options *RemoveOutputPortAsInputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveOutputPortAsInputPortResponse, error)

	// ApproveOutputPortTechnicalAssetLink Approve Output Port Technical Asset Link
	ApproveOutputPortTechnicalAssetLink(ctx context.Context, options *ApproveOutputPortTechnicalAssetLinkRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ApproveOutputPortTechnicalAssetLinkResponse, error)

	// DenyOutputPortTechnicalAssetLink Deny Output Port Technical Asset Link
	DenyOutputPortTechnicalAssetLink(ctx context.Context, options *DenyOutputPortTechnicalAssetLinkRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DenyOutputPortTechnicalAssetLinkResponse, error)

	// LinkOutputPortToTechnicalAsset Link Output Port To Technical Asset
	LinkOutputPortToTechnicalAsset(ctx context.Context, options *LinkOutputPortToTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*LinkOutputPortToTechnicalAssetResponse, error)

	// UnlinkOutputPortFromTechnicalAsset Unlink Output Port From Technical Asset
	UnlinkOutputPortFromTechnicalAsset(ctx context.Context, options *UnlinkOutputPortFromTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UnlinkOutputPortFromTechnicalAssetResponse, error)

	// GetTechnicalAsset Get Technical Asset
	GetTechnicalAsset(ctx context.Context, options *GetTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetResponse, error)

	// RemoveTechnicalAsset Remove Technical Asset
	RemoveTechnicalAsset(ctx context.Context, options *RemoveTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveTechnicalAssetResponse, error)

	// GetTechnicalAssetEventHistory Get Technical Asset Event History
	GetTechnicalAssetEventHistory(ctx context.Context, options *GetTechnicalAssetEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetEventHistoryResponse, error)

	// UpdateTechnicalAssetStatus Update Technical Asset Status
	UpdateTechnicalAssetStatus(ctx context.Context, options *UpdateTechnicalAssetStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateTechnicalAssetStatusResponse, error)

	// GetTechnicalAssetGraphData Get Technical Asset Graph Data
	GetTechnicalAssetGraphData(ctx context.Context, options *GetTechnicalAssetGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetGraphDataResponse, error)

	// GetDomains Get Domains
	GetDomains(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDomainsResponseJSON, error)

	// CreateDomain Create Domain
	CreateDomain(ctx context.Context, options *CreateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDomainResponseJSON, error)

	// UpdateDomain Update Domain
	UpdateDomain(ctx context.Context, options *UpdateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDomainResponseJSON, error)

	// RemoveDomain Remove Domain
	RemoveDomain(ctx context.Context, options *RemoveDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDomainResponse, error)

	// GetDomain Get Domain
	GetDomain(ctx context.Context, options *GetDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDomainResponseJSON, error)

	// MigrateDomain Migrate Domain
	MigrateDomain(ctx context.Context, options *MigrateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*MigrateDomainResponse, error)

	// GetEnvironment Get Environment
	GetEnvironment(ctx context.Context, options *GetEnvironmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentResponse, error)

	// GetEnvironmentConfigsByID Get Environment Configs By Id
	GetEnvironmentConfigsByID(ctx context.Context, options *GetEnvironmentConfigsByIDRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentConfigsByIDResponse, error)

	// GetEnvironmentPlatformServiceConfig Get Environment Platform Service Config
	GetEnvironmentPlatformServiceConfig(ctx context.Context, options *GetEnvironmentPlatformServiceConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformServiceConfigResponse, error)

	// GetEnvironmentPlatformConfig Get Environment Platform Config
	GetEnvironmentPlatformConfig(ctx context.Context, options *GetEnvironmentPlatformConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformConfigResponse, error)

	// GetEnvironments Get Environments
	GetEnvironments(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentsResponse, error)

	// GetEnvironmentConfigs Get Environment Configs
	GetEnvironmentConfigs(ctx context.Context, options *GetEnvironmentConfigsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentConfigsResponse, error)

	// GetEnvironmentPlatformServiceConfigForAllEnvs Get Environment Platform Service Config For All Envs
	GetEnvironmentPlatformServiceConfigForAllEnvs(ctx context.Context, options *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformServiceConfigForAllEnvsResponse, error)

	// GetPlatformServiceConfig Get Platform Service Config
	GetPlatformServiceConfig(ctx context.Context, options *GetPlatformServiceConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPlatformServiceConfigResponse, error)

	// GetSinglePlatformServiceConfiguration Get Single Platform Service Configuration
	GetSinglePlatformServiceConfiguration(ctx context.Context, options *GetSinglePlatformServiceConfigurationRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSinglePlatformServiceConfigurationResponse, error)

	// GetAllPlatformServiceConfigurations Get All Platform Service Configurations
	GetAllPlatformServiceConfigurations(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetAllPlatformServiceConfigurationsResponseJSON, error)

	// GetAllPlatforms Get All Platforms
	GetAllPlatforms(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetAllPlatformsResponseJSON, error)

	// GetPlatformServices Get Platform Services
	GetPlatformServices(ctx context.Context, options *GetPlatformServicesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPlatformServicesResponseJSON, error)

	// GetTags Get Tags
	GetTags(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetTagsResponse, error)

	// CreateTag Create Tag
	CreateTag(ctx context.Context, options *CreateTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateTagResponseJSON, error)

	// UpdateTag Update Tag
	UpdateTag(ctx context.Context, options *UpdateTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateTagResponseJSON, error)

	// RemoveTag Remove Tag
	RemoveTag(ctx context.Context, options *RemoveTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveTagResponse, error)

	// RemoveUser Remove User
	RemoveUser(ctx context.Context, options *RemoveUserRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveUserResponse, error)

	// GetUsers Get Users
	GetUsers(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetUsersResponseJSON, error)

	// CreateUser Create User
	CreateUser(ctx context.Context, options *CreateUserRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateUserResponse, error)

	// SetCanBecomeAdmin Set Can Become Admin
	SetCanBecomeAdmin(ctx context.Context, options *SetCanBecomeAdminRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetCanBecomeAdminResponse, error)

	// MarkTourAsSeen Mark Tour As Seen
	MarkTourAsSeen(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*MarkTourAsSeenResponse, error)

	// GetUserPendingActions Get User Pending Actions
	GetUserPendingActions(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetUserPendingActionsResponse, error)

	// GetCurrentUser Get Current User
	GetCurrentUser(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetCurrentUserResponse, error)

	// CreateRole Create Role
	CreateRole(ctx context.Context, options *CreateRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateRoleResponse, error)

	// RemoveRole Remove Role
	RemoveRole(ctx context.Context, options *RemoveRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveRoleResponse, error)

	// UpdateRole Update Role
	UpdateRole(ctx context.Context, options *UpdateRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateRoleResponse, error)

	// GetRoles Get Roles
	GetRoles(ctx context.Context, options *GetRolesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetRolesResponseJSON, error)

	// BecomeAdmin Become Admin
	BecomeAdmin(ctx context.Context, options *BecomeAdminRequestOptions, reqEditors ...runtime.RequestEditorFn) (*BecomeAdminResponse, error)

	// RevokeAdmin Revoke Admin
	RevokeAdmin(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*RevokeAdminResponse, error)

	// CreateGlobalRoleAssignment Create Global Role Assignment
	CreateGlobalRoleAssignment(ctx context.Context, options *CreateGlobalRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateGlobalRoleAssignmentResponse, error)

	// ListGlobalRoleAssignments List Global Role Assignments
	ListGlobalRoleAssignments(ctx context.Context, options *ListGlobalRoleAssignmentsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListGlobalRoleAssignmentsResponse, error)

	// DeleteGlobalRoleAssignment Delete Global Role Assignment
	DeleteGlobalRoleAssignment(ctx context.Context, options *DeleteGlobalRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteGlobalRoleAssignmentResponseJSON, error)

	// DecideGlobalRoleAssignment Decide Global Role Assignment
	DecideGlobalRoleAssignment(ctx context.Context, options *DecideGlobalRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideGlobalRoleAssignmentResponse, error)

	// ModifyGlobalRoleAssignment Modify Global Role Assignment
	ModifyGlobalRoleAssignment(ctx context.Context, options *ModifyGlobalRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyGlobalRoleAssignmentResponse, error)

	// DeleteDataProductRoleAssignment Delete Data Product Role Assignment
	DeleteDataProductRoleAssignment(ctx context.Context, options *DeleteDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteDataProductRoleAssignmentResponseJSON, error)

	// ModifyDataProductRoleAssignment Modify Data Product Role Assignment
	ModifyDataProductRoleAssignment(ctx context.Context, options *ModifyDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyDataProductRoleAssignmentResponse, error)

	// ListDataProductRoleAssignments List Data Product Role Assignments
	ListDataProductRoleAssignments(ctx context.Context, options *ListDataProductRoleAssignmentsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListDataProductRoleAssignmentsResponse, error)

	// CreateDataProductRoleAssignment Create Data Product Role Assignment
	CreateDataProductRoleAssignment(ctx context.Context, options *CreateDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductRoleAssignmentResponse, error)

	// RequestDataProductRoleAssignment Request Data Product Role Assignment
	RequestDataProductRoleAssignment(ctx context.Context, options *RequestDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RequestDataProductRoleAssignmentResponse, error)

	// DecideDataProductRoleAssignment Decide Data Product Role Assignment
	DecideDataProductRoleAssignment(ctx context.Context, options *DecideDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideDataProductRoleAssignmentResponse, error)

	// DeleteOutputPortRoleAssignment Delete Output Port Role Assignment
	DeleteOutputPortRoleAssignment(ctx context.Context, options *DeleteOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteOutputPortRoleAssignmentResponseJSON, error)

	// ModifyOutputPortRoleAssignment Modify Output Port Role Assignment
	ModifyOutputPortRoleAssignment(ctx context.Context, options *ModifyOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyOutputPortRoleAssignmentResponse, error)

	// ListOutputPortRoleAssignments List Output Port Role Assignments
	ListOutputPortRoleAssignments(ctx context.Context, options *ListOutputPortRoleAssignmentsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListOutputPortRoleAssignmentsResponse, error)

	// CreateOutputPortRoleAssignment Create Output Port Role Assignment
	CreateOutputPortRoleAssignment(ctx context.Context, options *CreateOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateOutputPortRoleAssignmentResponse, error)

	// RequestOutputPortRoleAssignment Request Output Port Role Assignment
	RequestOutputPortRoleAssignment(ctx context.Context, options *RequestOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RequestOutputPortRoleAssignmentResponse, error)

	// DecideOutputPortRoleAssignment Decide Output Port Role Assignment
	DecideOutputPortRoleAssignment(ctx context.Context, options *DecideOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideOutputPortRoleAssignmentResponse, error)

	// GetThemeSettings Get Theme Settings
	GetThemeSettings(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetThemeSettingsResponse, error)

	// UpdateThemeSettings Update Theme Settings
	UpdateThemeSettings(ctx context.Context, options *UpdateThemeSettingsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateThemeSettingsResponse, error)

	// GetGraphData Get Graph Data
	GetGraphData(ctx context.Context, options *GetGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetGraphDataResponse, error)

	// RemoveAllUserNotifications Remove All User Notifications
	RemoveAllUserNotifications(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*RemoveAllUserNotificationsResponse, error)

	// RemoveUserNotification Remove User Notification
	RemoveUserNotification(ctx context.Context, options *RemoveUserNotificationRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveUserNotificationResponse, error)

	// GetUserNotifications Get User Notifications
	GetUserNotifications(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetUserNotificationsResponseJSON, error)

	// SanitizeResourceName Sanitize Resource Name
	SanitizeResourceName(ctx context.Context, options *SanitizeResourceNameRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SanitizeResourceNameResponse, error)

	// ValidateResourceName Validate Resource Name
	ValidateResourceName(ctx context.Context, options *ValidateResourceNameRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ValidateResourceNameResponse, error)

	// ResourceNameConstraints Resource Name Constraints
	ResourceNameConstraints(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*ResourceNameConstraintsResponse, error)

	// GetPlatformTiles Get Platform Tiles
	GetPlatformTiles(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetPlatformTilesResponse, error)

	// GetPlugins Get Plugins
	GetPlugins(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetPluginsResponse, error)

	// GetPluginForm Get Plugin Form
	GetPluginForm(ctx context.Context, options *GetPluginFormRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPluginFormResponse, error)

	// GetDeviceToken Get Device Token
	GetDeviceToken(ctx context.Context, options *GetDeviceTokenRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDeviceTokenResponse, error)

	// GetJwtToken Get Jwt Token
	GetJwtToken(ctx context.Context, options *GetJwtTokenRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetJwtTokenResponse, error)

	// GetAwsCredentials Get Aws Credentials
	GetAwsCredentials(ctx context.Context, options *GetAwsCredentialsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetAwsCredentialsResponse, error)

	// GetVersion Get Version
	GetVersion(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetVersionResponse, error)
}

// CheckAccess Check Access
func (c *Client) CheckAccess(ctx context.Context, options *CheckAccessRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CheckAccessResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/access/{action}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CheckAccessResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CheckAccessErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CheckAccessResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/access/{action}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// IsAdmin Is Admin
func (c *Client) IsAdmin(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*IsAdminResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/admin",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*IsAdminResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(IsAdminResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/admin")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// SearchOutputPorts Search Output Ports
func (c *Client) SearchOutputPorts(ctx context.Context, options *SearchOutputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SearchOutputPortsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/search/output_ports",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*SearchOutputPortsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(SearchOutputPortsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(SearchOutputPortsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/search/output_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetOutputPortQueryStats Get Output Port Query Stats
func (c *Client) GetOutputPortQueryStats(ctx context.Context, options *GetOutputPortQueryStatsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortQueryStatsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetOutputPortQueryStatsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetOutputPortQueryStatsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetOutputPortQueryStatsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateOutputPortQueryStats Update Output Port Query Stats
func (c *Client) UpdateOutputPortQueryStats(ctx context.Context, options *UpdateOutputPortQueryStatsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortQueryStatsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats",
		Method:      "PATCH",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateOutputPortQueryStatsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateOutputPortQueryStatsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateOutputPortQueryStatsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteOutputPortQueryStat Delete Output Port Query Stat
func (c *Client) DeleteOutputPortQueryStat(ctx context.Context, options *DeleteOutputPortQueryStatRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteOutputPortQueryStatResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats",
		Method:      "DELETE",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteOutputPortQueryStatResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteOutputPortQueryStatErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteOutputPortQueryStatResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetOutputPortCuratedQueries Get Output Port Curated Queries
func (c *Client) GetOutputPortCuratedQueries(ctx context.Context, options *GetOutputPortCuratedQueriesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortCuratedQueriesResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/curated_queries",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetOutputPortCuratedQueriesResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetOutputPortCuratedQueriesErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetOutputPortCuratedQueriesResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/curated_queries")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ReplaceOutputPortCuratedQueries Replace Output Port Curated Queries
func (c *Client) ReplaceOutputPortCuratedQueries(ctx context.Context, options *ReplaceOutputPortCuratedQueriesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ReplaceOutputPortCuratedQueriesResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/curated_queries",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ReplaceOutputPortCuratedQueriesResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ReplaceOutputPortCuratedQueriesResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/curated_queries")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductOutputPorts Get Data Product Output Ports
func (c *Client) GetDataProductOutputPorts(ctx context.Context, options *GetDataProductOutputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductOutputPortsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductOutputPortsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductOutputPortsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductOutputPortsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateOutputPort Create Output Port
func (c *Client) CreateOutputPort(ctx context.Context, options *CreateOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateOutputPortResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateOutputPortResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateOutputPortResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetOutputPort Get Output Port
func (c *Client) GetOutputPort(ctx context.Context, options *GetOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetOutputPortResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetOutputPortErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetOutputPortResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDataset Remove Dataset
func (c *Client) RemoveDataset(ctx context.Context, options *RemoveDatasetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDatasetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDatasetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDatasetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateOutputPort Update Output Port
func (c *Client) UpdateOutputPort(ctx context.Context, options *UpdateOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateOutputPortResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateOutputPortResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetOutputPortsEventHistory Get Output Ports Event History
func (c *Client) GetOutputPortsEventHistory(ctx context.Context, options *GetOutputPortsEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortsEventHistoryResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/history",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetOutputPortsEventHistoryResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetOutputPortsEventHistoryErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetOutputPortsEventHistoryResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/history")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateOutputPortAbout Update Output Port About
func (c *Client) UpdateOutputPortAbout(ctx context.Context, options *UpdateOutputPortAboutRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortAboutResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/about",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateOutputPortAboutResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateOutputPortAboutResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/about")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateOutputPortStatus Update Output Port Status
func (c *Client) UpdateOutputPortStatus(ctx context.Context, options *UpdateOutputPortStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortStatusResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/status",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateOutputPortStatusResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateOutputPortStatusResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/status")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetOutputPortGraphData Get Output Port Graph Data
func (c *Client) GetOutputPortGraphData(ctx context.Context, options *GetOutputPortGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortGraphDataResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/graph",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetOutputPortGraphDataResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetOutputPortGraphDataErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetOutputPortGraphDataResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/graph")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// SetValueForOutputPort Set Value For Output Port
func (c *Client) SetValueForOutputPort(ctx context.Context, options *SetValueForOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetValueForOutputPortResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/settings/{setting_id}",
		Method:     "POST",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*SetValueForOutputPortResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(SetValueForOutputPortErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(SetValueForOutputPortResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/settings/{setting_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDataProduct Create Data Product
func (c *Client) CreateDataProduct(ctx context.Context, options *CreateDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDataProductResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDataProductResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProducts Get Data Products
func (c *Client) GetDataProducts(ctx context.Context, options *GetDataProductsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDataProduct Remove Data Product
func (c *Client) RemoveDataProduct(ctx context.Context, options *RemoveDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDataProductResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDataProductResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProduct Update Data Product
func (c *Client) UpdateDataProduct(ctx context.Context, options *UpdateDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProduct Get Data Product
func (c *Client) GetDataProduct(ctx context.Context, options *GetDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductAbout Update Data Product About
func (c *Client) UpdateDataProductAbout(ctx context.Context, options *UpdateDataProductAboutRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductAboutResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/about",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductAboutResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductAboutResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/about")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductStatus Update Data Product Status
func (c *Client) UpdateDataProductStatus(ctx context.Context, options *UpdateDataProductStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductStatusResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/status",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductStatusResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductStatusResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/status")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductUsage Update Data Product Usage
func (c *Client) UpdateDataProductUsage(ctx context.Context, options *UpdateDataProductUsageRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductUsageResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/usage",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductUsageResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateDataProductUsageErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductUsageResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/usage")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductGraphData Get Data Product Graph Data
func (c *Client) GetDataProductGraphData(ctx context.Context, options *GetDataProductGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductGraphDataResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/graph",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductGraphDataResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductGraphDataErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductGraphDataResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/graph")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// SetValueForDataProduct Set Value For Data Product
func (c *Client) SetValueForDataProduct(ctx context.Context, options *SetValueForDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetValueForDataProductResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/settings/{setting_id}",
		Method:     "POST",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*SetValueForDataProductResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(SetValueForDataProductErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(SetValueForDataProductResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/settings/{setting_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// LinkInputPortsToDataProduct Link Input Ports To Data Product
func (c *Client) LinkInputPortsToDataProduct(ctx context.Context, options *LinkInputPortsToDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*LinkInputPortsToDataProductResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/link_input_ports",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*LinkInputPortsToDataProductResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(LinkInputPortsToDataProductResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/link_input_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductEventHistory Get Data Product Event History
func (c *Client) GetDataProductEventHistory(ctx context.Context, options *GetDataProductEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductEventHistoryResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/history",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductEventHistoryResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductEventHistoryErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductEventHistoryResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/history")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateTechnicalAsset Create Technical Asset
func (c *Client) CreateTechnicalAsset(ctx context.Context, options *CreateTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateTechnicalAssetResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/technical_asset",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateTechnicalAssetResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateTechnicalAssetErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateTechnicalAssetResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/technical_asset")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetSigninURL Get Signin Url
func (c *Client) GetSigninURL(ctx context.Context, options *GetSigninURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSigninURLResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/signin_url",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetSigninURLResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetSigninURLErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetSigninURLResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/signin_url")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetConveyorIdeURL Get Conveyor Ide Url
func (c *Client) GetConveyorIdeURL(ctx context.Context, options *GetConveyorIdeURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetConveyorIdeURLResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/conveyor_ide_url",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetConveyorIdeURLResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetConveyorIdeURLErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetConveyorIdeURLResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/conveyor_ide_url")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDatabricksWorkspaceURL Get Databricks Workspace Url
func (c *Client) GetDatabricksWorkspaceURL(ctx context.Context, options *GetDatabricksWorkspaceURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDatabricksWorkspaceURLResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/databricks_workspace_url",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDatabricksWorkspaceURLResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDatabricksWorkspaceURLErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDatabricksWorkspaceURLResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/databricks_workspace_url")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetSnowflakeURL Get Snowflake Url
func (c *Client) GetSnowflakeURL(ctx context.Context, options *GetSnowflakeURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSnowflakeURLResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/snowflake_url",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetSnowflakeURLResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetSnowflakeURLErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetSnowflakeURLResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/snowflake_url")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetTechnicalAssets Get Technical Assets
func (c *Client) GetTechnicalAssets(ctx context.Context, options *GetTechnicalAssetsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/technical_assets",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetTechnicalAssetsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetTechnicalAssetsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetTechnicalAssetsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/technical_assets")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductInputPorts Get Data Product Input Ports
func (c *Client) GetDataProductInputPorts(ctx context.Context, options *GetDataProductInputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductInputPortsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/input_ports",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductInputPortsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductInputPortsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductInputPortsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/input_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductRolledUpTags Get Data Product Rolled Up Tags
func (c *Client) GetDataProductRolledUpTags(ctx context.Context, options *GetDataProductRolledUpTagsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductRolledUpTagsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/rolled_up_tags",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductRolledUpTagsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductRolledUpTagsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductRolledUpTagsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/rolled_up_tags")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UnlinkInputPortFromDataProduct Unlink Input Port From Data Product
func (c *Client) UnlinkInputPortFromDataProduct(ctx context.Context, options *UnlinkInputPortFromDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UnlinkInputPortFromDataProductResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/input_ports/{input_port_id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UnlinkInputPortFromDataProductResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UnlinkInputPortFromDataProductResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/input_ports/{input_port_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductType Get Data Product Type
func (c *Client) GetDataProductType(ctx context.Context, options *GetDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductTypeResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductTypeResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductTypeErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductTypeResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductType Update Data Product Type
func (c *Client) UpdateDataProductType(ctx context.Context, options *UpdateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductTypeResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductTypeResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateDataProductTypeErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductTypeResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDataProductType Remove Data Product Type
func (c *Client) RemoveDataProductType(ctx context.Context, options *RemoveDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductTypeResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDataProductTypeResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveDataProductTypeErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDataProductTypeResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductsTypes Get Data Products Types
func (c *Client) GetDataProductsTypes(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsTypesResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductsTypesResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductsTypesResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDataProductType Create Data Product Type
func (c *Client) CreateDataProductType(ctx context.Context, options *CreateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductTypeResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDataProductTypeResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDataProductTypeResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// MigrateDataProductType Migrate Data Product Type
func (c *Client) MigrateDataProductType(ctx context.Context, options *MigrateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*MigrateDataProductTypeResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types/migrate/{from_id}/{to_id}",
		Method:     "PUT",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*MigrateDataProductTypeResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(MigrateDataProductTypeErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(MigrateDataProductTypeResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types/migrate/{from_id}/{to_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductsLifecycles Get Data Products Lifecycles
func (c *Client) GetDataProductsLifecycles(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsLifecyclesResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_lifecycles",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductsLifecyclesResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductsLifecyclesResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_lifecycles")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDataProductLifecycle Create Data Product Lifecycle
func (c *Client) CreateDataProductLifecycle(ctx context.Context, options *CreateDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductLifecycleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_lifecycles",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDataProductLifecycleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDataProductLifecycleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_lifecycles")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductLifecycle Update Data Product Lifecycle
func (c *Client) UpdateDataProductLifecycle(ctx context.Context, options *UpdateDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductLifecycleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_lifecycles/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductLifecycleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductLifecycleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_lifecycles/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDataProductLifecycle Remove Data Product Lifecycle
func (c *Client) RemoveDataProductLifecycle(ctx context.Context, options *RemoveDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductLifecycleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_lifecycles/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDataProductLifecycleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveDataProductLifecycleErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDataProductLifecycleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_lifecycles/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductsSettings Get Data Products Settings
func (c *Client) GetDataProductsSettings(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsSettingsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductsSettingsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductsSettingsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDataProductSetting Create Data Product Setting
func (c *Client) CreateDataProductSetting(ctx context.Context, options *CreateDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductSettingResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDataProductSettingResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateDataProductSettingErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDataProductSettingResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductSetting Update Data Product Setting
func (c *Client) UpdateDataProductSetting(ctx context.Context, options *UpdateDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductSettingResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductSettingResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateDataProductSettingErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductSettingResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDataProductSetting Remove Data Product Setting
func (c *Client) RemoveDataProductSetting(ctx context.Context, options *RemoveDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductSettingResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDataProductSettingResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveDataProductSettingErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDataProductSettingResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ApproveOutputPortAsInputPort Approve Output Port As Input Port
func (c *Client) ApproveOutputPortAsInputPort(ctx context.Context, options *ApproveOutputPortAsInputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ApproveOutputPortAsInputPortResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/input_ports/approve",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ApproveOutputPortAsInputPortResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ApproveOutputPortAsInputPortErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ApproveOutputPortAsInputPortResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/input_ports/approve")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DenyOutputPortAsInputPort Deny Output Port As Input Port
func (c *Client) DenyOutputPortAsInputPort(ctx context.Context, options *DenyOutputPortAsInputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DenyOutputPortAsInputPortResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/input_ports/deny",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DenyOutputPortAsInputPortResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DenyOutputPortAsInputPortErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DenyOutputPortAsInputPortResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/input_ports/deny")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveOutputPortAsInputPort Remove Output Port As Input Port
func (c *Client) RemoveOutputPortAsInputPort(ctx context.Context, options *RemoveOutputPortAsInputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveOutputPortAsInputPortResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/input_ports/remove",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveOutputPortAsInputPortResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveOutputPortAsInputPortErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveOutputPortAsInputPortResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/input_ports/remove")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ApproveOutputPortTechnicalAssetLink Approve Output Port Technical Asset Link
func (c *Client) ApproveOutputPortTechnicalAssetLink(ctx context.Context, options *ApproveOutputPortTechnicalAssetLinkRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ApproveOutputPortTechnicalAssetLinkResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/technical_assets/approve_link_request",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ApproveOutputPortTechnicalAssetLinkResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ApproveOutputPortTechnicalAssetLinkErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ApproveOutputPortTechnicalAssetLinkResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/technical_assets/approve_link_request")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DenyOutputPortTechnicalAssetLink Deny Output Port Technical Asset Link
func (c *Client) DenyOutputPortTechnicalAssetLink(ctx context.Context, options *DenyOutputPortTechnicalAssetLinkRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DenyOutputPortTechnicalAssetLinkResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/technical_assets/deny_link_request",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DenyOutputPortTechnicalAssetLinkResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DenyOutputPortTechnicalAssetLinkErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DenyOutputPortTechnicalAssetLinkResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/technical_assets/deny_link_request")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// LinkOutputPortToTechnicalAsset Link Output Port To Technical Asset
func (c *Client) LinkOutputPortToTechnicalAsset(ctx context.Context, options *LinkOutputPortToTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*LinkOutputPortToTechnicalAssetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/technical_assets/add",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*LinkOutputPortToTechnicalAssetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(LinkOutputPortToTechnicalAssetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/technical_assets/add")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UnlinkOutputPortFromTechnicalAsset Unlink Output Port From Technical Asset
func (c *Client) UnlinkOutputPortFromTechnicalAsset(ctx context.Context, options *UnlinkOutputPortFromTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UnlinkOutputPortFromTechnicalAssetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/technical_assets/remove",
		Method:      "DELETE",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UnlinkOutputPortFromTechnicalAssetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UnlinkOutputPortFromTechnicalAssetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{output_port_id}/technical_assets/remove")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetTechnicalAsset Get Technical Asset
func (c *Client) GetTechnicalAsset(ctx context.Context, options *GetTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetTechnicalAssetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetTechnicalAssetErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetTechnicalAssetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveTechnicalAsset Remove Technical Asset
func (c *Client) RemoveTechnicalAsset(ctx context.Context, options *RemoveTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveTechnicalAssetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveTechnicalAssetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveTechnicalAssetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetTechnicalAssetEventHistory Get Technical Asset Event History
func (c *Client) GetTechnicalAssetEventHistory(ctx context.Context, options *GetTechnicalAssetEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetEventHistoryResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}/history",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetTechnicalAssetEventHistoryResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetTechnicalAssetEventHistoryErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetTechnicalAssetEventHistoryResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}/history")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateTechnicalAssetStatus Update Technical Asset Status
func (c *Client) UpdateTechnicalAssetStatus(ctx context.Context, options *UpdateTechnicalAssetStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateTechnicalAssetStatusResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}/status",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateTechnicalAssetStatusResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateTechnicalAssetStatusResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}/status")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetTechnicalAssetGraphData Get Technical Asset Graph Data
func (c *Client) GetTechnicalAssetGraphData(ctx context.Context, options *GetTechnicalAssetGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetGraphDataResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}/graph",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetTechnicalAssetGraphDataResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetTechnicalAssetGraphDataErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetTechnicalAssetGraphDataResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}/graph")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDomains Get Domains
func (c *Client) GetDomains(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDomainsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/domains",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDomainsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDomainsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDomain Create Domain
func (c *Client) CreateDomain(ctx context.Context, options *CreateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDomainResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/domains",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDomainResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDomainResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDomain Update Domain
func (c *Client) UpdateDomain(ctx context.Context, options *UpdateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDomainResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/domains/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDomainResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDomainResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDomain Remove Domain
func (c *Client) RemoveDomain(ctx context.Context, options *RemoveDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDomainResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/domains/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDomainResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDomainResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDomain Get Domain
func (c *Client) GetDomain(ctx context.Context, options *GetDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDomainResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/domains/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDomainResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDomainResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// MigrateDomain Migrate Domain
func (c *Client) MigrateDomain(ctx context.Context, options *MigrateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*MigrateDomainResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/domains/migrate/{from_id}/{to_id}",
		Method:     "PUT",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*MigrateDomainResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(MigrateDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(MigrateDomainResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains/migrate/{from_id}/{to_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironment Get Environment
func (c *Client) GetEnvironment(ctx context.Context, options *GetEnvironmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentConfigsByID Get Environment Configs By Id
func (c *Client) GetEnvironmentConfigsByID(ctx context.Context, options *GetEnvironmentConfigsByIDRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentConfigsByIDResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/configs/{config_id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentConfigsByIDResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentConfigsByIDErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentConfigsByIDResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/configs/{config_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentPlatformServiceConfig Get Environment Platform Service Config
func (c *Client) GetEnvironmentPlatformServiceConfig(ctx context.Context, options *GetEnvironmentPlatformServiceConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformServiceConfigResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/{id}/platforms/{platform_id}/services/{service_id}/config",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentPlatformServiceConfigResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentPlatformServiceConfigErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentPlatformServiceConfigResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/{id}/platforms/{platform_id}/services/{service_id}/config")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentPlatformConfig Get Environment Platform Config
func (c *Client) GetEnvironmentPlatformConfig(ctx context.Context, options *GetEnvironmentPlatformConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformConfigResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/{id}/platforms/{platform_id}/config",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentPlatformConfigResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentPlatformConfigErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentPlatformConfigResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/{id}/platforms/{platform_id}/config")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironments Get Environments
func (c *Client) GetEnvironments(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentConfigs Get Environment Configs
func (c *Client) GetEnvironmentConfigs(ctx context.Context, options *GetEnvironmentConfigsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentConfigsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/{id}/configs",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentConfigsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentConfigsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentConfigsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/{id}/configs")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentPlatformServiceConfigForAllEnvs Get Environment Platform Service Config For All Envs
func (c *Client) GetEnvironmentPlatformServiceConfigForAllEnvs(ctx context.Context, options *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformServiceConfigForAllEnvsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/platforms/{platform_id}/services/{service_id}/config",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentPlatformServiceConfigForAllEnvsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentPlatformServiceConfigForAllEnvsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentPlatformServiceConfigForAllEnvsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/platforms/{platform_id}/services/{service_id}/config")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetPlatformServiceConfig Get Platform Service Config
func (c *Client) GetPlatformServiceConfig(ctx context.Context, options *GetPlatformServiceConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPlatformServiceConfigResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms/{id}/services/{service_id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetPlatformServiceConfigResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetPlatformServiceConfigResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms/{id}/services/{service_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetSinglePlatformServiceConfiguration Get Single Platform Service Configuration
func (c *Client) GetSinglePlatformServiceConfiguration(ctx context.Context, options *GetSinglePlatformServiceConfigurationRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSinglePlatformServiceConfigurationResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms/configs/{config_id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetSinglePlatformServiceConfigurationResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetSinglePlatformServiceConfigurationErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetSinglePlatformServiceConfigurationResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms/configs/{config_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetAllPlatformServiceConfigurations Get All Platform Service Configurations
func (c *Client) GetAllPlatformServiceConfigurations(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetAllPlatformServiceConfigurationsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms/configs",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetAllPlatformServiceConfigurationsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetAllPlatformServiceConfigurationsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms/configs")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetAllPlatforms Get All Platforms
func (c *Client) GetAllPlatforms(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetAllPlatformsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetAllPlatformsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetAllPlatformsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetPlatformServices Get Platform Services
func (c *Client) GetPlatformServices(ctx context.Context, options *GetPlatformServicesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPlatformServicesResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms/{id}/services",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetPlatformServicesResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetPlatformServicesErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetPlatformServicesResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms/{id}/services")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetTags Get Tags
func (c *Client) GetTags(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetTagsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/tags",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetTagsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetTagsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/tags")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateTag Create Tag
func (c *Client) CreateTag(ctx context.Context, options *CreateTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateTagResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/tags",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateTagResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateTagErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateTagResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/tags")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateTag Update Tag
func (c *Client) UpdateTag(ctx context.Context, options *UpdateTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateTagResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/tags/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateTagResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateTagErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateTagResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/tags/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveTag Remove Tag
func (c *Client) RemoveTag(ctx context.Context, options *RemoveTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveTagResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/tags/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveTagResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveTagErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveTagResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/tags/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveUser Remove User
func (c *Client) RemoveUser(ctx context.Context, options *RemoveUserRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveUserResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveUserResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveUserResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetUsers Get Users
func (c *Client) GetUsers(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetUsersResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetUsersResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetUsersResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateUser Create User
func (c *Client) CreateUser(ctx context.Context, options *CreateUserRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateUserResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/users",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateUserResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateUserErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateUserResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// SetCanBecomeAdmin Set Can Become Admin
func (c *Client) SetCanBecomeAdmin(ctx context.Context, options *SetCanBecomeAdminRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetCanBecomeAdminResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/users/set_can_become_admin",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*SetCanBecomeAdminResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(SetCanBecomeAdminErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(SetCanBecomeAdminResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/set_can_become_admin")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// MarkTourAsSeen Mark Tour As Seen
func (c *Client) MarkTourAsSeen(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*MarkTourAsSeenResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users/current/seen_tour",
		Method:     "POST",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*MarkTourAsSeenResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(MarkTourAsSeenResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/current/seen_tour")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetUserPendingActions Get User Pending Actions
func (c *Client) GetUserPendingActions(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetUserPendingActionsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users/current/pending_actions",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetUserPendingActionsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetUserPendingActionsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/current/pending_actions")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetCurrentUser Get Current User
func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetCurrentUserResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users/current",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetCurrentUserResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetCurrentUserResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/current")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateRole Create Role
func (c *Client) CreateRole(ctx context.Context, options *CreateRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateRoleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/roles",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateRoleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateRoleErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateRoleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/roles")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveRole Remove Role
func (c *Client) RemoveRole(ctx context.Context, options *RemoveRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveRoleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/roles/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveRoleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveRoleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/roles/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateRole Update Role
func (c *Client) UpdateRole(ctx context.Context, options *UpdateRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateRoleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/roles/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateRoleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateRoleErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateRoleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/roles/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetRoles Get Roles
func (c *Client) GetRoles(ctx context.Context, options *GetRolesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetRolesResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/roles/{scope}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetRolesResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetRolesErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetRolesResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/roles/{scope}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// BecomeAdmin Become Admin
func (c *Client) BecomeAdmin(ctx context.Context, options *BecomeAdminRequestOptions, reqEditors ...runtime.RequestEditorFn) (*BecomeAdminResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/become_admin",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*BecomeAdminResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(BecomeAdminErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(BecomeAdminResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/become_admin")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RevokeAdmin Revoke Admin
func (c *Client) RevokeAdmin(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*RevokeAdminResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/revoke_admin",
		Method:     "POST",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RevokeAdminResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RevokeAdminResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/revoke_admin")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateGlobalRoleAssignment Create Global Role Assignment
func (c *Client) CreateGlobalRoleAssignment(ctx context.Context, options *CreateGlobalRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateGlobalRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateGlobalRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateGlobalRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateGlobalRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ListGlobalRoleAssignments List Global Role Assignments
func (c *Client) ListGlobalRoleAssignments(ctx context.Context, options *ListGlobalRoleAssignmentsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListGlobalRoleAssignmentsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ListGlobalRoleAssignmentsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ListGlobalRoleAssignmentsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ListGlobalRoleAssignmentsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteGlobalRoleAssignment Delete Global Role Assignment
func (c *Client) DeleteGlobalRoleAssignment(ctx context.Context, options *DeleteGlobalRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteGlobalRoleAssignmentResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteGlobalRoleAssignmentResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteGlobalRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteGlobalRoleAssignmentResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DecideGlobalRoleAssignment Decide Global Role Assignment
func (c *Client) DecideGlobalRoleAssignment(ctx context.Context, options *DecideGlobalRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideGlobalRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/{id}/decide",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DecideGlobalRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DecideGlobalRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DecideGlobalRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/{id}/decide")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ModifyGlobalRoleAssignment Modify Global Role Assignment
func (c *Client) ModifyGlobalRoleAssignment(ctx context.Context, options *ModifyGlobalRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyGlobalRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/{id}/role",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ModifyGlobalRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ModifyGlobalRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ModifyGlobalRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/{id}/role")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteDataProductRoleAssignment Delete Data Product Role Assignment
func (c *Client) DeleteDataProductRoleAssignment(ctx context.Context, options *DeleteDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteDataProductRoleAssignmentResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteDataProductRoleAssignmentResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteDataProductRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteDataProductRoleAssignmentResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ModifyDataProductRoleAssignment Modify Data Product Role Assignment
func (c *Client) ModifyDataProductRoleAssignment(ctx context.Context, options *ModifyDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyDataProductRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ModifyDataProductRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ModifyDataProductRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ModifyDataProductRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ListDataProductRoleAssignments List Data Product Role Assignments
func (c *Client) ListDataProductRoleAssignments(ctx context.Context, options *ListDataProductRoleAssignmentsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListDataProductRoleAssignmentsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ListDataProductRoleAssignmentsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ListDataProductRoleAssignmentsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ListDataProductRoleAssignmentsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDataProductRoleAssignment Create Data Product Role Assignment
func (c *Client) CreateDataProductRoleAssignment(ctx context.Context, options *CreateDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDataProductRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateDataProductRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDataProductRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RequestDataProductRoleAssignment Request Data Product Role Assignment
func (c *Client) RequestDataProductRoleAssignment(ctx context.Context, options *RequestDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RequestDataProductRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product/request",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RequestDataProductRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RequestDataProductRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RequestDataProductRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product/request")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DecideDataProductRoleAssignment Decide Data Product Role Assignment
func (c *Client) DecideDataProductRoleAssignment(ctx context.Context, options *DecideDataProductRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideDataProductRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product/{id}/decide",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DecideDataProductRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DecideDataProductRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DecideDataProductRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product/{id}/decide")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteOutputPortRoleAssignment Delete Output Port Role Assignment
func (c *Client) DeleteOutputPortRoleAssignment(ctx context.Context, options *DeleteOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteOutputPortRoleAssignmentResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteOutputPortRoleAssignmentResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteOutputPortRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteOutputPortRoleAssignmentResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ModifyOutputPortRoleAssignment Modify Output Port Role Assignment
func (c *Client) ModifyOutputPortRoleAssignment(ctx context.Context, options *ModifyOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyOutputPortRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ModifyOutputPortRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ModifyOutputPortRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ModifyOutputPortRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ListOutputPortRoleAssignments List Output Port Role Assignments
func (c *Client) ListOutputPortRoleAssignments(ctx context.Context, options *ListOutputPortRoleAssignmentsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListOutputPortRoleAssignmentsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ListOutputPortRoleAssignmentsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ListOutputPortRoleAssignmentsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ListOutputPortRoleAssignmentsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateOutputPortRoleAssignment Create Output Port Role Assignment
func (c *Client) CreateOutputPortRoleAssignment(ctx context.Context, options *CreateOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateOutputPortRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateOutputPortRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateOutputPortRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateOutputPortRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RequestOutputPortRoleAssignment Request Output Port Role Assignment
func (c *Client) RequestOutputPortRoleAssignment(ctx context.Context, options *RequestOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RequestOutputPortRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port/request",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RequestOutputPortRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RequestOutputPortRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RequestOutputPortRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port/request")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DecideOutputPortRoleAssignment Decide Output Port Role Assignment
func (c *Client) DecideOutputPortRoleAssignment(ctx context.Context, options *DecideOutputPortRoleAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideOutputPortRoleAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port/{id}/decide",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DecideOutputPortRoleAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DecideOutputPortRoleAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DecideOutputPortRoleAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port/{id}/decide")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetThemeSettings Get Theme Settings
func (c *Client) GetThemeSettings(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetThemeSettingsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/theme_settings",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetThemeSettingsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetThemeSettingsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/theme_settings")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateThemeSettings Update Theme Settings
func (c *Client) UpdateThemeSettings(ctx context.Context, options *UpdateThemeSettingsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateThemeSettingsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/theme_settings",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateThemeSettingsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateThemeSettingsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateThemeSettingsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/theme_settings")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetGraphData Get Graph Data
func (c *Client) GetGraphData(ctx context.Context, options *GetGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetGraphDataResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/graph",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetGraphDataResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetGraphDataErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetGraphDataResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/graph")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveAllUserNotifications Remove All User Notifications
func (c *Client) RemoveAllUserNotifications(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*RemoveAllUserNotificationsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users/current/notifications/all",
		Method:     "DELETE",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveAllUserNotificationsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveAllUserNotificationsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/current/notifications/all")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveUserNotification Remove User Notification
func (c *Client) RemoveUserNotification(ctx context.Context, options *RemoveUserNotificationRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveUserNotificationResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users/current/notifications/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveUserNotificationResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveUserNotificationErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveUserNotificationResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/current/notifications/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetUserNotifications Get User Notifications
func (c *Client) GetUserNotifications(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetUserNotificationsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users/current/notifications",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetUserNotificationsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetUserNotificationsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/current/notifications")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// SanitizeResourceName Sanitize Resource Name
func (c *Client) SanitizeResourceName(ctx context.Context, options *SanitizeResourceNameRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SanitizeResourceNameResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/resource_names/sanitize",
		Method:     "POST",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*SanitizeResourceNameResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(SanitizeResourceNameErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(SanitizeResourceNameResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/resource_names/sanitize")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ValidateResourceName Validate Resource Name
func (c *Client) ValidateResourceName(ctx context.Context, options *ValidateResourceNameRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ValidateResourceNameResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/resource_names/validate",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ValidateResourceNameResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ValidateResourceNameErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ValidateResourceNameResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/resource_names/validate")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ResourceNameConstraints Resource Name Constraints
func (c *Client) ResourceNameConstraints(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*ResourceNameConstraintsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/resource_names/constraints",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ResourceNameConstraintsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ResourceNameConstraintsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/resource_names/constraints")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetPlatformTiles Get Platform Tiles
func (c *Client) GetPlatformTiles(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetPlatformTilesResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/plugins/platform-tiles",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetPlatformTilesResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetPlatformTilesResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/plugins/platform-tiles")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetPlugins Get Plugins
func (c *Client) GetPlugins(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetPluginsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/plugins/",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetPluginsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetPluginsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/plugins/")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetPluginForm Get Plugin Form
func (c *Client) GetPluginForm(ctx context.Context, options *GetPluginFormRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPluginFormResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/plugins/{plugin_name}/form",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetPluginFormResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetPluginFormErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetPluginFormResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/plugins/{plugin_name}/form")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDeviceToken Get Device Token
func (c *Client) GetDeviceToken(ctx context.Context, options *GetDeviceTokenRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDeviceTokenResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authn/device/device_token",
		Method:     "POST",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDeviceTokenResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDeviceTokenErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDeviceTokenResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authn/device/device_token")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetJwtToken Get Jwt Token
func (c *Client) GetJwtToken(ctx context.Context, options *GetJwtTokenRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetJwtTokenResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authn/device/jwt_token",
		Method:     "POST",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetJwtTokenResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetJwtTokenErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetJwtTokenResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authn/device/jwt_token")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetAwsCredentials Get Aws Credentials
func (c *Client) GetAwsCredentials(ctx context.Context, options *GetAwsCredentialsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetAwsCredentialsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authn/aws_credentials",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetAwsCredentialsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetAwsCredentialsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetAwsCredentialsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authn/aws_credentials")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetVersion Get Version
func (c *Client) GetVersion(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetVersionResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/version",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetVersionResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetVersionResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/version")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

var _ ClientInterface = (*Client)(nil)

// CheckAccessRequestOptions is the options needed to make a request to CheckAccess.
type CheckAccessRequestOptions struct {
	PathParams *CheckAccessPath
	Query      *CheckAccessQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CheckAccessRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CheckAccessRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *CheckAccessRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CheckAccessRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *CheckAccessRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// SearchOutputPortsRequestOptions is the options needed to make a request to SearchOutputPorts.
type SearchOutputPortsRequestOptions struct {
	Query *SearchOutputPortsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *SearchOutputPortsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *SearchOutputPortsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *SearchOutputPortsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *SearchOutputPortsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *SearchOutputPortsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetOutputPortQueryStatsRequestOptions is the options needed to make a request to GetOutputPortQueryStats.
type GetOutputPortQueryStatsRequestOptions struct {
	PathParams *GetOutputPortQueryStatsPath
	Query      *GetOutputPortQueryStatsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetOutputPortQueryStatsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetOutputPortQueryStatsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetOutputPortQueryStatsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetOutputPortQueryStatsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetOutputPortQueryStatsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateOutputPortQueryStatsRequestOptions is the options needed to make a request to UpdateOutputPortQueryStats.
type UpdateOutputPortQueryStatsRequestOptions struct {
	PathParams *UpdateOutputPortQueryStatsPath
	Body       *UpdateOutputPortQueryStatsBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateOutputPortQueryStatsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateOutputPortQueryStatsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateOutputPortQueryStatsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateOutputPortQueryStatsRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateOutputPortQueryStatsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteOutputPortQueryStatRequestOptions is the options needed to make a request to DeleteOutputPortQueryStat.
type DeleteOutputPortQueryStatRequestOptions struct {
	PathParams *DeleteOutputPortQueryStatPath
	Body       *DeleteOutputPortQueryStatBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteOutputPortQueryStatRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteOutputPortQueryStatRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteOutputPortQueryStatRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteOutputPortQueryStatRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DeleteOutputPortQueryStatRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetOutputPortCuratedQueriesRequestOptions is the options needed to make a request to GetOutputPortCuratedQueries.
type GetOutputPortCuratedQueriesRequestOptions struct {
	PathParams *GetOutputPortCuratedQueriesPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetOutputPortCuratedQueriesRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetOutputPortCuratedQueriesRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetOutputPortCuratedQueriesRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetOutputPortCuratedQueriesRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetOutputPortCuratedQueriesRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ReplaceOutputPortCuratedQueriesRequestOptions is the options needed to make a request to ReplaceOutputPortCuratedQueries.
type ReplaceOutputPortCuratedQueriesRequestOptions struct {
	PathParams *ReplaceOutputPortCuratedQueriesPath
	Body       *ReplaceOutputPortCuratedQueriesBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductOutputPortsRequestOptions is the options needed to make a request to GetDataProductOutputPorts.
type GetDataProductOutputPortsRequestOptions struct {
	PathParams *GetDataProductOutputPortsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductOutputPortsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductOutputPortsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductOutputPortsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductOutputPortsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductOutputPortsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateOutputPortRequestOptions is the options needed to make a request to CreateOutputPort.
type CreateOutputPortRequestOptions struct {
	PathParams *CreateOutputPortPath
	Body       *CreateOutputPortBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateOutputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateOutputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *CreateOutputPortRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateOutputPortRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateOutputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetOutputPortRequestOptions is the options needed to make a request to GetOutputPort.
type GetOutputPortRequestOptions struct {
	PathParams *GetOutputPortPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetOutputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetOutputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetOutputPortRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetOutputPortRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetOutputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDatasetRequestOptions is the options needed to make a request to RemoveDataset.
type RemoveDatasetRequestOptions struct {
	PathParams *RemoveDatasetPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDatasetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDatasetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDatasetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDatasetRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDatasetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateOutputPortRequestOptions is the options needed to make a request to UpdateOutputPort.
type UpdateOutputPortRequestOptions struct {
	PathParams *UpdateOutputPortPath
	Body       *UpdateOutputPortBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateOutputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateOutputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateOutputPortRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateOutputPortRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateOutputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetOutputPortsEventHistoryRequestOptions is the options needed to make a request to GetOutputPortsEventHistory.
type GetOutputPortsEventHistoryRequestOptions struct {
	PathParams *GetOutputPortsEventHistoryPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetOutputPortsEventHistoryRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetOutputPortsEventHistoryRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetOutputPortsEventHistoryRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetOutputPortsEventHistoryRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetOutputPortsEventHistoryRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateOutputPortAboutRequestOptions is the options needed to make a request to UpdateOutputPortAbout.
type UpdateOutputPortAboutRequestOptions struct {
	PathParams *UpdateOutputPortAboutPath
	Body       *UpdateOutputPortAboutBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateOutputPortAboutRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateOutputPortAboutRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateOutputPortAboutRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateOutputPortAboutRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateOutputPortAboutRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateOutputPortStatusRequestOptions is the options needed to make a request to UpdateOutputPortStatus.
type UpdateOutputPortStatusRequestOptions struct {
	PathParams *UpdateOutputPortStatusPath
	Body       *UpdateOutputPortStatusBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateOutputPortStatusRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateOutputPortStatusRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateOutputPortStatusRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateOutputPortStatusRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateOutputPortStatusRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetOutputPortGraphDataRequestOptions is the options needed to make a request to GetOutputPortGraphData.
type GetOutputPortGraphDataRequestOptions struct {
	PathParams *GetOutputPortGraphDataPath
	Query      *GetOutputPortGraphDataQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetOutputPortGraphDataRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetOutputPortGraphDataRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetOutputPortGraphDataRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetOutputPortGraphDataRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetOutputPortGraphDataRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// SetValueForOutputPortRequestOptions is the options needed to make a request to SetValueForOutputPort.
type SetValueForOutputPortRequestOptions struct {
	PathParams *SetValueForOutputPortPath
	Query      *SetValueForOutputPortQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *SetValueForOutputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *SetValueForOutputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *SetValueForOutputPortRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *SetValueForOutputPortRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *SetValueForOutputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDataProductRequestOptions is the options needed to make a request to CreateDataProduct.
type CreateDataProductRequestOptions struct {
	Body *CreateDataProductBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDataProductRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductsRequestOptions is the options needed to make a request to GetDataProducts.
type GetDataProductsRequestOptions struct {
	Query *GetDataProductsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *GetDataProductsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDataProductRequestOptions is the options needed to make a request to RemoveDataProduct.
type RemoveDataProductRequestOptions struct {
	PathParams *RemoveDataProductPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDataProductRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductRequestOptions is the options needed to make a request to UpdateDataProduct.
type UpdateDataProductRequestOptions struct {
	PathParams *UpdateDataProductPath
	Body       *UpdateDataProductBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductRequestOptions is the options needed to make a request to GetDataProduct.
type GetDataProductRequestOptions struct {
	PathParams *GetDataProductPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductAboutRequestOptions is the options needed to make a request to UpdateDataProductAbout.
type UpdateDataProductAboutRequestOptions struct {
	PathParams *UpdateDataProductAboutPath
	Body       *UpdateDataProductAboutBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductAboutRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductAboutRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductAboutRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductAboutRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductAboutRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductStatusRequestOptions is the options needed to make a request to UpdateDataProductStatus.
type UpdateDataProductStatusRequestOptions struct {
	PathParams *UpdateDataProductStatusPath
	Body       *UpdateDataProductStatusBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductStatusRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductStatusRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductStatusRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductStatusRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductStatusRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductUsageRequestOptions is the options needed to make a request to UpdateDataProductUsage.
type UpdateDataProductUsageRequestOptions struct {
	PathParams *UpdateDataProductUsagePath
	Body       *UpdateDataProductUsageBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductUsageRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductUsageRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductUsageRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductUsageRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductUsageRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductGraphDataRequestOptions is the options needed to make a request to GetDataProductGraphData.
type GetDataProductGraphDataRequestOptions struct {
	PathParams *GetDataProductGraphDataPath
	Query      *GetDataProductGraphDataQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductGraphDataRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductGraphDataRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductGraphDataRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductGraphDataRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductGraphDataRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// SetValueForDataProductRequestOptions is the options needed to make a request to SetValueForDataProduct.
type SetValueForDataProductRequestOptions struct {
	PathParams *SetValueForDataProductPath
	Query      *SetValueForDataProductQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *SetValueForDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *SetValueForDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *SetValueForDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *SetValueForDataProductRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *SetValueForDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// LinkInputPortsToDataProductRequestOptions is the options needed to make a request to LinkInputPortsToDataProduct.
type LinkInputPortsToDataProductRequestOptions struct {
	PathParams *LinkInputPortsToDataProductPath
	Body       *LinkInputPortsToDataProductBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *LinkInputPortsToDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *LinkInputPortsToDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *LinkInputPortsToDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *LinkInputPortsToDataProductRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *LinkInputPortsToDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductEventHistoryRequestOptions is the options needed to make a request to GetDataProductEventHistory.
type GetDataProductEventHistoryRequestOptions struct {
	PathParams *GetDataProductEventHistoryPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductEventHistoryRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductEventHistoryRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductEventHistoryRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductEventHistoryRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductEventHistoryRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateTechnicalAssetRequestOptions is the options needed to make a request to CreateTechnicalAsset.
type CreateTechnicalAssetRequestOptions struct {
	PathParams *CreateTechnicalAssetPath
	Body       *CreateTechnicalAssetBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *CreateTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateTechnicalAssetRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetSigninURLRequestOptions is the options needed to make a request to GetSigninURL.
type GetSigninURLRequestOptions struct {
	PathParams *GetSigninURLPath
	Query      *GetSigninURLQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetSigninURLRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetSigninURLRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetSigninURLRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetSigninURLRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetSigninURLRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetConveyorIdeURLRequestOptions is the options needed to make a request to GetConveyorIdeURL.
type GetConveyorIdeURLRequestOptions struct {
	PathParams *GetConveyorIdeURLPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetConveyorIdeURLRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetConveyorIdeURLRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetConveyorIdeURLRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetConveyorIdeURLRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetConveyorIdeURLRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDatabricksWorkspaceURLRequestOptions is the options needed to make a request to GetDatabricksWorkspaceURL.
type GetDatabricksWorkspaceURLRequestOptions struct {
	PathParams *GetDatabricksWorkspaceURLPath
	Query      *GetDatabricksWorkspaceURLQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDatabricksWorkspaceURLRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDatabricksWorkspaceURLRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDatabricksWorkspaceURLRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDatabricksWorkspaceURLRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDatabricksWorkspaceURLRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetSnowflakeURLRequestOptions is the options needed to make a request to GetSnowflakeURL.
type GetSnowflakeURLRequestOptions struct {
	PathParams *GetSnowflakeURLPath
	Query      *GetSnowflakeURLQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetSnowflakeURLRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetSnowflakeURLRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetSnowflakeURLRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetSnowflakeURLRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetSnowflakeURLRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetTechnicalAssetsRequestOptions is the options needed to make a request to GetTechnicalAssets.
type GetTechnicalAssetsRequestOptions struct {
	PathParams *GetTechnicalAssetsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetTechnicalAssetsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetTechnicalAssetsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetTechnicalAssetsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetTechnicalAssetsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetTechnicalAssetsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductInputPortsRequestOptions is the options needed to make a request to GetDataProductInputPorts.
type GetDataProductInputPortsRequestOptions struct {
	PathParams *GetDataProductInputPortsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductInputPortsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductInputPortsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductInputPortsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductInputPortsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductInputPortsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductRolledUpTagsRequestOptions is the options needed to make a request to GetDataProductRolledUpTags.
type GetDataProductRolledUpTagsRequestOptions struct {
	PathParams *GetDataProductRolledUpTagsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductRolledUpTagsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductRolledUpTagsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductRolledUpTagsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductRolledUpTagsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductRolledUpTagsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UnlinkInputPortFromDataProductRequestOptions is the options needed to make a request to UnlinkInputPortFromDataProduct.
type UnlinkInputPortFromDataProductRequestOptions struct {
	PathParams *UnlinkInputPortFromDataProductPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UnlinkInputPortFromDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UnlinkInputPortFromDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UnlinkInputPortFromDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UnlinkInputPortFromDataProductRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *UnlinkInputPortFromDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductTypeRequestOptions is the options needed to make a request to GetDataProductType.
type GetDataProductTypeRequestOptions struct {
	PathParams *GetDataProductTypePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductTypeRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductTypeRequestOptions is the options needed to make a request to UpdateDataProductType.
type UpdateDataProductTypeRequestOptions struct {
	PathParams *UpdateDataProductTypePath
	Body       *UpdateDataProductTypeBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductTypeRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDataProductTypeRequestOptions is the options needed to make a request to RemoveDataProductType.
type RemoveDataProductTypeRequestOptions struct {
	PathParams *RemoveDataProductTypePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDataProductTypeRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDataProductTypeRequestOptions is the options needed to make a request to CreateDataProductType.
type CreateDataProductTypeRequestOptions struct {
	Body *CreateDataProductTypeBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDataProductTypeRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// MigrateDataProductTypeRequestOptions is the options needed to make a request to MigrateDataProductType.
type MigrateDataProductTypeRequestOptions struct {
	PathParams *MigrateDataProductTypePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *MigrateDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *MigrateDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *MigrateDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *MigrateDataProductTypeRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *MigrateDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDataProductLifecycleRequestOptions is the options needed to make a request to CreateDataProductLifecycle.
type CreateDataProductLifecycleRequestOptions struct {
	Body *CreateDataProductLifecycleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDataProductLifecycleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDataProductLifecycleRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDataProductLifecycleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDataProductLifecycleRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDataProductLifecycleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductLifecycleRequestOptions is the options needed to make a request to UpdateDataProductLifecycle.
type UpdateDataProductLifecycleRequestOptions struct {
	PathParams *UpdateDataProductLifecyclePath
	Body       *UpdateDataProductLifecycleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductLifecycleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductLifecycleRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductLifecycleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductLifecycleRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductLifecycleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDataProductLifecycleRequestOptions is the options needed to make a request to RemoveDataProductLifecycle.
type RemoveDataProductLifecycleRequestOptions struct {
	PathParams *RemoveDataProductLifecyclePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDataProductLifecycleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDataProductLifecycleRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDataProductLifecycleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDataProductLifecycleRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDataProductLifecycleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDataProductSettingRequestOptions is the options needed to make a request to CreateDataProductSetting.
type CreateDataProductSettingRequestOptions struct {
	Body *CreateDataProductSettingBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDataProductSettingRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDataProductSettingRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDataProductSettingRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDataProductSettingRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDataProductSettingRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductSettingRequestOptions is the options needed to make a request to UpdateDataProductSetting.
type UpdateDataProductSettingRequestOptions struct {
	PathParams *UpdateDataProductSettingPath
	Body       *UpdateDataProductSettingBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductSettingRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductSettingRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductSettingRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductSettingRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductSettingRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDataProductSettingRequestOptions is the options needed to make a request to RemoveDataProductSetting.
type RemoveDataProductSettingRequestOptions struct {
	PathParams *RemoveDataProductSettingPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDataProductSettingRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDataProductSettingRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDataProductSettingRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDataProductSettingRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDataProductSettingRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ApproveOutputPortAsInputPortRequestOptions is the options needed to make a request to ApproveOutputPortAsInputPort.
type ApproveOutputPortAsInputPortRequestOptions struct {
	PathParams *ApproveOutputPortAsInputPortPath
	Body       *ApproveOutputPortAsInputPortBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ApproveOutputPortAsInputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ApproveOutputPortAsInputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ApproveOutputPortAsInputPortRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ApproveOutputPortAsInputPortRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ApproveOutputPortAsInputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DenyOutputPortAsInputPortRequestOptions is the options needed to make a request to DenyOutputPortAsInputPort.
type DenyOutputPortAsInputPortRequestOptions struct {
	PathParams *DenyOutputPortAsInputPortPath
	Body       *DenyOutputPortAsInputPortBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DenyOutputPortAsInputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DenyOutputPortAsInputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DenyOutputPortAsInputPortRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DenyOutputPortAsInputPortRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DenyOutputPortAsInputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveOutputPortAsInputPortRequestOptions is the options needed to make a request to RemoveOutputPortAsInputPort.
type RemoveOutputPortAsInputPortRequestOptions struct {
	PathParams *RemoveOutputPortAsInputPortPath
	Body       *RemoveOutputPortAsInputPortBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveOutputPortAsInputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveOutputPortAsInputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveOutputPortAsInputPortRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveOutputPortAsInputPortRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *RemoveOutputPortAsInputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ApproveOutputPortTechnicalAssetLinkRequestOptions is the options needed to make a request to ApproveOutputPortTechnicalAssetLink.
type ApproveOutputPortTechnicalAssetLinkRequestOptions struct {
	PathParams *ApproveOutputPortTechnicalAssetLinkPath
	Body       *ApproveOutputPortTechnicalAssetLinkBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ApproveOutputPortTechnicalAssetLinkRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ApproveOutputPortTechnicalAssetLinkRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ApproveOutputPortTechnicalAssetLinkRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ApproveOutputPortTechnicalAssetLinkRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ApproveOutputPortTechnicalAssetLinkRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DenyOutputPortTechnicalAssetLinkRequestOptions is the options needed to make a request to DenyOutputPortTechnicalAssetLink.
type DenyOutputPortTechnicalAssetLinkRequestOptions struct {
	PathParams *DenyOutputPortTechnicalAssetLinkPath
	Body       *DenyOutputPortTechnicalAssetLinkBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DenyOutputPortTechnicalAssetLinkRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DenyOutputPortTechnicalAssetLinkRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DenyOutputPortTechnicalAssetLinkRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DenyOutputPortTechnicalAssetLinkRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DenyOutputPortTechnicalAssetLinkRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// LinkOutputPortToTechnicalAssetRequestOptions is the options needed to make a request to LinkOutputPortToTechnicalAsset.
type LinkOutputPortToTechnicalAssetRequestOptions struct {
	PathParams *LinkOutputPortToTechnicalAssetPath
	Body       *LinkOutputPortToTechnicalAssetBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UnlinkOutputPortFromTechnicalAssetRequestOptions is the options needed to make a request to UnlinkOutputPortFromTechnicalAsset.
type UnlinkOutputPortFromTechnicalAssetRequestOptions struct {
	PathParams *UnlinkOutputPortFromTechnicalAssetPath
	Body       *UnlinkOutputPortFromTechnicalAssetBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetTechnicalAssetRequestOptions is the options needed to make a request to GetTechnicalAsset.
type GetTechnicalAssetRequestOptions struct {
	PathParams *GetTechnicalAssetPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetTechnicalAssetRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveTechnicalAssetRequestOptions is the options needed to make a request to RemoveTechnicalAsset.
type RemoveTechnicalAssetRequestOptions struct {
	PathParams *RemoveTechnicalAssetPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveTechnicalAssetRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetTechnicalAssetEventHistoryRequestOptions is the options needed to make a request to GetTechnicalAssetEventHistory.
type GetTechnicalAssetEventHistoryRequestOptions struct {
	PathParams *GetTechnicalAssetEventHistoryPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetTechnicalAssetEventHistoryRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetTechnicalAssetEventHistoryRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetTechnicalAssetEventHistoryRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetTechnicalAssetEventHistoryRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetTechnicalAssetEventHistoryRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateTechnicalAssetStatusRequestOptions is the options needed to make a request to UpdateTechnicalAssetStatus.
type UpdateTechnicalAssetStatusRequestOptions struct {
	PathParams *UpdateTechnicalAssetStatusPath
	Body       *UpdateTechnicalAssetStatusBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateTechnicalAssetStatusRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateTechnicalAssetStatusRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateTechnicalAssetStatusRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateTechnicalAssetStatusRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateTechnicalAssetStatusRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetTechnicalAssetGraphDataRequestOptions is the options needed to make a request to GetTechnicalAssetGraphData.
type GetTechnicalAssetGraphDataRequestOptions struct {
	PathParams *GetTechnicalAssetGraphDataPath
	Query      *GetTechnicalAssetGraphDataQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetTechnicalAssetGraphDataRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetTechnicalAssetGraphDataRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetTechnicalAssetGraphDataRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetTechnicalAssetGraphDataRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetTechnicalAssetGraphDataRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDomainRequestOptions is the options needed to make a request to CreateDomain.
type CreateDomainRequestOptions struct {
	Body *CreateDomainBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDomainRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDomainRequestOptions is the options needed to make a request to UpdateDomain.
type UpdateDomainRequestOptions struct {
	PathParams *UpdateDomainPath
	Body       *UpdateDomainBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDomainRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDomainRequestOptions is the options needed to make a request to RemoveDomain.
type RemoveDomainRequestOptions struct {
	PathParams *RemoveDomainPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDomainRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDomainRequestOptions is the options needed to make a request to GetDomain.
type GetDomainRequestOptions struct {
	PathParams *GetDomainPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDomainRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// MigrateDomainRequestOptions is the options needed to make a request to MigrateDomain.
type MigrateDomainRequestOptions struct {
	PathParams *MigrateDomainPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *MigrateDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *MigrateDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *MigrateDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *MigrateDomainRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *MigrateDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentRequestOptions is the options needed to make a request to GetEnvironment.
type GetEnvironmentRequestOptions struct {
	PathParams *GetEnvironmentPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentConfigsByIDRequestOptions is the options needed to make a request to GetEnvironmentConfigsByID.
type GetEnvironmentConfigsByIDRequestOptions struct {
	PathParams *GetEnvironmentConfigsByIDPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentConfigsByIDRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentConfigsByIDRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentConfigsByIDRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentConfigsByIDRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentConfigsByIDRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentPlatformServiceConfigRequestOptions is the options needed to make a request to GetEnvironmentPlatformServiceConfig.
type GetEnvironmentPlatformServiceConfigRequestOptions struct {
	PathParams *GetEnvironmentPlatformServiceConfigPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentPlatformConfigRequestOptions is the options needed to make a request to GetEnvironmentPlatformConfig.
type GetEnvironmentPlatformConfigRequestOptions struct {
	PathParams *GetEnvironmentPlatformConfigPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentPlatformConfigRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentPlatformConfigRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentPlatformConfigRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentPlatformConfigRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentPlatformConfigRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentConfigsRequestOptions is the options needed to make a request to GetEnvironmentConfigs.
type GetEnvironmentConfigsRequestOptions struct {
	PathParams *GetEnvironmentConfigsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentConfigsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentConfigsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentConfigsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentConfigsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentConfigsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions is the options needed to make a request to GetEnvironmentPlatformServiceConfigForAllEnvs.
type GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions struct {
	PathParams *GetEnvironmentPlatformServiceConfigForAllEnvsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetPlatformServiceConfigRequestOptions is the options needed to make a request to GetPlatformServiceConfig.
type GetPlatformServiceConfigRequestOptions struct {
	PathParams *GetPlatformServiceConfigPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetPlatformServiceConfigRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetPlatformServiceConfigRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetPlatformServiceConfigRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetPlatformServiceConfigRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetPlatformServiceConfigRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetSinglePlatformServiceConfigurationRequestOptions is the options needed to make a request to GetSinglePlatformServiceConfiguration.
type GetSinglePlatformServiceConfigurationRequestOptions struct {
	PathParams *GetSinglePlatformServiceConfigurationPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetPlatformServicesRequestOptions is the options needed to make a request to GetPlatformServices.
type GetPlatformServicesRequestOptions struct {
	PathParams *GetPlatformServicesPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetPlatformServicesRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetPlatformServicesRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetPlatformServicesRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetPlatformServicesRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetPlatformServicesRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateTagRequestOptions is the options needed to make a request to CreateTag.
type CreateTagRequestOptions struct {
	Body *CreateTagBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateTagRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateTagRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateTagRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateTagRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateTagRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateTagRequestOptions is the options needed to make a request to UpdateTag.
type UpdateTagRequestOptions struct {
	PathParams *UpdateTagPath
	Body       *UpdateTagBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateTagRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateTagRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateTagRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateTagRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateTagRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveTagRequestOptions is the options needed to make a request to RemoveTag.
type RemoveTagRequestOptions struct {
	PathParams *RemoveTagPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveTagRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveTagRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveTagRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveTagRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveTagRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveUserRequestOptions is the options needed to make a request to RemoveUser.
type RemoveUserRequestOptions struct {
	PathParams *RemoveUserPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveUserRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveUserRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveUserRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveUserRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveUserRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateUserRequestOptions is the options needed to make a request to CreateUser.
type CreateUserRequestOptions struct {
	Body *CreateUserBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateUserRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateUserRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateUserRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateUserRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateUserRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// SetCanBecomeAdminRequestOptions is the options needed to make a request to SetCanBecomeAdmin.
type SetCanBecomeAdminRequestOptions struct {
	Body *SetCanBecomeAdminBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *SetCanBecomeAdminRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *SetCanBecomeAdminRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *SetCanBecomeAdminRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *SetCanBecomeAdminRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *SetCanBecomeAdminRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateRoleRequestOptions is the options needed to make a request to CreateRole.
type CreateRoleRequestOptions struct {
	Body *CreateRoleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateRoleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateRoleRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateRoleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateRoleRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateRoleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveRoleRequestOptions is the options needed to make a request to RemoveRole.
type RemoveRoleRequestOptions struct {
	PathParams *RemoveRolePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveRoleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveRoleRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveRoleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveRoleRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveRoleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateRoleRequestOptions is the options needed to make a request to UpdateRole.
type UpdateRoleRequestOptions struct {
	PathParams *UpdateRolePath
	Body       *UpdateRoleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateRoleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateRoleRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateRoleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateRoleRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateRoleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetRolesRequestOptions is the options needed to make a request to GetRoles.
type GetRolesRequestOptions struct {
	PathParams *GetRolesPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetRolesRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetRolesRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetRolesRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetRolesRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetRolesRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// BecomeAdminRequestOptions is the options needed to make a request to BecomeAdmin.
type BecomeAdminRequestOptions struct {
	Body *BecomeAdminBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *BecomeAdminRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *BecomeAdminRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *BecomeAdminRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *BecomeAdminRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *BecomeAdminRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateGlobalRoleAssignmentRequestOptions is the options needed to make a request to CreateGlobalRoleAssignment.
type CreateGlobalRoleAssignmentRequestOptions struct {
	Body *CreateGlobalRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateGlobalRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateGlobalRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateGlobalRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateGlobalRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateGlobalRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ListGlobalRoleAssignmentsRequestOptions is the options needed to make a request to ListGlobalRoleAssignments.
type ListGlobalRoleAssignmentsRequestOptions struct {
	Query *ListGlobalRoleAssignmentsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ListGlobalRoleAssignmentsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ListGlobalRoleAssignmentsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *ListGlobalRoleAssignmentsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ListGlobalRoleAssignmentsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *ListGlobalRoleAssignmentsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteGlobalRoleAssignmentRequestOptions is the options needed to make a request to DeleteGlobalRoleAssignment.
type DeleteGlobalRoleAssignmentRequestOptions struct {
	PathParams *DeleteGlobalRoleAssignmentPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteGlobalRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteGlobalRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteGlobalRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteGlobalRoleAssignmentRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *DeleteGlobalRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DecideGlobalRoleAssignmentRequestOptions is the options needed to make a request to DecideGlobalRoleAssignment.
type DecideGlobalRoleAssignmentRequestOptions struct {
	PathParams *DecideGlobalRoleAssignmentPath
	Body       *DecideGlobalRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DecideGlobalRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DecideGlobalRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DecideGlobalRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DecideGlobalRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DecideGlobalRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ModifyGlobalRoleAssignmentRequestOptions is the options needed to make a request to ModifyGlobalRoleAssignment.
type ModifyGlobalRoleAssignmentRequestOptions struct {
	PathParams *ModifyGlobalRoleAssignmentPath
	Body       *ModifyGlobalRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ModifyGlobalRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ModifyGlobalRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ModifyGlobalRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ModifyGlobalRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ModifyGlobalRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteDataProductRoleAssignmentRequestOptions is the options needed to make a request to DeleteDataProductRoleAssignment.
type DeleteDataProductRoleAssignmentRequestOptions struct {
	PathParams *DeleteDataProductRoleAssignmentPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteDataProductRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteDataProductRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteDataProductRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteDataProductRoleAssignmentRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *DeleteDataProductRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ModifyDataProductRoleAssignmentRequestOptions is the options needed to make a request to ModifyDataProductRoleAssignment.
type ModifyDataProductRoleAssignmentRequestOptions struct {
	PathParams *ModifyDataProductRoleAssignmentPath
	Body       *ModifyDataProductRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ModifyDataProductRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ModifyDataProductRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ModifyDataProductRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ModifyDataProductRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ModifyDataProductRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ListDataProductRoleAssignmentsRequestOptions is the options needed to make a request to ListDataProductRoleAssignments.
type ListDataProductRoleAssignmentsRequestOptions struct {
	Query *ListDataProductRoleAssignmentsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ListDataProductRoleAssignmentsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ListDataProductRoleAssignmentsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *ListDataProductRoleAssignmentsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ListDataProductRoleAssignmentsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *ListDataProductRoleAssignmentsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDataProductRoleAssignmentRequestOptions is the options needed to make a request to CreateDataProductRoleAssignment.
type CreateDataProductRoleAssignmentRequestOptions struct {
	Body *CreateDataProductRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDataProductRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDataProductRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDataProductRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDataProductRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDataProductRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RequestDataProductRoleAssignmentRequestOptions is the options needed to make a request to RequestDataProductRoleAssignment.
type RequestDataProductRoleAssignmentRequestOptions struct {
	Body *RequestDataProductRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RequestDataProductRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RequestDataProductRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *RequestDataProductRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RequestDataProductRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *RequestDataProductRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DecideDataProductRoleAssignmentRequestOptions is the options needed to make a request to DecideDataProductRoleAssignment.
type DecideDataProductRoleAssignmentRequestOptions struct {
	PathParams *DecideDataProductRoleAssignmentPath
	Body       *DecideDataProductRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DecideDataProductRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DecideDataProductRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DecideDataProductRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DecideDataProductRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DecideDataProductRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteOutputPortRoleAssignmentRequestOptions is the options needed to make a request to DeleteOutputPortRoleAssignment.
type DeleteOutputPortRoleAssignmentRequestOptions struct {
	PathParams *DeleteOutputPortRoleAssignmentPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteOutputPortRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteOutputPortRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteOutputPortRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteOutputPortRoleAssignmentRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *DeleteOutputPortRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ModifyOutputPortRoleAssignmentRequestOptions is the options needed to make a request to ModifyOutputPortRoleAssignment.
type ModifyOutputPortRoleAssignmentRequestOptions struct {
	PathParams *ModifyOutputPortRoleAssignmentPath
	Body       *ModifyOutputPortRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ModifyOutputPortRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ModifyOutputPortRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ModifyOutputPortRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ModifyOutputPortRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ModifyOutputPortRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ListOutputPortRoleAssignmentsRequestOptions is the options needed to make a request to ListOutputPortRoleAssignments.
type ListOutputPortRoleAssignmentsRequestOptions struct {
	Query *ListOutputPortRoleAssignmentsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ListOutputPortRoleAssignmentsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ListOutputPortRoleAssignmentsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *ListOutputPortRoleAssignmentsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ListOutputPortRoleAssignmentsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *ListOutputPortRoleAssignmentsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateOutputPortRoleAssignmentRequestOptions is the options needed to make a request to CreateOutputPortRoleAssignment.
type CreateOutputPortRoleAssignmentRequestOptions struct {
	Body *CreateOutputPortRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateOutputPortRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateOutputPortRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateOutputPortRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateOutputPortRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateOutputPortRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RequestOutputPortRoleAssignmentRequestOptions is the options needed to make a request to RequestOutputPortRoleAssignment.
type RequestOutputPortRoleAssignmentRequestOptions struct {
	Body *RequestOutputPortRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RequestOutputPortRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RequestOutputPortRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *RequestOutputPortRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RequestOutputPortRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *RequestOutputPortRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DecideOutputPortRoleAssignmentRequestOptions is the options needed to make a request to DecideOutputPortRoleAssignment.
type DecideOutputPortRoleAssignmentRequestOptions struct {
	PathParams *DecideOutputPortRoleAssignmentPath
	Body       *DecideOutputPortRoleAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DecideOutputPortRoleAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DecideOutputPortRoleAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DecideOutputPortRoleAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DecideOutputPortRoleAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DecideOutputPortRoleAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateThemeSettingsRequestOptions is the options needed to make a request to UpdateThemeSettings.
type UpdateThemeSettingsRequestOptions struct {
	Body *UpdateThemeSettingsBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateThemeSettingsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateThemeSettingsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *UpdateThemeSettingsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateThemeSettingsRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateThemeSettingsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetGraphDataRequestOptions is the options needed to make a request to GetGraphData.
type GetGraphDataRequestOptions struct {
	Query *GetGraphDataQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetGraphDataRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetGraphDataRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *GetGraphDataRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetGraphDataRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetGraphDataRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveUserNotificationRequestOptions is the options needed to make a request to RemoveUserNotification.
type RemoveUserNotificationRequestOptions struct {
	PathParams *RemoveUserNotificationPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveUserNotificationRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveUserNotificationRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveUserNotificationRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveUserNotificationRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveUserNotificationRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// SanitizeResourceNameRequestOptions is the options needed to make a request to SanitizeResourceName.
type SanitizeResourceNameRequestOptions struct {
	Query *SanitizeResourceNameQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *SanitizeResourceNameRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *SanitizeResourceNameRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *SanitizeResourceNameRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *SanitizeResourceNameRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *SanitizeResourceNameRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ValidateResourceNameRequestOptions is the options needed to make a request to ValidateResourceName.
type ValidateResourceNameRequestOptions struct {
	Body *ValidateResourceNameBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ValidateResourceNameRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ValidateResourceNameRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *ValidateResourceNameRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ValidateResourceNameRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ValidateResourceNameRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetPluginFormRequestOptions is the options needed to make a request to GetPluginForm.
type GetPluginFormRequestOptions struct {
	PathParams *GetPluginFormPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetPluginFormRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetPluginFormRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetPluginFormRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetPluginFormRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetPluginFormRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDeviceTokenRequestOptions is the options needed to make a request to GetDeviceToken.
type GetDeviceTokenRequestOptions struct {
	Query *GetDeviceTokenQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDeviceTokenRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDeviceTokenRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *GetDeviceTokenRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDeviceTokenRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDeviceTokenRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetJwtTokenRequestOptions is the options needed to make a request to GetJwtToken.
type GetJwtTokenRequestOptions struct {
	Query *GetJwtTokenQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetJwtTokenRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetJwtTokenRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *GetJwtTokenRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetJwtTokenRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetJwtTokenRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetAwsCredentialsRequestOptions is the options needed to make a request to GetAwsCredentials.
type GetAwsCredentialsRequestOptions struct {
	Query *GetAwsCredentialsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetAwsCredentialsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetAwsCredentialsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *GetAwsCredentialsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetAwsCredentialsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetAwsCredentialsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

type AccessGranularity string

const (
	AccessGranularitySchema AccessGranularity = "schema"
	AccessGranularityTable  AccessGranularity = "table"
)

// Validate checks if the AccessGranularity value is valid
func (a AccessGranularity) Validate() error {
	switch a {
	case AccessGranularitySchema, AccessGranularityTable:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid AccessGranularity value, got: %v", a))
	}
}

// AuthorizationAction The integer values for the authorization actions are stored directly in the DB.
// This means you can change the name of the actions, but not their integer values.
// The values for the actions are spaced on purpose, to make it easier to extend.
// This has no technical benefit, but it makes it easier to read for developers.
type AuthorizationAction int

const (
	AuthorizationActionN101 AuthorizationAction = 101
	AuthorizationActionN102 AuthorizationAction = 102
	AuthorizationActionN103 AuthorizationAction = 103
	AuthorizationActionN104 AuthorizationAction = 104
	AuthorizationActionN105 AuthorizationAction = 105
	AuthorizationActionN106 AuthorizationAction = 106
	AuthorizationActionN107 AuthorizationAction = 107
	AuthorizationActionN301 AuthorizationAction = 301
	AuthorizationActionN302 AuthorizationAction = 302
	AuthorizationActionN303 AuthorizationAction = 303
	AuthorizationActionN304 AuthorizationAction = 304
	AuthorizationActionN305 AuthorizationAction = 305
	AuthorizationActionN306 AuthorizationAction = 306
	AuthorizationActionN307 AuthorizationAction = 307
	AuthorizationActionN308 AuthorizationAction = 308
	AuthorizationActionN309 AuthorizationAction = 309
	AuthorizationActionN310 AuthorizationAction = 310
	AuthorizationActionN311 AuthorizationAction = 311
	AuthorizationActionN312 AuthorizationAction = 312
	AuthorizationActionN313 AuthorizationAction = 313
	AuthorizationActionN314 AuthorizationAction = 314
	AuthorizationActionN315 AuthorizationAction = 315
	AuthorizationActionN401 AuthorizationAction = 401
	AuthorizationActionN402 AuthorizationAction = 402
	AuthorizationActionN403 AuthorizationAction = 403
	AuthorizationActionN404 AuthorizationAction = 404
	AuthorizationActionN405 AuthorizationAction = 405
	AuthorizationActionN406 AuthorizationAction = 406
	AuthorizationActionN407 AuthorizationAction = 407
	AuthorizationActionN408 AuthorizationAction = 408
	AuthorizationActionN409 AuthorizationAction = 409
	AuthorizationActionN410 AuthorizationAction = 410
	AuthorizationActionN411 AuthorizationAction = 411
	AuthorizationActionN412 AuthorizationAction = 412
	AuthorizationActionN413 AuthorizationAction = 413
)

// Validate checks if the AuthorizationAction value is valid
func (a AuthorizationAction) Validate() error {
	switch a {
	case AuthorizationActionN101, AuthorizationActionN102, AuthorizationActionN103, AuthorizationActionN104, AuthorizationActionN105, AuthorizationActionN106, AuthorizationActionN107, AuthorizationActionN301, AuthorizationActionN302, AuthorizationActionN303, AuthorizationActionN304, AuthorizationActionN305, AuthorizationActionN306, AuthorizationActionN307, AuthorizationActionN308, AuthorizationActionN309, AuthorizationActionN310, AuthorizationActionN311, AuthorizationActionN312, AuthorizationActionN313, AuthorizationActionN314, AuthorizationActionN315, AuthorizationActionN401, AuthorizationActionN402, AuthorizationActionN403, AuthorizationActionN404, AuthorizationActionN405, AuthorizationActionN406, AuthorizationActionN407, AuthorizationActionN408, AuthorizationActionN409, AuthorizationActionN410, AuthorizationActionN411, AuthorizationActionN412, AuthorizationActionN413:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid AuthorizationAction value, got: %v", a))
	}
}

type DataProductIconKey string

const (
	DataProductIconKeyAnalytics       DataProductIconKey = "analytics"
	DataProductIconKeyDefault         DataProductIconKey = "default"
	DataProductIconKeyExploration     DataProductIconKey = "exploration"
	DataProductIconKeyIngestion       DataProductIconKey = "ingestion"
	DataProductIconKeyMachineLearning DataProductIconKey = "machine_learning"
	DataProductIconKeyProcessing      DataProductIconKey = "processing"
	DataProductIconKeyReporting       DataProductIconKey = "reporting"
)

// Validate checks if the DataProductIconKey value is valid
func (d DataProductIconKey) Validate() error {
	switch d {
	case DataProductIconKeyAnalytics, DataProductIconKeyDefault, DataProductIconKeyExploration, DataProductIconKeyIngestion, DataProductIconKeyMachineLearning, DataProductIconKeyProcessing, DataProductIconKeyReporting:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DataProductIconKey value, got: %v", d))
	}
}

type DataProductSettingScope string

const (
	DataProductSettingScopeDataproduct DataProductSettingScope = "dataproduct"
	DataProductSettingScopeDataset     DataProductSettingScope = "dataset"
)

// Validate checks if the DataProductSettingScope value is valid
func (d DataProductSettingScope) Validate() error {
	switch d {
	case DataProductSettingScopeDataproduct, DataProductSettingScopeDataset:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DataProductSettingScope value, got: %v", d))
	}
}

type DataProductSettingType string

const (
	DataProductSettingTypeCheckbox DataProductSettingType = "checkbox"
	DataProductSettingTypeInput    DataProductSettingType = "input"
	DataProductSettingTypeTags     DataProductSettingType = "tags"
)

// Validate checks if the DataProductSettingType value is valid
func (d DataProductSettingType) Validate() error {
	switch d {
	case DataProductSettingTypeCheckbox, DataProductSettingTypeInput, DataProductSettingTypeTags:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DataProductSettingType value, got: %v", d))
	}
}

type DataProductStatus string

const (
	DataProductStatusActive   DataProductStatus = "active"
	DataProductStatusArchived DataProductStatus = "archived"
	DataProductStatusPending  DataProductStatus = "pending"
)

// Validate checks if the DataProductStatus value is valid
func (d DataProductStatus) Validate() error {
	switch d {
	case DataProductStatusActive, DataProductStatusArchived, DataProductStatusPending:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DataProductStatus value, got: %v", d))
	}
}

type DecisionStatus string

const (
	DecisionStatusApproved DecisionStatus = "approved"
	DecisionStatusDenied   DecisionStatus = "denied"
	DecisionStatusPending  DecisionStatus = "pending"
)

// Validate checks if the DecisionStatus value is valid
func (d DecisionStatus) Validate() error {
	switch d {
	case DecisionStatusApproved, DecisionStatusDenied, DecisionStatusPending:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DecisionStatus value, got: %v", d))
	}
}

type EventEntityType string

const (
	EventEntityTypeDataProduct    EventEntityType = "data_product"
	EventEntityTypeOutputPort     EventEntityType = "output_port"
	EventEntityTypeTechnicalAsset EventEntityType = "technical_asset"
	EventEntityTypeUser           EventEntityType = "user"
)

// Validate checks if the EventEntityType value is valid
func (e EventEntityType) Validate() error {
	switch e {
	case EventEntityTypeDataProduct, EventEntityTypeOutputPort, EventEntityTypeTechnicalAsset, EventEntityTypeUser:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid EventEntityType value, got: %v", e))
	}
}

type NodeType string

const (
	NodeTypeDataOutputNode  NodeType = "dataOutputNode"
	NodeTypeDataProductNode NodeType = "dataProductNode"
	NodeTypeDatasetNode     NodeType = "datasetNode"
	NodeTypeDomainNode      NodeType = "domainNode"
)

// Validate checks if the NodeType value is valid
func (n NodeType) Validate() error {
	switch n {
	case NodeTypeDataOutputNode, NodeTypeDataProductNode, NodeTypeDatasetNode, NodeTypeDomainNode:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid NodeType value, got: %v", n))
	}
}

type OutputPortAccessType string

const (
	OutputPortAccessTypePrivate    OutputPortAccessType = "private"
	OutputPortAccessTypePublic     OutputPortAccessType = "public"
	OutputPortAccessTypeRestricted OutputPortAccessType = "restricted"
)

// Validate checks if the OutputPortAccessType value is valid
func (o OutputPortAccessType) Validate() error {
	switch o {
	case OutputPortAccessTypePrivate, OutputPortAccessTypePublic, OutputPortAccessTypeRestricted:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid OutputPortAccessType value, got: %v", o))
	}
}

type OutputPortStatus string

const (
	OutputPortStatusActive   OutputPortStatus = "active"
	OutputPortStatusArchived OutputPortStatus = "archived"
	OutputPortStatusPending  OutputPortStatus = "pending"
)

// Validate checks if the OutputPortStatus value is valid
func (o OutputPortStatus) Validate() error {
	switch o {
	case OutputPortStatusActive, OutputPortStatusArchived, OutputPortStatusPending:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid OutputPortStatus value, got: %v", o))
	}
}

type Prototype int

const (
	PrototypeN0 Prototype = 0
	PrototypeN1 Prototype = 1
	PrototypeN2 Prototype = 2
	PrototypeN3 Prototype = 3
)

// Validate checks if the Prototype value is valid
func (p Prototype) Validate() error {
	switch p {
	case PrototypeN0, PrototypeN1, PrototypeN2, PrototypeN3:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid Prototype value, got: %v", p))
	}
}

type QueryStatsGranularity string

const (
	QueryStatsGranularityDay   QueryStatsGranularity = "day"
	QueryStatsGranularityMonth QueryStatsGranularity = "month"
	QueryStatsGranularityWeek  QueryStatsGranularity = "week"
)

// Validate checks if the QueryStatsGranularity value is valid
func (q QueryStatsGranularity) Validate() error {
	switch q {
	case QueryStatsGranularityDay, QueryStatsGranularityMonth, QueryStatsGranularityWeek:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid QueryStatsGranularity value, got: %v", q))
	}
}

type ResourceNameModel string

const (
	ResourceNameModelDataProduct        ResourceNameModel = "data_product"
	ResourceNameModelDataProductSetting ResourceNameModel = "data_product_setting"
	ResourceNameModelOutputPort         ResourceNameModel = "output_port"
	ResourceNameModelOutputPortSetting  ResourceNameModel = "output_port_setting"
	ResourceNameModelTechnicalAsset     ResourceNameModel = "technical_asset"
)

// Validate checks if the ResourceNameModel value is valid
func (r ResourceNameModel) Validate() error {
	switch r {
	case ResourceNameModelDataProduct, ResourceNameModelDataProductSetting, ResourceNameModelOutputPort, ResourceNameModelOutputPortSetting, ResourceNameModelTechnicalAsset:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid ResourceNameModel value, got: %v", r))
	}
}

type ResourceNameValidityType string

const (
	ResourceNameValidityTypeDUPLICATENAMESPACE ResourceNameValidityType = "DUPLICATE_NAMESPACE"
	ResourceNameValidityTypeINVALIDCHARACTERS  ResourceNameValidityType = "INVALID_CHARACTERS"
	ResourceNameValidityTypeINVALIDLENGTH      ResourceNameValidityType = "INVALID_LENGTH"
	ResourceNameValidityTypeVALID              ResourceNameValidityType = "VALID"
)

// Validate checks if the ResourceNameValidityType value is valid
func (r ResourceNameValidityType) Validate() error {
	switch r {
	case ResourceNameValidityTypeDUPLICATENAMESPACE, ResourceNameValidityTypeINVALIDCHARACTERS, ResourceNameValidityTypeINVALIDLENGTH, ResourceNameValidityTypeVALID:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid ResourceNameValidityType value, got: %v", r))
	}
}

type Scope string

const (
	ScopeDataProduct Scope = "data_product"
	ScopeDataset     Scope = "dataset"
	ScopeDomain      Scope = "domain"
	ScopeGlobal      Scope = "global"
)

// Validate checks if the Scope value is valid
func (s Scope) Validate() error {
	switch s {
	case ScopeDataProduct, ScopeDataset, ScopeDomain, ScopeGlobal:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid Scope value, got: %v", s))
	}
}

type TechnicalAssetStatus string

const (
	TechnicalAssetStatusActive   TechnicalAssetStatus = "active"
	TechnicalAssetStatusArchived TechnicalAssetStatus = "archived"
	TechnicalAssetStatusPending  TechnicalAssetStatus = "pending"
)

// Validate checks if the TechnicalAssetStatus value is valid
func (t TechnicalAssetStatus) Validate() error {
	switch t {
	case TechnicalAssetStatusActive, TechnicalAssetStatusArchived, TechnicalAssetStatusPending:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid TechnicalAssetStatus value, got: %v", t))
	}
}

type TechnicalMapping string

const (
	TechnicalMappingCustom  TechnicalMapping = "custom"
	TechnicalMappingDefault TechnicalMapping = "default"
)

// Validate checks if the TechnicalMapping value is valid
func (t TechnicalMapping) Validate() error {
	switch t {
	case TechnicalMappingCustom, TechnicalMappingDefault:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid TechnicalMapping value, got: %v", t))
	}
}

type UIElementType string

const (
	UIElementTypeCheckbox UIElementType = "checkbox"
	UIElementTypeRadio    UIElementType = "radio"
	UIElementTypeSelect   UIElementType = "select"
	UIElementTypeString   UIElementType = "string"
)

// Validate checks if the UIElementType value is valid
func (u UIElementType) Validate() error {
	switch u {
	case UIElementTypeCheckbox, UIElementTypeRadio, UIElementTypeSelect, UIElementTypeString:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid UIElementType value, got: %v", u))
	}
}

type CheckAccessPath struct {
	Action AuthorizationAction `json:"action" validate:"required"`
}

func (c CheckAccessPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.Action).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Action", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortQueryStatsPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetOutputPortQueryStatsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortQueryStatsPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortQueryStatsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteOutputPortQueryStatPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteOutputPortQueryStatPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortCuratedQueriesPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetOutputPortCuratedQueriesPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ReplaceOutputPortCuratedQueriesPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (r ReplaceOutputPortCuratedQueriesPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductOutputPortsPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (g GetDataProductOutputPortsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateOutputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (c CreateOutputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetOutputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDatasetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDatasetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortsEventHistoryPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetOutputPortsEventHistoryPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortAboutPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortAboutPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortStatusPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortStatusPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortGraphDataPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetOutputPortGraphDataPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SetValueForOutputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
	SettingID     uuid.UUID `json:"setting_id" validate:"required"`
}

func (s SetValueForOutputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(s.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(s.SettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SettingID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDataProductPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductAboutPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductAboutPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductStatusPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductStatusPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductUsagePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductUsagePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductGraphDataPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductGraphDataPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SetValueForDataProductPath struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	SettingID uuid.UUID `json:"setting_id" validate:"required"`
}

func (s SetValueForDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(s.SettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SettingID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkInputPortsToDataProductPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (l LinkInputPortsToDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductEventHistoryPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductEventHistoryPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTechnicalAssetPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSigninURLPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetSigninURLPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetConveyorIdeURLPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetConveyorIdeURLPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDatabricksWorkspaceURLPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDatabricksWorkspaceURLPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSnowflakeURLPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetSnowflakeURLPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetsPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetTechnicalAssetsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductInputPortsPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductInputPortsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductRolledUpTagsPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductRolledUpTagsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UnlinkInputPortFromDataProductPath struct {
	ID          uuid.UUID `json:"id" validate:"required"`
	InputPortID uuid.UUID `json:"input_port_id" validate:"required"`
}

func (u UnlinkInputPortFromDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(u.InputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("InputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductTypePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductTypePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductTypePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductTypePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDataProductTypePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDataProductTypePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MigrateDataProductTypePath struct {
	FromID uuid.UUID `json:"from_id" validate:"required"`
	ToID   uuid.UUID `json:"to_id" validate:"required"`
}

func (m MigrateDataProductTypePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.FromID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("FromID", err)
		}
	}
	if v, ok := any(m.ToID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ToID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductLifecyclePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductLifecyclePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDataProductLifecyclePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDataProductLifecyclePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductSettingPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductSettingPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDataProductSettingPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDataProductSettingPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ApproveOutputPortAsInputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID `json:"output_port_id" validate:"required"`
}

func (a ApproveOutputPortAsInputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(a.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DenyOutputPortAsInputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID `json:"output_port_id" validate:"required"`
}

func (d DenyOutputPortAsInputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(d.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveOutputPortAsInputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID `json:"output_port_id" validate:"required"`
}

func (r RemoveOutputPortAsInputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(r.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ApproveOutputPortTechnicalAssetLinkPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID `json:"output_port_id" validate:"required"`
}

func (a ApproveOutputPortTechnicalAssetLinkPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(a.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DenyOutputPortTechnicalAssetLinkPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID `json:"output_port_id" validate:"required"`
}

func (d DenyOutputPortTechnicalAssetLinkPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(d.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkOutputPortToTechnicalAssetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID `json:"output_port_id" validate:"required"`
}

func (l LinkOutputPortToTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(l.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UnlinkOutputPortFromTechnicalAssetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID `json:"output_port_id" validate:"required"`
}

func (u UnlinkOutputPortFromTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveTechnicalAssetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetEventHistoryPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetTechnicalAssetEventHistoryPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateTechnicalAssetStatusPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateTechnicalAssetStatusPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetGraphDataPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetTechnicalAssetGraphDataPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDomainPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDomainPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDomainPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDomainPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDomainPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDomainPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MigrateDomainPath struct {
	FromID uuid.UUID `json:"from_id" validate:"required"`
	ToID   uuid.UUID `json:"to_id" validate:"required"`
}

func (m MigrateDomainPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.FromID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("FromID", err)
		}
	}
	if v, ok := any(m.ToID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ToID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetEnvironmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentConfigsByIDPath struct {
	ConfigID uuid.UUID `json:"config_id" validate:"required"`
}

func (g GetEnvironmentConfigsByIDPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfigID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfigID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentPlatformServiceConfigPath struct {
	ID         uuid.UUID `json:"id" validate:"required"`
	PlatformID uuid.UUID `json:"platform_id" validate:"required"`
	ServiceID  uuid.UUID `json:"service_id" validate:"required"`
}

func (g GetEnvironmentPlatformServiceConfigPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(g.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentPlatformConfigPath struct {
	ID         uuid.UUID `json:"id" validate:"required"`
	PlatformID uuid.UUID `json:"platform_id" validate:"required"`
}

func (g GetEnvironmentPlatformConfigPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentConfigsPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetEnvironmentConfigsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentPlatformServiceConfigForAllEnvsPath struct {
	PlatformID uuid.UUID `json:"platform_id" validate:"required"`
	ServiceID  uuid.UUID `json:"service_id" validate:"required"`
}

func (g GetEnvironmentPlatformServiceConfigForAllEnvsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(g.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetPlatformServiceConfigPath struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	ServiceID uuid.UUID `json:"service_id" validate:"required"`
}

func (g GetPlatformServiceConfigPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSinglePlatformServiceConfigurationPath struct {
	ConfigID uuid.UUID `json:"config_id" validate:"required"`
}

func (g GetSinglePlatformServiceConfigurationPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfigID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfigID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetPlatformServicesPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetPlatformServicesPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateTagPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateTagPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveTagPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveTagPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveUserPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveUserPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveRolePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveRolePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateRolePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateRolePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRolesPath struct {
	Scope Scope `json:"scope" validate:"required"`
}

func (g GetRolesPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteGlobalRoleAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteGlobalRoleAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideGlobalRoleAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DecideGlobalRoleAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyGlobalRoleAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (m ModifyGlobalRoleAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteDataProductRoleAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteDataProductRoleAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyDataProductRoleAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (m ModifyDataProductRoleAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideDataProductRoleAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DecideDataProductRoleAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteOutputPortRoleAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteOutputPortRoleAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyOutputPortRoleAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (m ModifyOutputPortRoleAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideOutputPortRoleAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DecideOutputPortRoleAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveUserNotificationPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveUserNotificationPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetPluginFormPath struct {
	PluginName string `json:"plugin_name" validate:"required"`
}

func (g GetPluginFormPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type UpdateOutputPortQueryStatsBody = UpdateOutputPortQueryStatus

type DeleteOutputPortQueryStatBody = OutputPortQueryStatsDelete

type ReplaceOutputPortCuratedQueriesBody = OutputPortCuratedQueriesUpdate

type CreateOutputPortBody = CreateOutputPortRequest

type UpdateOutputPortBody = DatasetUpdate

type UpdateOutputPortAboutBody = DatasetAboutUpdate

type UpdateOutputPortStatusBody = DatasetStatusUpdate

type CreateDataProductBody = DataProductCreate

type UpdateDataProductBody = DataProductUpdate

type UpdateDataProductAboutBody = DataProductAboutUpdate

type UpdateDataProductStatusBody = DataProductStatusUpdate

type UpdateDataProductUsageBody = DataProductUsageUpdate

type LinkInputPortsToDataProductBody = LinkInputPortsToDataProduct

type CreateTechnicalAssetBody = CreateTechnicalAssetRequest

type UpdateDataProductTypeBody = DataProductTypeUpdate

type CreateDataProductTypeBody = DataProductTypeCreate

type CreateDataProductLifecycleBody = DataProductLifeCycleCreate

type UpdateDataProductLifecycleBody = DataProductLifeCycleUpdate

type CreateDataProductSettingBody = DataProductSettingCreate

type UpdateDataProductSettingBody = DataProductSettingUpdate

type ApproveOutputPortAsInputPortBody = ApproveOutputPortAsInputPortRequest

type DenyOutputPortAsInputPortBody = DenyOutputPortAsInputPortRequest

type RemoveOutputPortAsInputPortBody = RemoveOutputPortAsInputPortRequest

type ApproveOutputPortTechnicalAssetLinkBody = ApproveLinkBetweenTechnicalAssetAndOutputPortRequest

type DenyOutputPortTechnicalAssetLinkBody = DenyLinkBetweenTechnicalAssetAndOutputPortRequest

type LinkOutputPortToTechnicalAssetBody = LinkTechnicalAssetToOutputPortRequest

type UnlinkOutputPortFromTechnicalAssetBody = UnLinkTechnicalAssetToOutputPortRequest

type UpdateTechnicalAssetStatusBody = DataOutputStatusUpdate

type CreateDomainBody = DomainCreate

type UpdateDomainBody = DomainUpdate

type CreateTagBody = TagCreate

type UpdateTagBody = TagUpdate

type CreateUserBody = UserCreate

type SetCanBecomeAdminBody = CanBecomeAdminUpdate

type CreateRoleBody = CreateRole

type UpdateRoleBody = UpdateRole

type BecomeAdminBody = BecomeAdmin

type CreateGlobalRoleAssignmentBody = CreateGlobalRoleAssignment

type DecideGlobalRoleAssignmentBody = DecideGlobalRoleAssignment

type ModifyGlobalRoleAssignmentBody = ModifyGlobalRoleAssignment

type ModifyDataProductRoleAssignmentBody = ModifyDataProductRoleAssignment

type CreateDataProductRoleAssignmentBody = CreateDataProductRoleAssignment

type RequestDataProductRoleAssignmentBody = RequestDataProductRoleAssignment

type DecideDataProductRoleAssignmentBody = DecideDataProductRoleAssignment

type ModifyOutputPortRoleAssignmentBody = ModifyOutputPortRoleAssignment

type CreateOutputPortRoleAssignmentBody = CreateOutputPortRoleAssignment

type RequestOutputPortRoleAssignmentBody = RequestOutputPortRoleAssignment

type DecideOutputPortRoleAssignmentBody = DecideOutputPortRoleAssignment

type UpdateThemeSettingsBody = ThemeSettings

type ValidateResourceNameBody = ResourceNameValidationRequest

type CheckAccessQuery struct {
	Resource *uuid.UUID `json:"resource,omitempty"`
	Domain   *uuid.UUID `json:"domain,omitempty"`
}

func (c CheckAccessQuery) Validate() error {
	var errors runtime.ValidationErrors
	if c.Resource != nil {
		if v, ok := any(c.Resource).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Resource", err)
			}
		}
	}
	if c.Domain != nil {
		if v, ok := any(c.Domain).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Domain", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchOutputPortsQuery struct {
	Query string `json:"query" validate:"required,min=3"`
	Limit *int   `json:"limit,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchOutputPortsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetOutputPortQueryStatsQuery struct {
	Granularity *QueryStatsGranularity `json:"granularity,omitempty"`
	DayRange    *int                   `json:"day_range,omitempty" validate:"omitempty,gte=1"`
}

func (g GetOutputPortQueryStatsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if g.Granularity != nil {
		if v, ok := any(g.Granularity).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Granularity", err)
			}
		}
	}
	if g.DayRange != nil {
		if err := typesValidator.Var(g.DayRange, "omitempty,gte=1"); err != nil {
			errors = errors.Append("DayRange", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortGraphDataQuery struct {
	Level *int `json:"level,omitempty"`
}

type SetValueForOutputPortQuery struct {
	Value string `json:"value" validate:"required"`
}

func (s SetValueForOutputPortQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetDataProductsQuery struct {
	FilterToUserWithAssigment *uuid.UUID `json:"filter_to_user_with_assigment,omitempty"`
}

func (g GetDataProductsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if g.FilterToUserWithAssigment != nil {
		if v, ok := any(g.FilterToUserWithAssigment).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("FilterToUserWithAssigment", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductGraphDataQuery struct {
	Level *int `json:"level,omitempty"`
}

type SetValueForDataProductQuery struct {
	Value string `json:"value" validate:"required"`
}

func (s SetValueForDataProductQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetSigninURLQuery struct {
	Environment string `json:"environment" validate:"required"`
}

func (g GetSigninURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetDatabricksWorkspaceURLQuery struct {
	Environment string `json:"environment" validate:"required"`
}

func (g GetDatabricksWorkspaceURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetSnowflakeURLQuery struct {
	Environment string `json:"environment" validate:"required"`
}

func (g GetSnowflakeURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetTechnicalAssetGraphDataQuery struct {
	Level *int `json:"level,omitempty"`
}

type ListGlobalRoleAssignmentsQuery struct {
	UserID *uuid.UUID `json:"user_id,omitempty"`
	RoleID *uuid.UUID `json:"role_id,omitempty"`
}

func (l ListGlobalRoleAssignmentsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if l.UserID != nil {
		if v, ok := any(l.UserID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("UserID", err)
			}
		}
	}
	if l.RoleID != nil {
		if v, ok := any(l.RoleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RoleID", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ListDataProductRoleAssignmentsQuery struct {
	DataProductID *uuid.UUID      `json:"data_product_id,omitempty"`
	UserID        *uuid.UUID      `json:"user_id,omitempty"`
	RoleID        *uuid.UUID      `json:"role_id,omitempty"`
	Decision      *DecisionStatus `json:"decision,omitempty"`
}

func (l ListDataProductRoleAssignmentsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if l.DataProductID != nil {
		if v, ok := any(l.DataProductID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataProductID", err)
			}
		}
	}
	if l.UserID != nil {
		if v, ok := any(l.UserID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("UserID", err)
			}
		}
	}
	if l.RoleID != nil {
		if v, ok := any(l.RoleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RoleID", err)
			}
		}
	}
	if l.Decision != nil {
		if v, ok := any(l.Decision).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Decision", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ListOutputPortRoleAssignmentsQuery struct {
	OutputPortID *uuid.UUID      `json:"output_port_id,omitempty"`
	UserID       *uuid.UUID      `json:"user_id,omitempty"`
	RoleID       *uuid.UUID      `json:"role_id,omitempty"`
	Decision     *DecisionStatus `json:"decision,omitempty"`
}

func (l ListOutputPortRoleAssignmentsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if l.OutputPortID != nil {
		if v, ok := any(l.OutputPortID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("OutputPortID", err)
			}
		}
	}
	if l.UserID != nil {
		if v, ok := any(l.UserID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("UserID", err)
			}
		}
	}
	if l.RoleID != nil {
		if v, ok := any(l.RoleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RoleID", err)
			}
		}
	}
	if l.Decision != nil {
		if v, ok := any(l.Decision).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Decision", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetGraphDataQuery struct {
	DomainNodesEnabled      *bool `json:"domain_nodes_enabled,omitempty"`
	DataProductNodesEnabled *bool `json:"data_product_nodes_enabled,omitempty"`
	DatasetNodesEnabled     *bool `json:"dataset_nodes_enabled,omitempty"`
}

type SanitizeResourceNameQuery struct {
	Name string `json:"name" validate:"required"`
}

func (s SanitizeResourceNameQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetDeviceTokenQuery struct {
	ClientID string  `json:"client_id" validate:"required"`
	Scope    *string `json:"scope,omitempty"`
}

func (g GetDeviceTokenQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetJwtTokenQuery struct {
	ClientID   string `json:"client_id" validate:"required"`
	DeviceCode string `json:"device_code" validate:"required"`
	GrantType  string `json:"grant_type" validate:"required"`
}

func (g GetJwtTokenQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetAwsCredentialsQuery struct {
	DataProductName string `json:"data_product_name" validate:"required"`
	Environment     string `json:"environment" validate:"required"`
}

func (g GetAwsCredentialsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type CheckAccessResponse = AccessResponse

type CheckAccessErrorResponse = HTTPValidationError

type IsAdminResponseJSON = IsAdminResponse

type SearchOutputPortsResponseJSON = SearchOutputPortsResponse

type SearchOutputPortsErrorResponse = HTTPValidationError

type GetOutputPortQueryStatsResponse = OutputPortQueryStatsResponses

type GetOutputPortQueryStatsErrorResponse = HTTPValidationError

type UpdateOutputPortQueryStatsResponse struct{}

type UpdateOutputPortQueryStatsErrorResponse = HTTPValidationError

type DeleteOutputPortQueryStatResponse struct{}

type DeleteOutputPortQueryStatErrorResponse = HTTPValidationError

type GetOutputPortCuratedQueriesResponse = OutputPortCuratedQueries

type GetOutputPortCuratedQueriesErrorResponse = HTTPValidationError

type ReplaceOutputPortCuratedQueriesResponse = OutputPortCuratedQueries

type ReplaceOutputPortCuratedQueriesErrorResponse = HTTPValidationError

type GetDataProductOutputPortsResponseJSON = GetDataProductOutputPortsResponse

type GetDataProductOutputPortsErrorResponse = HTTPValidationError

type CreateOutputPortResponseJSON = CreateOutputPortResponse

type CreateOutputPortErrorResponse = HTTPValidationError

type GetOutputPortResponseJSON = GetOutputPortResponse

type GetOutputPortErrorResponse = HTTPValidationError

type RemoveDatasetResponse struct{}

type RemoveDatasetErrorResponse = HTTPValidationError

type UpdateOutputPortResponseJSON = UpdateOutputPortResponse

type UpdateOutputPortErrorResponse = HTTPValidationError

type GetOutputPortsEventHistoryResponse = GetEventHistoryResponse

type GetOutputPortsEventHistoryErrorResponse = HTTPValidationError

type UpdateOutputPortAboutResponse struct{}

type UpdateOutputPortAboutErrorResponse = HTTPValidationError

type UpdateOutputPortStatusResponse struct{}

type UpdateOutputPortStatusErrorResponse = HTTPValidationError

type GetOutputPortGraphDataResponse = Graph

type GetOutputPortGraphDataErrorResponse = HTTPValidationError

type SetValueForOutputPortResponse struct{}

type SetValueForOutputPortErrorResponse = HTTPValidationError

type CreateDataProductResponseJSON = CreateDataProductResponse

type CreateDataProductErrorResponse = HTTPValidationError

type GetDataProductsResponseJSON = GetDataProductsResponse

type GetDataProductsErrorResponse = HTTPValidationError

type RemoveDataProductResponse struct{}

type RemoveDataProductErrorResponse = HTTPValidationError

type UpdateDataProductResponseJSON = UpdateDataProductResponse

type UpdateDataProductErrorResponse = HTTPValidationError

type GetDataProductResponseJSON = GetDataProductResponse

type GetDataProductErrorResponse = HTTPValidationError

type UpdateDataProductAboutResponse struct{}

type UpdateDataProductAboutErrorResponse = HTTPValidationError

type UpdateDataProductStatusResponse struct{}

type UpdateDataProductStatusErrorResponse = HTTPValidationError

type UpdateDataProductUsageResponse struct{}

type UpdateDataProductUsageErrorResponse = HTTPValidationError

type GetDataProductGraphDataResponse = Graph

type GetDataProductGraphDataErrorResponse = HTTPValidationError

type SetValueForDataProductResponse struct{}

type SetValueForDataProductErrorResponse = HTTPValidationError

type LinkInputPortsToDataProductResponse = LinkInputPortsToDataProductPost

type LinkInputPortsToDataProductErrorResponse = HTTPValidationError

type GetDataProductEventHistoryResponse = GetEventHistoryResponse

type GetDataProductEventHistoryErrorResponse = HTTPValidationError

type CreateTechnicalAssetResponseJSON = CreateTechnicalAssetResponse

type CreateTechnicalAssetErrorResponse = HTTPValidationError

type GetSigninURLResponseJSON = GetSigninURLResponse

type GetSigninURLErrorResponse = HTTPValidationError

type GetConveyorIdeURLResponseJSON = GetConveyorIdeURLResponse

type GetConveyorIdeURLErrorResponse = HTTPValidationError

type GetDatabricksWorkspaceURLResponseJSON = GetDatabricksWorkspaceURLResponse

type GetDatabricksWorkspaceURLErrorResponse = HTTPValidationError

type GetSnowflakeURLResponseJSON = GetSnowflakeURLResponse

type GetSnowflakeURLErrorResponse = HTTPValidationError

type GetTechnicalAssetsResponseJSON = GetTechnicalAssetsResponse

type GetTechnicalAssetsErrorResponse = HTTPValidationError

type GetDataProductInputPortsResponseJSON = GetDataProductInputPortsResponse

type GetDataProductInputPortsErrorResponse = HTTPValidationError

type GetDataProductRolledUpTagsResponseJSON = GetDataProductRolledUpTagsResponse

type GetDataProductRolledUpTagsErrorResponse = HTTPValidationError

type UnlinkInputPortFromDataProductResponse struct{}

type UnlinkInputPortFromDataProductErrorResponse = HTTPValidationError

type GetDataProductTypeResponse = DataProductTypeGet

type GetDataProductTypeErrorResponse = HTTPValidationError

type UpdateDataProductTypeResponseJSON = UpdateDataProductTypeResponse

type UpdateDataProductTypeErrorResponse = HTTPValidationError

type RemoveDataProductTypeResponse struct{}

type RemoveDataProductTypeErrorResponse = HTTPValidationError

type GetDataProductsTypesResponse = DataProductTypesGet

type CreateDataProductTypeResponseJSON = CreateDataProductTypeResponse

type CreateDataProductTypeErrorResponse = HTTPValidationError

type MigrateDataProductTypeResponse struct{}

type MigrateDataProductTypeErrorResponse = HTTPValidationError

type GetDataProductsLifecyclesResponse = DataProductLifeCyclesGet

type CreateDataProductLifecycleResponse = CreateDataProductLifeCycleResponse

type CreateDataProductLifecycleErrorResponse = HTTPValidationError

type UpdateDataProductLifecycleResponse = UpdateDataProductLifeCycleResponse

type UpdateDataProductLifecycleErrorResponse = HTTPValidationError

type RemoveDataProductLifecycleResponse struct{}

type RemoveDataProductLifecycleErrorResponse = HTTPValidationError

type GetDataProductsSettingsResponse = DataProductSettingsGet

type CreateDataProductSettingResponseJSON = CreateDataProductSettingResponse

type CreateDataProductSettingErrorResponse = HTTPValidationError

type UpdateDataProductSettingResponseJSON = UpdateDataProductSettingResponse

type UpdateDataProductSettingErrorResponse = HTTPValidationError

type RemoveDataProductSettingResponse struct{}

type RemoveDataProductSettingErrorResponse = HTTPValidationError

type ApproveOutputPortAsInputPortResponse struct{}

type ApproveOutputPortAsInputPortErrorResponse = HTTPValidationError

type DenyOutputPortAsInputPortResponse struct{}

type DenyOutputPortAsInputPortErrorResponse = HTTPValidationError

type RemoveOutputPortAsInputPortResponse struct{}

type RemoveOutputPortAsInputPortErrorResponse = HTTPValidationError

type ApproveOutputPortTechnicalAssetLinkResponse struct{}

type ApproveOutputPortTechnicalAssetLinkErrorResponse = HTTPValidationError

type DenyOutputPortTechnicalAssetLinkResponse struct{}

type DenyOutputPortTechnicalAssetLinkErrorResponse = HTTPValidationError

type LinkOutputPortToTechnicalAssetResponse = LinkTechnicalAssetsToOutputPortResponse

type LinkOutputPortToTechnicalAssetErrorResponse = HTTPValidationError

type UnlinkOutputPortFromTechnicalAssetResponse struct{}

type UnlinkOutputPortFromTechnicalAssetErrorResponse = HTTPValidationError

type GetTechnicalAssetResponse = GetTechnicalAssetsResponseItem

type GetTechnicalAssetErrorResponse = HTTPValidationError

type RemoveTechnicalAssetResponse struct{}

type RemoveTechnicalAssetErrorResponse = HTTPValidationError

type GetTechnicalAssetEventHistoryResponse = GetEventHistoryResponse

type GetTechnicalAssetEventHistoryErrorResponse = HTTPValidationError

type UpdateTechnicalAssetStatusResponse struct{}

type UpdateTechnicalAssetStatusErrorResponse = HTTPValidationError

type GetTechnicalAssetGraphDataResponse = Graph

type GetTechnicalAssetGraphDataErrorResponse = HTTPValidationError

type GetDomainsResponseJSON = GetDomainsResponse

type CreateDomainResponseJSON = CreateDomainResponse

type CreateDomainErrorResponse = HTTPValidationError

type UpdateDomainResponseJSON = UpdateDomainResponse

type UpdateDomainErrorResponse = HTTPValidationError

type RemoveDomainResponse struct{}

type RemoveDomainErrorResponse = HTTPValidationError

type GetDomainResponseJSON = GetDomainResponse

type GetDomainErrorResponse = HTTPValidationError

type MigrateDomainResponse struct{}

type MigrateDomainErrorResponse = HTTPValidationError

type GetEnvironmentResponse = Environment

type GetEnvironmentErrorResponse = HTTPValidationError

type GetEnvironmentConfigsByIDResponse = EnvironmentConfigsGetItem

type GetEnvironmentConfigsByIDErrorResponse = HTTPValidationError

type GetEnvironmentPlatformServiceConfigResponse = EnvironmentConfigsGetItem

type GetEnvironmentPlatformServiceConfigErrorResponse = HTTPValidationError

type GetEnvironmentPlatformConfigResponse = EnvironmentPlatformConfigGet

type GetEnvironmentPlatformConfigErrorResponse = HTTPValidationError

type GetEnvironmentsResponse = EnvironmentsGet

type GetEnvironmentConfigsResponse = EnvironmentConfigsGet

type GetEnvironmentConfigsErrorResponse = HTTPValidationError

type GetEnvironmentPlatformServiceConfigForAllEnvsResponse = EnvironmentConfigsGet

type GetEnvironmentPlatformServiceConfigForAllEnvsErrorResponse = HTTPValidationError

type GetPlatformServiceConfigResponse = PlatformServiceConfiguration

type GetPlatformServiceConfigErrorResponse = HTTPValidationError

type GetSinglePlatformServiceConfigurationResponse = PlatformServiceConfiguration

type GetSinglePlatformServiceConfigurationErrorResponse = HTTPValidationError

type GetAllPlatformServiceConfigurationsResponseJSON = GetAllPlatformServiceConfigurationsResponse

type GetAllPlatformsResponseJSON = GetAllPlatformsResponse

type GetPlatformServicesResponseJSON = GetPlatformServicesResponse

type GetPlatformServicesErrorResponse = HTTPValidationError

type GetTagsResponse = TagsGet

type CreateTagResponseJSON = CreateTagResponse

type CreateTagErrorResponse = HTTPValidationError

type UpdateTagResponseJSON = UpdateTagResponse

type UpdateTagErrorResponse = HTTPValidationError

type RemoveTagResponse struct{}

type RemoveTagErrorResponse = HTTPValidationError

type RemoveUserResponse struct{}

type RemoveUserErrorResponse = HTTPValidationError

type GetUsersResponseJSON = GetUsersResponse

type CreateUserResponse = UserCreateResponse

type CreateUserErrorResponse = HTTPValidationError

type SetCanBecomeAdminResponse struct{}

type SetCanBecomeAdminErrorResponse = HTTPValidationError

type MarkTourAsSeenResponse struct{}

type GetUserPendingActionsResponse = PendingActionResponse

type GetCurrentUserResponse = User

type CreateRoleResponse = Role

type CreateRoleErrorResponse = HTTPValidationError

type RemoveRoleResponse struct{}

type RemoveRoleErrorResponse = HTTPValidationError

type UpdateRoleResponse = Role

type UpdateRoleErrorResponse = HTTPValidationError

type GetRolesResponseJSON = GetRolesResponse

type GetRolesErrorResponse = HTTPValidationError

type BecomeAdminResponse struct{}

type BecomeAdminErrorResponse = HTTPValidationError

type RevokeAdminResponse struct{}

type CreateGlobalRoleAssignmentResponse = GlobalRoleAssignmentResponse

type CreateGlobalRoleAssignmentErrorResponse = HTTPValidationError

type ListGlobalRoleAssignmentsResponse = AppAuthorizationRoleAssignmentsGlobalSchemaListRoleAssignmentsResponse

type ListGlobalRoleAssignmentsErrorResponse = HTTPValidationError

type DeleteGlobalRoleAssignmentResponseJSON = DeleteGlobalRoleAssignmentResponse

type DeleteGlobalRoleAssignmentErrorResponse = HTTPValidationError

type DecideGlobalRoleAssignmentResponse = GlobalRoleAssignmentResponse

type DecideGlobalRoleAssignmentErrorResponse = HTTPValidationError

type ModifyGlobalRoleAssignmentResponse = GlobalRoleAssignmentResponse

type ModifyGlobalRoleAssignmentErrorResponse = HTTPValidationError

type DeleteDataProductRoleAssignmentResponseJSON = DeleteDataProductRoleAssignmentResponse

type DeleteDataProductRoleAssignmentErrorResponse = HTTPValidationError

type ModifyDataProductRoleAssignmentResponse = DataProductRoleAssignmentResponse

type ModifyDataProductRoleAssignmentErrorResponse = HTTPValidationError

type ListDataProductRoleAssignmentsResponse = AppAuthorizationRoleAssignmentsDataProductSchemaListRoleAssignmentsResponse

type ListDataProductRoleAssignmentsErrorResponse = HTTPValidationError

type CreateDataProductRoleAssignmentResponse = DataProductRoleAssignmentResponse

type CreateDataProductRoleAssignmentErrorResponse = HTTPValidationError

type RequestDataProductRoleAssignmentResponse = DataProductRoleAssignmentResponse

type RequestDataProductRoleAssignmentErrorResponse = HTTPValidationError

type DecideDataProductRoleAssignmentResponse = DataProductRoleAssignmentResponse

type DecideDataProductRoleAssignmentErrorResponse = HTTPValidationError

type DeleteOutputPortRoleAssignmentResponseJSON = DeleteOutputPortRoleAssignmentResponse

type DeleteOutputPortRoleAssignmentErrorResponse = HTTPValidationError

type ModifyOutputPortRoleAssignmentResponse = OutputPortRoleAssignmentResponse

type ModifyOutputPortRoleAssignmentErrorResponse = HTTPValidationError

type ListOutputPortRoleAssignmentsResponse = AppAuthorizationRoleAssignmentsOutputPortSchemaListRoleAssignmentsResponse

type ListOutputPortRoleAssignmentsErrorResponse = HTTPValidationError

type CreateOutputPortRoleAssignmentResponse = OutputPortRoleAssignmentResponse

type CreateOutputPortRoleAssignmentErrorResponse = HTTPValidationError

type RequestOutputPortRoleAssignmentResponse = OutputPortRoleAssignmentResponse

type RequestOutputPortRoleAssignmentErrorResponse = HTTPValidationError

type DecideOutputPortRoleAssignmentResponse = OutputPortRoleAssignmentResponse

type DecideOutputPortRoleAssignmentErrorResponse = HTTPValidationError

type GetThemeSettingsResponse = ThemeSettings

type UpdateThemeSettingsResponse struct{}

type UpdateThemeSettingsErrorResponse = HTTPValidationError

type GetGraphDataResponse = Graph

type GetGraphDataErrorResponse = HTTPValidationError

type RemoveAllUserNotificationsResponse struct{}

type RemoveUserNotificationResponse struct{}

type RemoveUserNotificationErrorResponse = HTTPValidationError

type GetUserNotificationsResponseJSON = GetUserNotificationsResponse

type SanitizeResourceNameResponse = ResourceNameSuggestion

type SanitizeResourceNameErrorResponse = HTTPValidationError

type ValidateResourceNameResponse = ResourceNameValidation

type ValidateResourceNameErrorResponse = HTTPValidationError

type ResourceNameConstraintsResponse = ResourceNameLengthLimits

// GetPlatformTilesResponse Response model for platform tiles
type GetPlatformTilesResponse = PlatformTileResponse

// GetPluginsResponse Response model for listing available plugins
type GetPluginsResponse = PluginResponse

type GetPluginFormResponse = UIElementMetadataResponse

type GetPluginFormErrorResponse = HTTPValidationError

type GetDeviceTokenResponse struct{}

type GetDeviceTokenErrorResponse = HTTPValidationError

type GetJwtTokenResponse struct{}

type GetJwtTokenErrorResponse = HTTPValidationError

type GetAwsCredentialsResponse = AWSCredentials

type GetAwsCredentialsErrorResponse = HTTPValidationError

type GetVersionResponse struct{}

type AWSCredentials struct {
	AccessKeyID     string    `json:"AccessKeyId" validate:"required"`
	SecretAccessKey string    `json:"SecretAccessKey" validate:"required"`
	SessionToken    string    `json:"SessionToken" validate:"required"`
	Expiration      time.Time `json:"Expiration" validate:"required"`
}

func (a AWSCredentials) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AWSEnvironmentPlatformConfiguration struct {
	AccountID   string   `json:"account_id" validate:"required"`
	Region      string   `json:"region" validate:"required"`
	CanReadFrom []string `json:"can_read_from" validate:"required"`
}

func (a AWSEnvironmentPlatformConfiguration) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AWSGlueConfig struct {
	Identifier       string `json:"identifier" validate:"required"`
	DatabaseName     string `json:"database_name" validate:"required"`
	BucketIdentifier string `json:"bucket_identifier" validate:"required"`
	S3Path           string `json:"s3_path" validate:"required"`
}

func (a AWSGlueConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AWSS3Config struct {
	Identifier string `json:"identifier" validate:"required"`
	BucketName string `json:"bucket_name" validate:"required"`
	BucketArn  string `json:"bucket_arn" validate:"required"`
	KmsKeyArn  string `json:"kms_key_arn" validate:"required"`
	IsDefault  bool   `json:"is_default"`
}

func (a AWSS3Config) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AccessResponse struct {
	Allowed bool `json:"allowed"`
}

type ApproveLinkBetweenTechnicalAssetAndOutputPortRequest struct {
	TechnicalAssetID uuid.UUID `json:"technical_asset_id" validate:"required"`
}

func (a ApproveLinkBetweenTechnicalAssetAndOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ApproveOutputPortAsInputPortRequest struct {
	ConsumingDataProductID uuid.UUID `json:"consuming_data_product_id" validate:"required"`
}

func (a ApproveOutputPortAsInputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ConsumingDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumingDataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type BecomeAdmin struct {
	Expiry string `json:"expiry" validate:"required"`
}

func (b BecomeAdmin) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(b))
}

type CanBecomeAdminUpdate struct {
	UserID         string `json:"user_id" validate:"required"`
	CanBecomeAdmin bool   `json:"can_become_admin"`
}

func (c CanBecomeAdminUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type CreateDataProductLifeCycleResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductLifeCycleResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductRoleAssignment struct {
	UserID        uuid.UUID `json:"user_id" validate:"required"`
	RoleID        uuid.UUID `json:"role_id" validate:"required"`
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (c CreateDataProductRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(c.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(c.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductSettingResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductSettingResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductTypeResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductTypeResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDomainResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDomainResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateGlobalRoleAssignment struct {
	UserID uuid.UUID                         `json:"user_id" validate:"required"`
	RoleID CreateGlobalRoleAssignment_RoleID `json:"role_id"`
}

func (c CreateGlobalRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(c.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateGlobalRoleAssignment_RoleID struct {
	CreateGlobalRoleAssignment_RoleID_AnyOf *CreateGlobalRoleAssignment_RoleID_AnyOf `json:"-"`
}

func (c CreateGlobalRoleAssignment_RoleID) Validate() error {
	var errors runtime.ValidationErrors
	if c.CreateGlobalRoleAssignment_RoleID_AnyOf != nil {
		if v, ok := any(c.CreateGlobalRoleAssignment_RoleID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("CreateGlobalRoleAssignment_RoleID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (c CreateGlobalRoleAssignment_RoleID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(c.CreateGlobalRoleAssignment_RoleID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("CreateGlobalRoleAssignment_RoleID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (c *CreateGlobalRoleAssignment_RoleID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if c.CreateGlobalRoleAssignment_RoleID_AnyOf == nil {
		c.CreateGlobalRoleAssignment_RoleID_AnyOf = &CreateGlobalRoleAssignment_RoleID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, c.CreateGlobalRoleAssignment_RoleID_AnyOf); err != nil {
		return fmt.Errorf("CreateGlobalRoleAssignment_RoleID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type CreateOutputPortRequest struct {
	Name        string               `json:"name" validate:"required"`
	Namespace   string               `json:"namespace" validate:"required"`
	Description string               `json:"description" validate:"required"`
	AccessType  OutputPortAccessType `json:"access_type" validate:"required"`
	About       *string              `json:"about,omitempty"`
	LifecycleID *uuid.UUID           `json:"lifecycle_id,omitempty"`
	TagIds      []uuid.UUID          `json:"tag_ids" validate:"required"`
	Owners      []uuid.UUID          `json:"owners" validate:"required"`
}

func (c CreateOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(c.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(c.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(c.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if c.LifecycleID != nil {
		if v, ok := any(c.LifecycleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LifecycleID", err)
			}
		}
	}
	for i, item := range c.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	for i, item := range c.Owners {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Owners[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateOutputPortResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateOutputPortRoleAssignment struct {
	UserID       uuid.UUID `json:"user_id" validate:"required"`
	RoleID       uuid.UUID `json:"role_id" validate:"required"`
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
}

func (c CreateOutputPortRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(c.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(c.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateRole struct {
	Name        string                `json:"name" validate:"required"`
	Scope       Scope                 `json:"scope" validate:"required"`
	Description string                `json:"description" validate:"required"`
	Permissions []AuthorizationAction `json:"permissions" validate:"required"`
}

func (c CreateRole) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(c.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if err := typesValidator.Var(c.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	for i, item := range c.Permissions {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Permissions[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTagResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateTagResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTechnicalAssetRequest struct {
	Name          string                                    `json:"name" validate:"required"`
	Description   string                                    `json:"description" validate:"required"`
	Namespace     string                                    `json:"namespace" validate:"required"`
	PlatformID    uuid.UUID                                 `json:"platform_id" validate:"required"`
	ServiceID     uuid.UUID                                 `json:"service_id" validate:"required"`
	Status        TechnicalAssetStatus                      `json:"status" validate:"required"`
	Configuration CreateTechnicalAssetRequest_Configuration `json:"configuration"`

	// SourceAligned DEPRECATED: Use 'technical_mapping' instead. This field will be removed in a future version.
	// Deprecated:
	SourceAligned    *bool             `json:"sourceAligned,omitempty"`
	TechnicalMapping *TechnicalMapping `json:"technical_mapping,omitempty"`
	TagIds           []uuid.UUID       `json:"tag_ids" validate:"required"`
}

func (c CreateTechnicalAssetRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(c.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(c.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(c.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(c.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if v, ok := any(c.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(c.Configuration).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Configuration", err)
		}
	}
	if c.TechnicalMapping != nil {
		if v, ok := any(c.TechnicalMapping).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TechnicalMapping", err)
			}
		}
	}
	for i, item := range c.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTechnicalAssetRequest_Configuration struct {
	CreateTechnicalAssetRequest_Configuration_OneOf *CreateTechnicalAssetRequest_Configuration_OneOf `json:"-"`
}

func (c CreateTechnicalAssetRequest_Configuration) Validate() error {
	var errors runtime.ValidationErrors
	if c.CreateTechnicalAssetRequest_Configuration_OneOf != nil {
		if v, ok := any(c.CreateTechnicalAssetRequest_Configuration_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("CreateTechnicalAssetRequest_Configuration_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (c CreateTechnicalAssetRequest_Configuration) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(c.CreateTechnicalAssetRequest_Configuration_OneOf)
		if err != nil {
			return nil, fmt.Errorf("CreateTechnicalAssetRequest_Configuration_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (c *CreateTechnicalAssetRequest_Configuration) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if c.CreateTechnicalAssetRequest_Configuration_OneOf == nil {
		c.CreateTechnicalAssetRequest_Configuration_OneOf = &CreateTechnicalAssetRequest_Configuration_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, c.CreateTechnicalAssetRequest_Configuration_OneOf); err != nil {
		return fmt.Errorf("CreateTechnicalAssetRequest_Configuration_OneOf unmarshal: %w", err)
	}

	return nil
}

type CreateTechnicalAssetResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateTechnicalAssetResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataOutputStatusUpdate struct {
	Status TechnicalAssetStatus `json:"status" validate:"required"`
}

func (d DataOutputStatusUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProduct struct {
	ID          uuid.UUID         `json:"id" validate:"required"`
	Name        string            `json:"name" validate:"required"`
	Namespace   string            `json:"namespace" validate:"required"`
	Description string            `json:"description" validate:"required"`
	Status      DataProductStatus `json:"status" validate:"required"`
	Type        DataProductType   `json:"type"`
}

func (d DataProduct) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductAboutUpdate struct {
	About string `json:"about" validate:"required"`
}

func (d DataProductAboutUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DataProductCreate struct {
	Name        string      `json:"name" validate:"required"`
	Namespace   string      `json:"namespace" validate:"required"`
	Description string      `json:"description" validate:"required"`
	TypeID      uuid.UUID   `json:"type_id" validate:"required"`
	About       *string     `json:"about,omitempty"`
	DomainID    uuid.UUID   `json:"domain_id" validate:"required"`
	TagIds      []uuid.UUID `json:"tag_ids" validate:"required"`
	LifecycleID uuid.UUID   `json:"lifecycle_id" validate:"required"`
	Owners      []uuid.UUID `json:"owners" validate:"required"`
}

func (d DataProductCreate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.TypeID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TypeID", err)
		}
	}
	if v, ok := any(d.DomainID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DomainID", err)
		}
	}
	for i, item := range d.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if v, ok := any(d.LifecycleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("LifecycleID", err)
		}
	}
	for i, item := range d.Owners {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Owners[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductLifeCycle struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Value     int       `json:"value" validate:"required"`
	Color     string    `json:"color" validate:"required"`
	IsDefault bool      `json:"is_default"`
}

func (d DataProductLifeCycle) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(d.Color, "required"); err != nil {
		errors = errors.Append("Color", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductLifeCycleCreate struct {
	Value     int    `json:"value" validate:"required"`
	Name      string `json:"name" validate:"required"`
	Color     string `json:"color" validate:"required"`
	IsDefault *bool  `json:"is_default,omitempty"`
}

func (d DataProductLifeCycleCreate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DataProductLifeCycleUpdate struct {
	Value     int    `json:"value" validate:"required"`
	Name      string `json:"name" validate:"required"`
	Color     string `json:"color" validate:"required"`
	IsDefault *bool  `json:"is_default,omitempty"`
}

func (d DataProductLifeCycleUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DataProductLifeCyclesGet struct {
	DataProductLifeCycles []DataProductLifeCyclesGetItem `json:"data_product_life_cycles" validate:"required"`
}

func (d DataProductLifeCyclesGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.DataProductLifeCycles {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductLifeCycles[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductLifeCyclesGetItem struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Value     int       `json:"value" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Color     string    `json:"color" validate:"required"`
	IsDefault bool      `json:"is_default"`
}

func (d DataProductLifeCyclesGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Color, "required"); err != nil {
		errors = errors.Append("Color", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductOutputPortPendingAction struct {
	ID                uuid.UUID      `json:"id" validate:"required"`
	Justification     string         `json:"justification" validate:"required"`
	DataProductID     uuid.UUID      `json:"data_product_id" validate:"required"`
	OutputPortID      uuid.UUID      `json:"output_port_id" validate:"required"`
	Status            DecisionStatus `json:"status" validate:"required"`
	RequestedOn       time.Time      `json:"requested_on" validate:"required"`
	OutputPort        OutputPort     `json:"output_port"`
	DataProduct       DataProduct    `json:"data_product"`
	RequestedBy       User           `json:"requested_by"`
	DeniedBy          User           `json:"denied_by"`
	ApprovedBy        User           `json:"approved_by"`
	PendingActionType *string        `json:"pending_action_type,omitempty"`
}

func (d DataProductOutputPortPendingAction) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Justification, "required"); err != nil {
		errors = errors.Append("Justification", err)
	}
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(d.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if err := typesValidator.Var(d.RequestedOn, "required"); err != nil {
		errors = errors.Append("RequestedOn", err)
	}
	if v, ok := any(d.OutputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPort", err)
		}
	}
	if v, ok := any(d.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(d.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(d.DeniedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DeniedBy", err)
		}
	}
	if v, ok := any(d.ApprovedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ApprovedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductRoleAssignmentPendingAction struct {
	ID                uuid.UUID      `json:"id" validate:"required"`
	DataProduct       DataProduct    `json:"data_product"`
	User              User           `json:"user"`
	Role              Role           `json:"role"`
	Decision          DecisionStatus `json:"decision" validate:"required"`
	RequestedOn       time.Time      `json:"requested_on"`
	RequestedBy       User           `json:"requested_by"`
	DecidedOn         time.Time      `json:"decided_on"`
	DecidedBy         User           `json:"decided_by"`
	PendingActionType *string        `json:"pending_action_type,omitempty"`
}

func (d DataProductRoleAssignmentPendingAction) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(d.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(d.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(d.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(d.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductRoleAssignmentResponse struct {
	ID          uuid.UUID      `json:"id" validate:"required"`
	DataProduct DataProduct    `json:"data_product"`
	User        User           `json:"user"`
	Role        Role           `json:"role"`
	Decision    DecisionStatus `json:"decision" validate:"required"`
	RequestedOn time.Time      `json:"requested_on"`
	RequestedBy User           `json:"requested_by"`
	DecidedOn   time.Time      `json:"decided_on"`
	DecidedBy   User           `json:"decided_by"`
}

func (d DataProductRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(d.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(d.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(d.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(d.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSetting struct {
	ID        uuid.UUID               `json:"id" validate:"required"`
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSetting) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingCreate struct {
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSettingCreate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingUpdate struct {
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSettingUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingValue struct {
	ID                   uuid.UUID          `json:"id" validate:"required"`
	DataProductSettingID uuid.UUID          `json:"data_product_setting_id" validate:"required"`
	Value                string             `json:"value" validate:"required"`
	DataProductSetting   DataProductSetting `json:"data_product_setting"`
	DataProductID        uuid.UUID          `json:"data_product_id" validate:"required"`
}

func (d DataProductSettingValue) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.DataProductSettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSettingID", err)
		}
	}
	if err := typesValidator.Var(d.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if v, ok := any(d.DataProductSetting).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSetting", err)
		}
	}
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingsGet struct {
	DataProductSettings []DataProductSettingsGetItem `json:"data_product_settings" validate:"required"`
}

func (d DataProductSettingsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingsGetItem struct {
	ID        uuid.UUID               `json:"id" validate:"required"`
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSettingsGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductStatusUpdate struct {
	Status DataProductStatus `json:"status" validate:"required"`
}

func (d DataProductStatusUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductType struct {
	ID          uuid.UUID          `json:"id" validate:"required"`
	Name        string             `json:"name" validate:"required"`
	Description string             `json:"description" validate:"required"`
	IconKey     DataProductIconKey `json:"icon_key" validate:"required"`
}

func (d DataProductType) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypeCreate struct {
	Name        string             `json:"name" validate:"required"`
	Description string             `json:"description" validate:"required"`
	IconKey     DataProductIconKey `json:"icon_key" validate:"required"`
}

func (d DataProductTypeCreate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypeGet struct {
	ID           uuid.UUID          `json:"id" validate:"required"`
	Name         string             `json:"name" validate:"required"`
	Description  string             `json:"description" validate:"required"`
	IconKey      DataProductIconKey `json:"icon_key" validate:"required"`
	DataProducts []DataProduct      `json:"data_products" validate:"required"`
}

func (d DataProductTypeGet) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	for i, item := range d.DataProducts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProducts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypeUpdate struct {
	Name        string             `json:"name" validate:"required"`
	Description string             `json:"description" validate:"required"`
	IconKey     DataProductIconKey `json:"icon_key" validate:"required"`
}

func (d DataProductTypeUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypesGet struct {
	DataProductTypes []DataProductTypesGetItem `json:"data_product_types" validate:"required"`
}

func (d DataProductTypesGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.DataProductTypes {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductTypes[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypesGetItem struct {
	ID               uuid.UUID          `json:"id" validate:"required"`
	Name             string             `json:"name" validate:"required"`
	Description      string             `json:"description" validate:"required"`
	IconKey          DataProductIconKey `json:"icon_key" validate:"required"`
	DataProductCount int                `json:"data_product_count" validate:"required"`
}

func (d DataProductTypesGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if err := typesValidator.Var(d.DataProductCount, "required"); err != nil {
		errors = errors.Append("DataProductCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductUpdate struct {
	Name        string      `json:"name" validate:"required"`
	Namespace   string      `json:"namespace" validate:"required"`
	Description string      `json:"description" validate:"required"`
	TypeID      uuid.UUID   `json:"type_id" validate:"required"`
	About       *string     `json:"about,omitempty"`
	DomainID    uuid.UUID   `json:"domain_id" validate:"required"`
	TagIds      []uuid.UUID `json:"tag_ids" validate:"required"`
	LifecycleID uuid.UUID   `json:"lifecycle_id" validate:"required"`
}

func (d DataProductUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.TypeID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TypeID", err)
		}
	}
	if v, ok := any(d.DomainID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DomainID", err)
		}
	}
	for i, item := range d.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if v, ok := any(d.LifecycleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("LifecycleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductUsageUpdate struct {
	Usage string `json:"usage" validate:"required"`
}

func (d DataProductUsageUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatabricksConfig struct {
	Identifier string `json:"identifier" validate:"required"`
}

func (d DatabricksConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatabricksDataOutput struct {
	ConfigurationType string            `json:"configuration_type" validate:"required"`
	Catalog           string            `json:"catalog" validate:"required"`
	Schema            *string           `json:"schema,omitempty"`
	Table             *string           `json:"table,omitempty"`
	BucketIdentifier  *string           `json:"bucket_identifier,omitempty"`
	CatalogPath       *string           `json:"catalog_path,omitempty"`
	TablePath         *string           `json:"table_path,omitempty"`
	AccessGranularity AccessGranularity `json:"access_granularity" validate:"required"`
}

func (d DatabricksDataOutput) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.ConfigurationType, "required"); err != nil {
		errors = errors.Append("ConfigurationType", err)
	}
	if err := typesValidator.Var(d.Catalog, "required"); err != nil {
		errors = errors.Append("Catalog", err)
	}
	if v, ok := any(d.AccessGranularity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessGranularity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DatabricksEnvironmentPlatformConfiguration struct {
	WorkspaceUrls  map[string]string `json:"workspace_urls"`
	AccountID      string            `json:"account_id" validate:"required"`
	MetastoreID    string            `json:"metastore_id" validate:"required"`
	CredentialName string            `json:"credential_name" validate:"required"`
}

func (d DatabricksEnvironmentPlatformConfiguration) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatasetAboutUpdate struct {
	About string `json:"about" validate:"required"`
}

func (d DatasetAboutUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatasetStatusUpdate struct {
	Status OutputPortStatus `json:"status" validate:"required"`
}

func (d DatasetStatusUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DatasetUpdate struct {
	Name        string               `json:"name" validate:"required"`
	Namespace   string               `json:"namespace" validate:"required"`
	Description string               `json:"description" validate:"required"`
	AccessType  OutputPortAccessType `json:"access_type" validate:"required"`
	About       *string              `json:"about,omitempty"`
	LifecycleID *uuid.UUID           `json:"lifecycle_id,omitempty"`
	TagIds      []uuid.UUID          `json:"tag_ids" validate:"required"`
}

func (d DatasetUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if d.LifecycleID != nil {
		if v, ok := any(d.LifecycleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LifecycleID", err)
			}
		}
	}
	for i, item := range d.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideDataProductRoleAssignment struct {
	Decision DecisionStatus `json:"decision" validate:"required"`
}

func (d DecideDataProductRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideGlobalRoleAssignment struct {
	Decision DecisionStatus `json:"decision" validate:"required"`
}

func (d DecideGlobalRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideOutputPortRoleAssignment struct {
	Decision DecisionStatus `json:"decision" validate:"required"`
}

func (d DecideOutputPortRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteDataProductRoleAssignmentResponse struct {
	ID            uuid.UUID `json:"id" validate:"required"`
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (d DeleteDataProductRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteGlobalRoleAssignmentResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteGlobalRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteOutputPortRoleAssignmentResponse struct {
	ID           uuid.UUID `json:"id" validate:"required"`
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
}

func (d DeleteOutputPortRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DenyLinkBetweenTechnicalAssetAndOutputPortRequest struct {
	TechnicalAssetID uuid.UUID `json:"technical_asset_id" validate:"required"`
}

func (d DenyLinkBetweenTechnicalAssetAndOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DenyOutputPortAsInputPortRequest struct {
	ConsumingDataProductID uuid.UUID `json:"consuming_data_product_id" validate:"required"`
}

func (d DenyOutputPortAsInputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ConsumingDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumingDataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Domain struct {
	ID          uuid.UUID `json:"id" validate:"required"`
	Name        string    `json:"name" validate:"required"`
	Description string    `json:"description" validate:"required"`
}

func (d Domain) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DomainCreate struct {
	Name        string `json:"name" validate:"required"`
	Description string `json:"description" validate:"required"`
}

func (d DomainCreate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DomainUpdate struct {
	Name        string `json:"name" validate:"required"`
	Description string `json:"description" validate:"required"`
}

func (d DomainUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type Edge struct {
	ID           Edge_ID     `json:"id"`
	Source       Edge_Source `json:"source"`
	Target       Edge_Target `json:"target"`
	Animated     bool        `json:"animated"`
	SourceHandle *string     `json:"sourceHandle,omitempty"`
	TargetHandle *string     `json:"targetHandle,omitempty"`
}

func (e Edge) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(e.Source).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Source", err)
		}
	}
	if v, ok := any(e.Target).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Target", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Edge_ID struct {
	Edge_ID_AnyOf *Edge_ID_AnyOf `json:"-"`
}

func (e Edge_ID) Validate() error {
	var errors runtime.ValidationErrors
	if e.Edge_ID_AnyOf != nil {
		if v, ok := any(e.Edge_ID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Edge_ID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e Edge_ID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.Edge_ID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Edge_ID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *Edge_ID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.Edge_ID_AnyOf == nil {
		e.Edge_ID_AnyOf = &Edge_ID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.Edge_ID_AnyOf); err != nil {
		return fmt.Errorf("Edge_ID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Edge_Source struct {
	Edge_Source_AnyOf *Edge_Source_AnyOf `json:"-"`
}

func (e Edge_Source) Validate() error {
	var errors runtime.ValidationErrors
	if e.Edge_Source_AnyOf != nil {
		if v, ok := any(e.Edge_Source_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Edge_Source_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e Edge_Source) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.Edge_Source_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Edge_Source_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *Edge_Source) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.Edge_Source_AnyOf == nil {
		e.Edge_Source_AnyOf = &Edge_Source_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.Edge_Source_AnyOf); err != nil {
		return fmt.Errorf("Edge_Source_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Edge_Target struct {
	Edge_Target_AnyOf *Edge_Target_AnyOf `json:"-"`
}

func (e Edge_Target) Validate() error {
	var errors runtime.ValidationErrors
	if e.Edge_Target_AnyOf != nil {
		if v, ok := any(e.Edge_Target_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Edge_Target_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e Edge_Target) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.Edge_Target_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Edge_Target_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *Edge_Target) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.Edge_Target_AnyOf == nil {
		e.Edge_Target_AnyOf = &Edge_Target_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.Edge_Target_AnyOf); err != nil {
		return fmt.Errorf("Edge_Target_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Environment struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Acronym   string    `json:"acronym" validate:"required"`
	Context   string    `json:"context" validate:"required"`
	IsDefault *bool     `json:"is_default,omitempty"`
}

func (e Environment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(e.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(e.Acronym, "required"); err != nil {
		errors = errors.Append("Acronym", err)
	}
	if err := typesValidator.Var(e.Context, "required"); err != nil {
		errors = errors.Append("Context", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGet struct {
	EnvironmentConfigs []EnvironmentConfigsGetItem `json:"environment_configs" validate:"required"`
}

func (e EnvironmentConfigsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e.EnvironmentConfigs {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("EnvironmentConfigs[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGetItem struct {
	Config      EnvironmentConfigsGetItem_Config `json:"config" validate:"required"`
	ID          uuid.UUID                        `json:"id" validate:"required"`
	Platform    Platform                         `json:"platform"`
	Environment Environment                      `json:"environment"`
	Service     PlatformService                  `json:"service"`
}

func (e EnvironmentConfigsGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Config).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Config", err)
		}
	}
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(e.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if v, ok := any(e.Environment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Environment", err)
		}
	}
	if v, ok := any(e.Service).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Service", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGetItem_Config []EnvironmentConfigsGetItem_Config_Item

func (e EnvironmentConfigsGetItem_Config) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGetItem_Config_Item struct {
	EnvironmentConfigsGetItem_Config_AnyOf *EnvironmentConfigsGetItem_Config_AnyOf `json:"-"`
}

func (e EnvironmentConfigsGetItem_Config_Item) Validate() error {
	var errors runtime.ValidationErrors
	if e.EnvironmentConfigsGetItem_Config_AnyOf != nil {
		if v, ok := any(e.EnvironmentConfigsGetItem_Config_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("EnvironmentConfigsGetItem_Config_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e EnvironmentConfigsGetItem_Config_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.EnvironmentConfigsGetItem_Config_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("EnvironmentConfigsGetItem_Config_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *EnvironmentConfigsGetItem_Config_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.EnvironmentConfigsGetItem_Config_AnyOf == nil {
		e.EnvironmentConfigsGetItem_Config_AnyOf = &EnvironmentConfigsGetItem_Config_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.EnvironmentConfigsGetItem_Config_AnyOf); err != nil {
		return fmt.Errorf("EnvironmentConfigsGetItem_Config_AnyOf unmarshal: %w", err)
	}

	return nil
}

type EnvironmentGetItem struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Acronym   string    `json:"acronym" validate:"required"`
	Context   string    `json:"context" validate:"required"`
	IsDefault *bool     `json:"is_default,omitempty"`
}

func (e EnvironmentGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(e.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(e.Acronym, "required"); err != nil {
		errors = errors.Append("Acronym", err)
	}
	if err := typesValidator.Var(e.Context, "required"); err != nil {
		errors = errors.Append("Context", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentPlatformConfigGet struct {
	Config      EnvironmentPlatformConfigGet_Config `json:"config"`
	ID          uuid.UUID                           `json:"id" validate:"required"`
	Environment Environment                         `json:"environment"`
	Platform    Platform                            `json:"platform"`
}

func (e EnvironmentPlatformConfigGet) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Config).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Config", err)
		}
	}
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(e.Environment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Environment", err)
		}
	}
	if v, ok := any(e.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentPlatformConfigGet_Config struct {
	EnvironmentPlatformConfigGet_Config_AnyOf *EnvironmentPlatformConfigGet_Config_AnyOf `json:"-"`
}

func (e EnvironmentPlatformConfigGet_Config) Validate() error {
	var errors runtime.ValidationErrors
	if e.EnvironmentPlatformConfigGet_Config_AnyOf != nil {
		if v, ok := any(e.EnvironmentPlatformConfigGet_Config_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("EnvironmentPlatformConfigGet_Config_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e EnvironmentPlatformConfigGet_Config) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.EnvironmentPlatformConfigGet_Config_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("EnvironmentPlatformConfigGet_Config_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *EnvironmentPlatformConfigGet_Config) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.EnvironmentPlatformConfigGet_Config_AnyOf == nil {
		e.EnvironmentPlatformConfigGet_Config_AnyOf = &EnvironmentPlatformConfigGet_Config_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.EnvironmentPlatformConfigGet_Config_AnyOf); err != nil {
		return fmt.Errorf("EnvironmentPlatformConfigGet_Config_AnyOf unmarshal: %w", err)
	}

	return nil
}

type EnvironmentsGet struct {
	Environments []EnvironmentGetItem `json:"environments" validate:"required"`
}

func (e EnvironmentsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e.Environments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Environments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// FieldDependency Represents a field dependency for conditional visibility.
// e.g. if field A has depends_on(field_name=B, value=Y), then field A is only shown when field B has value Y
// In practice this is often used with checkbox fields having value=True
type FieldDependency struct {
	FieldName string   `json:"field_name" validate:"required"`
	Value     struct{} `json:"value"`
}

func (f FieldDependency) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(f))
}

type GetAllPlatformServiceConfigurationsResponse struct {
	PlatformServiceConfigurations []PlatformServiceConfiguration `json:"platform_service_configurations" validate:"required"`
}

func (g GetAllPlatformServiceConfigurationsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.PlatformServiceConfigurations {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("PlatformServiceConfigurations[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAllPlatformsResponse struct {
	Platforms []Platform `json:"platforms" validate:"required"`
}

func (g GetAllPlatformsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Platforms {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Platforms[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetConveyorIdeURLResponse struct {
	IdeURL string `json:"ide_url" validate:"required"`
}

func (g GetConveyorIdeURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetDataProductInputPortsResponse struct {
	InputPorts []InputPort `json:"input_ports" validate:"required"`
}

func (g GetDataProductInputPortsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.InputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("InputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductOutputPortsResponse struct {
	OutputPorts []OutputPort `json:"output_ports" validate:"required"`
}

func (g GetDataProductOutputPortsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.OutputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductResponse struct {
	ID                  uuid.UUID                 `json:"id" validate:"required"`
	Name                string                    `json:"name" validate:"required"`
	Description         string                    `json:"description" validate:"required"`
	Namespace           string                    `json:"namespace" validate:"required"`
	Status              DataProductStatus         `json:"status" validate:"required"`
	Tags                []Tag                     `json:"tags" validate:"required"`
	Usage               string                    `json:"usage"`
	Domain              Domain                    `json:"domain"`
	Type                DataProductType           `json:"type"`
	Lifecycle           DataProductLifeCycle      `json:"lifecycle"`
	DataProductSettings []DataProductSettingValue `json:"data_product_settings" validate:"required"`
	About               string                    `json:"about"`
}

func (g GetDataProductResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(g.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(g.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range g.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductRolledUpTagsResponse struct {
	RolledUpTags []Tag `json:"rolled_up_tags" validate:"required"`
}

func (g GetDataProductRolledUpTagsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.RolledUpTags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RolledUpTags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductsResponse struct {
	DataProducts []GetDataProductsResponseItem `json:"data_products" validate:"required"`
}

func (g GetDataProductsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.DataProducts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProducts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductsResponseItem struct {
	ID                  uuid.UUID                 `json:"id" validate:"required"`
	Name                string                    `json:"name" validate:"required"`
	Description         string                    `json:"description" validate:"required"`
	Namespace           string                    `json:"namespace" validate:"required"`
	Status              DataProductStatus         `json:"status" validate:"required"`
	Tags                []Tag                     `json:"tags" validate:"required"`
	Usage               string                    `json:"usage"`
	Domain              Domain                    `json:"domain"`
	Type                DataProductType           `json:"type"`
	Lifecycle           DataProductLifeCycle      `json:"lifecycle"`
	DataProductSettings []DataProductSettingValue `json:"data_product_settings" validate:"required"`
	UserCount           int                       `json:"user_count" validate:"required"`
	OutputPortCount     int                       `json:"output_port_count" validate:"required"`
	TechnicalAssetCount int                       `json:"technical_asset_count" validate:"required"`
}

func (g GetDataProductsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(g.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(g.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range g.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(g.UserCount, "required"); err != nil {
		errors = errors.Append("UserCount", err)
	}
	if err := typesValidator.Var(g.OutputPortCount, "required"); err != nil {
		errors = errors.Append("OutputPortCount", err)
	}
	if err := typesValidator.Var(g.TechnicalAssetCount, "required"); err != nil {
		errors = errors.Append("TechnicalAssetCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDatabricksWorkspaceURLResponse struct {
	DatabricksWorkspaceURL string `json:"databricks_workspace_url" validate:"required"`
}

func (g GetDatabricksWorkspaceURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetDomainResponse struct {
	ID           uuid.UUID     `json:"id" validate:"required"`
	Name         string        `json:"name" validate:"required"`
	Description  string        `json:"description" validate:"required"`
	DataProducts []DataProduct `json:"data_products" validate:"required"`
}

func (g GetDomainResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	for i, item := range g.DataProducts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProducts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDomainsItem struct {
	ID               uuid.UUID `json:"id" validate:"required"`
	Name             string    `json:"name" validate:"required"`
	Description      string    `json:"description" validate:"required"`
	DataProductCount int       `json:"data_product_count" validate:"required"`
}

func (g GetDomainsItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.DataProductCount, "required"); err != nil {
		errors = errors.Append("DataProductCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDomainsResponse struct {
	Domains []GetDomainsItem `json:"domains" validate:"required"`
}

func (g GetDomainsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Domains {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Domains[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEventHistoryResponse struct {
	Events []GetEventHistoryResponseItem `json:"events" validate:"required"`
}

func (g GetEventHistoryResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Events {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Events[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEventHistoryResponseItem struct {
	ID                       uuid.UUID        `json:"id" validate:"required"`
	Name                     string           `json:"name" validate:"required"`
	SubjectID                uuid.UUID        `json:"subject_id" validate:"required"`
	TargetID                 *uuid.UUID       `json:"target_id,omitempty"`
	SubjectType              EventEntityType  `json:"subject_type" validate:"required"`
	TargetType               *EventEntityType `json:"target_type,omitempty"`
	ActorID                  uuid.UUID        `json:"actor_id" validate:"required"`
	CreatedOn                time.Time        `json:"created_on" validate:"required"`
	DeletedSubjectIdentifier *string          `json:"deleted_subject_identifier,omitempty"`
	DeletedTargetIdentifier  *string          `json:"deleted_target_identifier,omitempty"`
	Actor                    User             `json:"actor"`
	DataProduct              *DataProduct     `json:"data_product,omitempty"`
	User                     *User            `json:"user,omitempty"`
	OutputPort               *OutputPort      `json:"output_port,omitempty"`
	TechnicalAsset           *TechnicalAsset  `json:"technical_asset,omitempty"`
}

func (g GetEventHistoryResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(g.SubjectID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SubjectID", err)
		}
	}
	if g.TargetID != nil {
		if v, ok := any(g.TargetID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TargetID", err)
			}
		}
	}
	if v, ok := any(g.SubjectType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SubjectType", err)
		}
	}
	if g.TargetType != nil {
		if v, ok := any(g.TargetType).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TargetType", err)
			}
		}
	}
	if v, ok := any(g.ActorID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ActorID", err)
		}
	}
	if err := typesValidator.Var(g.CreatedOn, "required"); err != nil {
		errors = errors.Append("CreatedOn", err)
	}
	if v, ok := any(g.Actor).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Actor", err)
		}
	}
	if g.DataProduct != nil {
		if v, ok := any(g.DataProduct).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataProduct", err)
			}
		}
	}
	if g.User != nil {
		if v, ok := any(g.User).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("User", err)
			}
		}
	}
	if g.OutputPort != nil {
		if v, ok := any(g.OutputPort).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("OutputPort", err)
			}
		}
	}
	if g.TechnicalAsset != nil {
		if v, ok := any(g.TechnicalAsset).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TechnicalAsset", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortResponse struct {
	ID                  uuid.UUID                `json:"id" validate:"required"`
	Namespace           string                   `json:"namespace" validate:"required"`
	Name                string                   `json:"name" validate:"required"`
	Description         string                   `json:"description" validate:"required"`
	Status              OutputPortStatus         `json:"status" validate:"required"`
	Usage               string                   `json:"usage"`
	AccessType          OutputPortAccessType     `json:"access_type" validate:"required"`
	DataProductID       uuid.UUID                `json:"data_product_id" validate:"required"`
	Tags                []Tag                    `json:"tags" validate:"required"`
	Domain              Domain                   `json:"domain"`
	Lifecycle           DataProductLifeCycle     `json:"lifecycle"`
	DataProductSettings []OutputPortSettingValue `json:"data_product_settings" validate:"required"`
	TechnicalAssetLinks []TechnicalAssetLink     `json:"technical_asset_links" validate:"required"`
	About               string                   `json:"about"`
	RolledUpTags        []Tag                    `json:"rolled_up_tags" validate:"required"`
}

func (g GetOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(g.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(g.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(g.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range g.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	for i, item := range g.TechnicalAssetLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalAssetLinks[%d]", i), err)
			}
		}
	}
	for i, item := range g.RolledUpTags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RolledUpTags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetPlatformServicesResponse struct {
	PlatformServices []PlatformService `json:"platform_services" validate:"required"`
}

func (g GetPlatformServicesResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.PlatformServices {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("PlatformServices[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRolesResponse struct {
	Roles []Role `json:"roles" validate:"required"`
}

func (g GetRolesResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Roles {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Roles[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSigninURLResponse struct {
	SigninURL string `json:"signin_url" validate:"required"`
}

func (g GetSigninURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetSnowflakeURLResponse struct {
	SnowflakeURL string `json:"snowflake_url" validate:"required"`
}

func (g GetSnowflakeURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetTechnicalAssetsResponse struct {
	TechnicalAssets []GetTechnicalAssetsResponseItem `json:"technical_assets" validate:"required"`
}

func (g GetTechnicalAssetsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.TechnicalAssets {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalAssets[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetsResponseItem struct {
	ID               uuid.UUID                                    `json:"id" validate:"required"`
	Name             string                                       `json:"name" validate:"required"`
	Description      string                                       `json:"description" validate:"required"`
	Namespace        string                                       `json:"namespace" validate:"required"`
	OwnerID          uuid.UUID                                    `json:"owner_id" validate:"required"`
	PlatformID       uuid.UUID                                    `json:"platform_id" validate:"required"`
	ServiceID        uuid.UUID                                    `json:"service_id" validate:"required"`
	Status           TechnicalAssetStatus                         `json:"status" validate:"required"`
	TechnicalMapping TechnicalMapping                             `json:"technical_mapping" validate:"required"`
	Configuration    GetTechnicalAssetsResponseItem_Configuration `json:"configuration"`
	Owner            DataProduct                                  `json:"owner"`
	OutputPortLinks  []OutputPortLink                             `json:"output_port_links" validate:"required"`
	Tags             []Tag                                        `json:"tags" validate:"required"`

	// SourceAligned DEPRECATED: Use 'technical_mapping' instead. This field will be removed in a future version.
	SourceAligned *bool           `json:"sourceAligned,omitempty"`
	ResultString  *string         `json:"result_string,omitempty"`
	TechnicalInfo []TechnicalInfo `json:"technical_info,omitempty"`
}

func (g GetTechnicalAssetsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(g.OwnerID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OwnerID", err)
		}
	}
	if v, ok := any(g.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(g.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(g.TechnicalMapping).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalMapping", err)
		}
	}
	if v, ok := any(g.Configuration).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Configuration", err)
		}
	}
	if v, ok := any(g.Owner).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Owner", err)
		}
	}
	for i, item := range g.OutputPortLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortLinks[%d]", i), err)
			}
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	for i, item := range g.TechnicalInfo {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalInfo[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetsResponseItem_Configuration struct {
	GetTechnicalAssetsResponseItem_Configuration_OneOf *GetTechnicalAssetsResponseItem_Configuration_OneOf `json:"-"`
}

func (g GetTechnicalAssetsResponseItem_Configuration) Validate() error {
	var errors runtime.ValidationErrors
	if g.GetTechnicalAssetsResponseItem_Configuration_OneOf != nil {
		if v, ok := any(g.GetTechnicalAssetsResponseItem_Configuration_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("GetTechnicalAssetsResponseItem_Configuration_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (g GetTechnicalAssetsResponseItem_Configuration) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(g.GetTechnicalAssetsResponseItem_Configuration_OneOf)
		if err != nil {
			return nil, fmt.Errorf("GetTechnicalAssetsResponseItem_Configuration_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (g *GetTechnicalAssetsResponseItem_Configuration) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if g.GetTechnicalAssetsResponseItem_Configuration_OneOf == nil {
		g.GetTechnicalAssetsResponseItem_Configuration_OneOf = &GetTechnicalAssetsResponseItem_Configuration_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, g.GetTechnicalAssetsResponseItem_Configuration_OneOf); err != nil {
		return fmt.Errorf("GetTechnicalAssetsResponseItem_Configuration_OneOf unmarshal: %w", err)
	}

	return nil
}

type GetUserNotificationsResponse struct {
	Notifications []GetUserNotificationsResponseItem `json:"notifications" validate:"required"`
}

func (g GetUserNotificationsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Notifications {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Notifications[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetUserNotificationsResponseItem struct {
	ID      uuid.UUID                   `json:"id" validate:"required"`
	EventID uuid.UUID                   `json:"event_id" validate:"required"`
	UserID  uuid.UUID                   `json:"user_id" validate:"required"`
	Event   GetEventHistoryResponseItem `json:"event"`
	User    User                        `json:"user"`
}

func (g GetUserNotificationsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.EventID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("EventID", err)
		}
	}
	if v, ok := any(g.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(g.Event).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Event", err)
		}
	}
	if v, ok := any(g.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetUsersResponse struct {
	Users []UsersGet `json:"users" validate:"required"`
}

func (g GetUsersResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Users {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Users[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GlobalRoleAssignmentResponse struct {
	ID          uuid.UUID      `json:"id" validate:"required"`
	User        User           `json:"user"`
	Role        Role           `json:"role"`
	Decision    DecisionStatus `json:"decision" validate:"required"`
	RequestedOn time.Time      `json:"requested_on"`
	RequestedBy User           `json:"requested_by"`
	DecidedOn   time.Time      `json:"decided_on"`
	DecidedBy   User           `json:"decided_by"`
}

func (g GlobalRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(g.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(g.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(g.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(g.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GlueDataOutput struct {
	ConfigurationType string            `json:"configuration_type" validate:"required"`
	Database          string            `json:"database" validate:"required"`
	DatabaseSuffix    *string           `json:"database_suffix,omitempty"`
	Table             *string           `json:"table,omitempty"`
	BucketIdentifier  *string           `json:"bucket_identifier,omitempty"`
	DatabasePath      *string           `json:"database_path,omitempty"`
	TablePath         *string           `json:"table_path,omitempty"`
	AccessGranularity AccessGranularity `json:"access_granularity" validate:"required"`
}

func (g GlueDataOutput) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(g.ConfigurationType, "required"); err != nil {
		errors = errors.Append("ConfigurationType", err)
	}
	if err := typesValidator.Var(g.Database, "required"); err != nil {
		errors = errors.Append("Database", err)
	}
	if v, ok := any(g.AccessGranularity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessGranularity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Graph struct {
	Edges []Edge `json:"edges" validate:"required"`
	Nodes []Node `json:"nodes" validate:"required"`
}

func (g Graph) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Edges {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Edges[%d]", i), err)
			}
		}
	}
	for i, item := range g.Nodes {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Nodes[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type HTTPValidationError struct {
	Detail []ValidationError `json:"detail,omitempty"`
}

func (h HTTPValidationError) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range h.Detail {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Detail[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (s HTTPValidationError) Error() string {
	return "unmapped client error"
}

type InputPort struct {
	ID            uuid.UUID      `json:"id" validate:"required"`
	Justification string         `json:"justification" validate:"required"`
	DataProductID uuid.UUID      `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID      `json:"output_port_id" validate:"required"`
	Status        DecisionStatus `json:"status" validate:"required"`
	InputPort     OutputPort     `json:"input_port"`
}

func (i InputPort) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(i.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(i.Justification, "required"); err != nil {
		errors = errors.Append("Justification", err)
	}
	if v, ok := any(i.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(i.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(i.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(i.InputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("InputPort", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type IsAdminResponse struct {
	IsAdmin bool    `json:"is_admin"`
	Time    *string `json:"time,omitempty"`
}

type LinkInputPortsToDataProduct struct {
	InputPorts    []uuid.UUID `json:"input_ports" validate:"required"`
	Justification string      `json:"justification" validate:"required"`
}

func (l LinkInputPortsToDataProduct) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.InputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("InputPorts[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(l.Justification, "required"); err != nil {
		errors = errors.Append("Justification", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkInputPortsToDataProductPost struct {
	InputPortLinks []uuid.UUID `json:"input_port_links" validate:"required"`
}

func (l LinkInputPortsToDataProductPost) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.InputPortLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("InputPortLinks[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkTechnicalAssetToOutputPortRequest struct {
	TechnicalAssetID uuid.UUID `json:"technical_asset_id" validate:"required"`
}

func (l LinkTechnicalAssetToOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkTechnicalAssetsToOutputPortResponse struct {
	LinkID uuid.UUID `json:"link_id" validate:"required"`
}

func (l LinkTechnicalAssetsToOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.LinkID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("LinkID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyDataProductRoleAssignment struct {
	RoleID uuid.UUID `json:"role_id" validate:"required"`
}

func (m ModifyDataProductRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyGlobalRoleAssignment struct {
	RoleID ModifyGlobalRoleAssignment_RoleID `json:"role_id"`
}

func (m ModifyGlobalRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyGlobalRoleAssignment_RoleID struct {
	ModifyGlobalRoleAssignment_RoleID_AnyOf *ModifyGlobalRoleAssignment_RoleID_AnyOf `json:"-"`
}

func (m ModifyGlobalRoleAssignment_RoleID) Validate() error {
	var errors runtime.ValidationErrors
	if m.ModifyGlobalRoleAssignment_RoleID_AnyOf != nil {
		if v, ok := any(m.ModifyGlobalRoleAssignment_RoleID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("ModifyGlobalRoleAssignment_RoleID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (m ModifyGlobalRoleAssignment_RoleID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(m.ModifyGlobalRoleAssignment_RoleID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("ModifyGlobalRoleAssignment_RoleID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (m *ModifyGlobalRoleAssignment_RoleID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if m.ModifyGlobalRoleAssignment_RoleID_AnyOf == nil {
		m.ModifyGlobalRoleAssignment_RoleID_AnyOf = &ModifyGlobalRoleAssignment_RoleID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, m.ModifyGlobalRoleAssignment_RoleID_AnyOf); err != nil {
		return fmt.Errorf("ModifyGlobalRoleAssignment_RoleID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type ModifyOutputPortRoleAssignment struct {
	RoleID uuid.UUID `json:"role_id" validate:"required"`
}

func (m ModifyOutputPortRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Node struct {
	ID     Node_ID  `json:"id"`
	Data   NodeData `json:"data"`
	Type   NodeType `json:"type" validate:"required"`
	IsMain *bool    `json:"isMain,omitempty"`
}

func (n Node) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(n.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(n.Data).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Data", err)
		}
	}
	if v, ok := any(n.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Node_ID struct {
	Node_ID_AnyOf *Node_ID_AnyOf `json:"-"`
}

func (n Node_ID) Validate() error {
	var errors runtime.ValidationErrors
	if n.Node_ID_AnyOf != nil {
		if v, ok := any(n.Node_ID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Node_ID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n Node_ID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.Node_ID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Node_ID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *Node_ID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.Node_ID_AnyOf == nil {
		n.Node_ID_AnyOf = &Node_ID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.Node_ID_AnyOf); err != nil {
		return fmt.Errorf("Node_ID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData struct {
	ID          NodeData_ID           `json:"id"`
	Name        string                `json:"name" validate:"required"`
	LinkToID    *NodeData_LinkToID    `json:"link_to_id,omitempty"`
	IconKey     *string               `json:"icon_key,omitempty"`
	Domain      *string               `json:"domain,omitempty"`
	DomainID    *NodeData_DomainID    `json:"domain_id,omitempty"`
	Description *string               `json:"description,omitempty"`
	Assignments *NodeData_Assignments `json:"assignments,omitempty"`
}

func (n NodeData) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(n.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(n.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if n.LinkToID != nil {
		if v, ok := any(n.LinkToID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LinkToID", err)
			}
		}
	}
	if n.DomainID != nil {
		if v, ok := any(n.DomainID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DomainID", err)
			}
		}
	}
	if n.Assignments != nil {
		if v, ok := any(n.Assignments).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Assignments", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NodeData_ID struct {
	NodeData_ID_AnyOf *NodeData_ID_AnyOf `json:"-"`
}

func (n NodeData_ID) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_ID_AnyOf != nil {
		if v, ok := any(n.NodeData_ID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_ID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_ID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_ID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_ID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_ID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_ID_AnyOf == nil {
		n.NodeData_ID_AnyOf = &NodeData_ID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_ID_AnyOf); err != nil {
		return fmt.Errorf("NodeData_ID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData_LinkToID struct {
	NodeData_LinkToID_AnyOf *NodeData_LinkToID_AnyOf `json:"-"`
}

func (n NodeData_LinkToID) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_LinkToID_AnyOf != nil {
		if v, ok := any(n.NodeData_LinkToID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_LinkToID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_LinkToID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_LinkToID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_LinkToID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_LinkToID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_LinkToID_AnyOf == nil {
		n.NodeData_LinkToID_AnyOf = &NodeData_LinkToID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_LinkToID_AnyOf); err != nil {
		return fmt.Errorf("NodeData_LinkToID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData_DomainID struct {
	NodeData_DomainID_AnyOf *NodeData_DomainID_AnyOf `json:"-"`
}

func (n NodeData_DomainID) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_DomainID_AnyOf != nil {
		if v, ok := any(n.NodeData_DomainID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_DomainID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_DomainID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_DomainID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_DomainID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_DomainID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_DomainID_AnyOf == nil {
		n.NodeData_DomainID_AnyOf = &NodeData_DomainID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_DomainID_AnyOf); err != nil {
		return fmt.Errorf("NodeData_DomainID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData_Assignments []NodeData_Assignments_AnyOf_Item

func (n NodeData_Assignments) Validate() error {
	if n == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	for i, item := range n {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NodeData_Assignments_AnyOf_Item struct {
	NodeData_Assignments_AnyOf_AnyOf *NodeData_Assignments_AnyOf_AnyOf `json:"-"`
}

func (n NodeData_Assignments_AnyOf_Item) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_Assignments_AnyOf_AnyOf != nil {
		if v, ok := any(n.NodeData_Assignments_AnyOf_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_Assignments_AnyOf_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_Assignments_AnyOf_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_Assignments_AnyOf_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_Assignments_AnyOf_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_Assignments_AnyOf_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_Assignments_AnyOf_AnyOf == nil {
		n.NodeData_Assignments_AnyOf_AnyOf = &NodeData_Assignments_AnyOf_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_Assignments_AnyOf_AnyOf); err != nil {
		return fmt.Errorf("NodeData_Assignments_AnyOf_AnyOf unmarshal: %w", err)
	}

	return nil
}

type OutputPort struct {
	ID            uuid.UUID            `json:"id" validate:"required"`
	Name          string               `json:"name" validate:"required"`
	Namespace     string               `json:"namespace" validate:"required"`
	Description   string               `json:"description" validate:"required"`
	Status        OutputPortStatus     `json:"status" validate:"required"`
	AccessType    OutputPortAccessType `json:"access_type" validate:"required"`
	DataProductID uuid.UUID            `json:"data_product_id" validate:"required"`
	Tags          []Tag                `json:"tags" validate:"required"`
}

func (o OutputPort) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(o.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(o.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(o.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(o.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(o.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if v, ok := any(o.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	for i, item := range o.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQueries struct {
	OutputPortCuratedQueries []OutputPortCuratedQuery `json:"output_port_curated_queries" validate:"required"`
}

func (o OutputPortCuratedQueries) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range o.OutputPortCuratedQueries {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortCuratedQueries[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQueriesUpdate struct {
	CuratedQueries []OutputPortCuratedQueryInput `json:"curated_queries" validate:"required"`
}

func (o OutputPortCuratedQueriesUpdate) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range o.CuratedQueries {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("CuratedQueries[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQuery struct {
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
	SortOrder    int       `json:"sort_order" validate:"required"`
	Title        string    `json:"title" validate:"required"`
	Description  string    `json:"description"`
	QueryText    string    `json:"query_text" validate:"required"`
	CreatedAt    time.Time `json:"created_at" validate:"required"`
	UpdatedAt    time.Time `json:"updated_at"`
}

func (o OutputPortCuratedQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if err := typesValidator.Var(o.SortOrder, "required"); err != nil {
		errors = errors.Append("SortOrder", err)
	}
	if err := typesValidator.Var(o.Title, "required"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(o.QueryText, "required"); err != nil {
		errors = errors.Append("QueryText", err)
	}
	if err := typesValidator.Var(o.CreatedAt, "required"); err != nil {
		errors = errors.Append("CreatedAt", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQueryInput struct {
	Title       string  `json:"title" validate:"required"`
	Description *string `json:"description,omitempty"`
	QueryText   string  `json:"query_text" validate:"required"`
}

func (o OutputPortCuratedQueryInput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(o))
}

type OutputPortLink struct {
	ID               uuid.UUID      `json:"id" validate:"required"`
	OutputPortID     uuid.UUID      `json:"output_port_id" validate:"required"`
	TechnicalAssetID uuid.UUID      `json:"technical_asset_id" validate:"required"`
	Status           DecisionStatus `json:"status" validate:"required"`
	Output           OutputPort     `json:"output"`
}

func (o OutputPortLink) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(o.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(o.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if v, ok := any(o.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(o.Output).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Output", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsDelete struct {
	Date                  string    `json:"date" validate:"required"`
	ConsumerDataProductID uuid.UUID `json:"consumer_data_product_id" validate:"required"`
}

func (o OutputPortQueryStatsDelete) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.Date, "required"); err != nil {
		errors = errors.Append("Date", err)
	}
	if v, ok := any(o.ConsumerDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumerDataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsResponse struct {
	Date                    runtime.Date `json:"date" validate:"required"`
	ConsumerDataProductID   uuid.UUID    `json:"consumer_data_product_id" validate:"required"`
	QueryCount              int          `json:"query_count" validate:"required"`
	ConsumerDataProductName *string      `json:"consumer_data_product_name,omitempty"`
}

func (o OutputPortQueryStatsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.Date).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Date", err)
		}
	}
	if v, ok := any(o.ConsumerDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumerDataProductID", err)
		}
	}
	if err := typesValidator.Var(o.QueryCount, "required"); err != nil {
		errors = errors.Append("QueryCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsResponses struct {
	OutputPortQueryStatsResponses []OutputPortQueryStatsResponse `json:"output_port_query_stats_responses" validate:"required"`
}

func (o OutputPortQueryStatsResponses) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range o.OutputPortQueryStatsResponses {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortQueryStatsResponses[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsUpdate struct {
	Date                  string    `json:"date" validate:"required"`
	ConsumerDataProductID uuid.UUID `json:"consumer_data_product_id" validate:"required"`
	QueryCount            int       `json:"query_count" validate:"required"`
}

func (o OutputPortQueryStatsUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.Date, "required"); err != nil {
		errors = errors.Append("Date", err)
	}
	if v, ok := any(o.ConsumerDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumerDataProductID", err)
		}
	}
	if err := typesValidator.Var(o.QueryCount, "required"); err != nil {
		errors = errors.Append("QueryCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortRoleAssignmentResponse struct {
	ID          uuid.UUID      `json:"id" validate:"required"`
	OutputPort  OutputPort     `json:"output_port"`
	User        User           `json:"user"`
	Role        Role           `json:"role"`
	Decision    DecisionStatus `json:"decision" validate:"required"`
	RequestedOn time.Time      `json:"requested_on"`
	RequestedBy User           `json:"requested_by"`
	DecidedOn   time.Time      `json:"decided_on"`
	DecidedBy   User           `json:"decided_by"`
}

func (o OutputPortRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(o.OutputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPort", err)
		}
	}
	if v, ok := any(o.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(o.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(o.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(o.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(o.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortSettingValue struct {
	ID                   uuid.UUID          `json:"id" validate:"required"`
	DataProductSettingID uuid.UUID          `json:"data_product_setting_id" validate:"required"`
	Value                string             `json:"value" validate:"required"`
	DataProductSetting   DataProductSetting `json:"data_product_setting"`
	OutputPortID         uuid.UUID          `json:"output_port_id" validate:"required"`
}

func (o OutputPortSettingValue) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(o.DataProductSettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSettingID", err)
		}
	}
	if err := typesValidator.Var(o.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if v, ok := any(o.DataProductSetting).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSetting", err)
		}
	}
	if v, ok := any(o.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PendingActionResponse struct {
	PendingActions PendingActionResponse_PendingActions `json:"pending_actions" validate:"required"`
}

func (p PendingActionResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.PendingActions).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PendingActions", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PendingActionResponse_PendingActions []PendingActionResponse_PendingActions_Item

func (p PendingActionResponse_PendingActions) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range p {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PendingActionResponse_PendingActions_Item struct {
	PendingActionResponse_PendingActions_AnyOf *PendingActionResponse_PendingActions_AnyOf `json:"-"`
}

func (p PendingActionResponse_PendingActions_Item) Validate() error {
	var errors runtime.ValidationErrors
	if p.PendingActionResponse_PendingActions_AnyOf != nil {
		if v, ok := any(p.PendingActionResponse_PendingActions_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PendingActionResponse_PendingActions_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (p PendingActionResponse_PendingActions_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(p.PendingActionResponse_PendingActions_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("PendingActionResponse_PendingActions_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (p *PendingActionResponse_PendingActions_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if p.PendingActionResponse_PendingActions_AnyOf == nil {
		p.PendingActionResponse_PendingActions_AnyOf = &PendingActionResponse_PendingActions_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, p.PendingActionResponse_PendingActions_AnyOf); err != nil {
		return fmt.Errorf("PendingActionResponse_PendingActions_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Platform struct {
	ID   uuid.UUID `json:"id" validate:"required"`
	Name string    `json:"name" validate:"required"`
}

func (p Platform) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(p.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PlatformService struct {
	ID                    uuid.UUID `json:"id" validate:"required"`
	Name                  string    `json:"name" validate:"required"`
	Platform              Platform  `json:"platform"`
	ResultStringTemplate  string    `json:"result_string_template" validate:"required"`
	TechnicalInfoTemplate string    `json:"technical_info_template" validate:"required"`
}

func (p PlatformService) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(p.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(p.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if err := typesValidator.Var(p.ResultStringTemplate, "required"); err != nil {
		errors = errors.Append("ResultStringTemplate", err)
	}
	if err := typesValidator.Var(p.TechnicalInfoTemplate, "required"); err != nil {
		errors = errors.Append("TechnicalInfoTemplate", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PlatformServiceConfiguration struct {
	ID       uuid.UUID       `json:"id" validate:"required"`
	Platform Platform        `json:"platform"`
	Service  PlatformService `json:"service"`
	Config   []string        `json:"config" validate:"required"`
}

func (p PlatformServiceConfiguration) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(p.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if v, ok := any(p.Service).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Service", err)
		}
	}
	if err := typesValidator.Var(p.Config, "required"); err != nil {
		errors = errors.Append("Config", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// PlatformTile Represents a platform tile in the UI
type PlatformTile struct {
	Label     string         `json:"label" validate:"required"`
	Value     string         `json:"value" validate:"required"`
	IconName  string         `json:"icon_name" validate:"required"`
	HasMenu   *bool          `json:"has_menu,omitempty"`
	HasConfig *bool          `json:"has_config,omitempty"`
	Children  []PlatformTile `json:"children,omitempty"`
}

func (p PlatformTile) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(p.Label, "required"); err != nil {
		errors = errors.Append("Label", err)
	}
	if err := typesValidator.Var(p.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(p.IconName, "required"); err != nil {
		errors = errors.Append("IconName", err)
	}
	for i, item := range p.Children {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Children[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// PlatformTileResponse Response model for platform tiles
type PlatformTileResponse struct {
	PlatformTiles []PlatformTile `json:"platform_tiles" validate:"required"`
}

func (p PlatformTileResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range p.PlatformTiles {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("PlatformTiles[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// PluginResponse Response model for listing available plugins
type PluginResponse struct {
	Plugins []UIElementMetadataResponse `json:"plugins" validate:"required"`
}

func (p PluginResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range p.Plugins {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Plugins[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RedshiftConfig struct {
	Identifier       string `json:"identifier" validate:"required"`
	DatabaseName     string `json:"database_name" validate:"required"`
	BucketIdentifier string `json:"bucket_identifier" validate:"required"`
	S3Path           string `json:"s3_path" validate:"required"`
}

func (r RedshiftConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type RedshiftDataOutput struct {
	ConfigurationType string            `json:"configuration_type" validate:"required"`
	Database          string            `json:"database" validate:"required"`
	Schema            *string           `json:"schema,omitempty"`
	Table             *string           `json:"table,omitempty"`
	BucketIdentifier  *string           `json:"bucket_identifier,omitempty"`
	DatabasePath      *string           `json:"database_path,omitempty"`
	TablePath         *string           `json:"table_path,omitempty"`
	AccessGranularity AccessGranularity `json:"access_granularity" validate:"required"`
}

func (r RedshiftDataOutput) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(r.ConfigurationType, "required"); err != nil {
		errors = errors.Append("ConfigurationType", err)
	}
	if err := typesValidator.Var(r.Database, "required"); err != nil {
		errors = errors.Append("Database", err)
	}
	if v, ok := any(r.AccessGranularity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessGranularity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveOutputPortAsInputPortRequest struct {
	ConsumingDataProductID uuid.UUID `json:"consuming_data_product_id" validate:"required"`
}

func (r RemoveOutputPortAsInputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ConsumingDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumingDataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RequestDataProductRoleAssignment struct {
	UserID        uuid.UUID `json:"user_id" validate:"required"`
	RoleID        uuid.UUID `json:"role_id" validate:"required"`
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (r RequestDataProductRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(r.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(r.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RequestOutputPortRoleAssignment struct {
	UserID       uuid.UUID `json:"user_id" validate:"required"`
	RoleID       uuid.UUID `json:"role_id" validate:"required"`
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
}

func (r RequestOutputPortRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(r.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(r.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ResourceNameLengthLimits struct {
	MaxLength int `json:"max_length" validate:"required"`
}

func (r ResourceNameLengthLimits) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type ResourceNameSuggestion struct {
	ResourceName string `json:"resource_name" validate:"required"`
}

func (r ResourceNameSuggestion) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type ResourceNameValidation struct {
	Validity ResourceNameValidityType `json:"validity" validate:"required"`
}

func (r ResourceNameValidation) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.Validity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Validity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ResourceNameValidationRequest struct {
	ResourceName  string            `json:"resource_name" validate:"required"`
	DataProductID *uuid.UUID        `json:"data_product_id,omitempty"`
	Model         ResourceNameModel `json:"model" validate:"required"`
}

func (r ResourceNameValidationRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(r.ResourceName, "required"); err != nil {
		errors = errors.Append("ResourceName", err)
	}
	if r.DataProductID != nil {
		if v, ok := any(r.DataProductID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataProductID", err)
			}
		}
	}
	if v, ok := any(r.Model).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Model", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Role struct {
	Name        string                `json:"name" validate:"required"`
	Scope       Scope                 `json:"scope" validate:"required"`
	Description string                `json:"description" validate:"required"`
	Permissions []AuthorizationAction `json:"permissions" validate:"required"`
	ID          uuid.UUID             `json:"id" validate:"required"`
	Prototype   Prototype             `json:"prototype" validate:"required"`
}

func (r Role) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(r.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(r.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if err := typesValidator.Var(r.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	for i, item := range r.Permissions {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Permissions[%d]", i), err)
			}
		}
	}
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(r.Prototype).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Prototype", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type S3DataOutput struct {
	ConfigurationType string  `json:"configuration_type" validate:"required"`
	Bucket            string  `json:"bucket" validate:"required"`
	Suffix            *string `json:"suffix,omitempty"`
	Path              string  `json:"path" validate:"required"`
}

func (s S3DataOutput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchOutputPortsResponse struct {
	OutputPorts []SearchOutputPortsResponseItem `json:"output_ports" validate:"required"`
}

func (s SearchOutputPortsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range s.OutputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchOutputPortsResponseItem struct {
	ID                  uuid.UUID                `json:"id" validate:"required"`
	Namespace           string                   `json:"namespace" validate:"required"`
	Name                string                   `json:"name" validate:"required"`
	Description         string                   `json:"description" validate:"required"`
	Status              OutputPortStatus         `json:"status" validate:"required"`
	Usage               string                   `json:"usage"`
	AccessType          OutputPortAccessType     `json:"access_type" validate:"required"`
	DataProductID       uuid.UUID                `json:"data_product_id" validate:"required"`
	Tags                []Tag                    `json:"tags" validate:"required"`
	Domain              Domain                   `json:"domain"`
	Lifecycle           DataProductLifeCycle     `json:"lifecycle"`
	DataProductSettings []OutputPortSettingValue `json:"data_product_settings" validate:"required"`
	TechnicalAssetLinks []TechnicalAssetLink     `json:"technical_asset_links" validate:"required"`
	DataProductCount    int                      `json:"data_product_count" validate:"required"`
	DataProductName     string                   `json:"data_product_name" validate:"required"`
}

func (s SearchOutputPortsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(s.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(s.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(s.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(s.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(s.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if v, ok := any(s.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	for i, item := range s.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(s.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(s.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range s.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	for i, item := range s.TechnicalAssetLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalAssetLinks[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(s.DataProductCount, "required"); err != nil {
		errors = errors.Append("DataProductCount", err)
	}
	if err := typesValidator.Var(s.DataProductName, "required"); err != nil {
		errors = errors.Append("DataProductName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

// SelectOption Option for select UI elements
type SelectOption struct {
	Label string             `json:"label" validate:"required"`
	Value SelectOption_Value `json:"value"`
}

func (s SelectOption) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.Label, "required"); err != nil {
		errors = errors.Append("Label", err)
	}
	if v, ok := any(s.Value).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Value", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SelectOption_Value struct {
	SelectOption_Value_AnyOf *SelectOption_Value_AnyOf `json:"-"`
}

func (s SelectOption_Value) Validate() error {
	var errors runtime.ValidationErrors
	if s.SelectOption_Value_AnyOf != nil {
		if v, ok := any(s.SelectOption_Value_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("SelectOption_Value_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (s SelectOption_Value) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(s.SelectOption_Value_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("SelectOption_Value_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (s *SelectOption_Value) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if s.SelectOption_Value_AnyOf == nil {
		s.SelectOption_Value_AnyOf = &SelectOption_Value_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, s.SelectOption_Value_AnyOf); err != nil {
		return fmt.Errorf("SelectOption_Value_AnyOf unmarshal: %w", err)
	}

	return nil
}

type SnowflakeConfig struct {
	Identifier   string `json:"identifier" validate:"required"`
	DatabaseName string `json:"database_name" validate:"required"`
}

func (s SnowflakeConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SnowflakeDataOutput struct {
	ConfigurationType string            `json:"configuration_type" validate:"required"`
	Database          string            `json:"database" validate:"required"`
	Schema            *string           `json:"schema,omitempty"`
	Table             *string           `json:"table,omitempty"`
	BucketIdentifier  *string           `json:"bucket_identifier,omitempty"`
	DatabasePath      *string           `json:"database_path,omitempty"`
	TablePath         *string           `json:"table_path,omitempty"`
	AccessGranularity AccessGranularity `json:"access_granularity" validate:"required"`
}

func (s SnowflakeDataOutput) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(s.ConfigurationType, "required"); err != nil {
		errors = errors.Append("ConfigurationType", err)
	}
	if err := typesValidator.Var(s.Database, "required"); err != nil {
		errors = errors.Append("Database", err)
	}
	if v, ok := any(s.AccessGranularity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessGranularity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Tag struct {
	ID    uuid.UUID `json:"id" validate:"required"`
	Value string    `json:"value" validate:"required"`
}

func (t Tag) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(t.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TagCreate struct {
	Value string `json:"value" validate:"required"`
}

func (t TagCreate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type TagUpdate struct {
	Value string `json:"value" validate:"required"`
}

func (t TagUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type TagsGet struct {
	Tags []TagsGetItem `json:"tags" validate:"required"`
}

func (t TagsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range t.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TagsGetItem struct {
	ID    uuid.UUID `json:"id" validate:"required"`
	Value string    `json:"value" validate:"required"`
}

func (t TagsGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(t.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalAsset struct {
	ID               uuid.UUID                    `json:"id" validate:"required"`
	Name             string                       `json:"name" validate:"required"`
	Namespace        string                       `json:"namespace" validate:"required"`
	Description      string                       `json:"description" validate:"required"`
	Status           TechnicalAssetStatus         `json:"status" validate:"required"`
	TechnicalMapping TechnicalMapping             `json:"technical_mapping" validate:"required"`
	OwnerID          uuid.UUID                    `json:"owner_id" validate:"required"`
	PlatformID       uuid.UUID                    `json:"platform_id" validate:"required"`
	ServiceID        uuid.UUID                    `json:"service_id" validate:"required"`
	Configuration    TechnicalAsset_Configuration `json:"configuration"`
}

func (t TechnicalAsset) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(t.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(t.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(t.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(t.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(t.TechnicalMapping).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalMapping", err)
		}
	}
	if v, ok := any(t.OwnerID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OwnerID", err)
		}
	}
	if v, ok := any(t.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(t.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if v, ok := any(t.Configuration).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Configuration", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalAsset_Configuration struct {
	TechnicalAsset_Configuration_OneOf *TechnicalAsset_Configuration_OneOf `json:"-"`
}

func (t TechnicalAsset_Configuration) Validate() error {
	var errors runtime.ValidationErrors
	if t.TechnicalAsset_Configuration_OneOf != nil {
		if v, ok := any(t.TechnicalAsset_Configuration_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TechnicalAsset_Configuration_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (t TechnicalAsset_Configuration) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(t.TechnicalAsset_Configuration_OneOf)
		if err != nil {
			return nil, fmt.Errorf("TechnicalAsset_Configuration_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (t *TechnicalAsset_Configuration) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if t.TechnicalAsset_Configuration_OneOf == nil {
		t.TechnicalAsset_Configuration_OneOf = &TechnicalAsset_Configuration_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, t.TechnicalAsset_Configuration_OneOf); err != nil {
		return fmt.Errorf("TechnicalAsset_Configuration_OneOf unmarshal: %w", err)
	}

	return nil
}

type TechnicalAssetLink struct {
	ID               uuid.UUID      `json:"id" validate:"required"`
	OutputPortID     uuid.UUID      `json:"output_port_id" validate:"required"`
	TechnicalAssetID uuid.UUID      `json:"technical_asset_id" validate:"required"`
	Status           DecisionStatus `json:"status" validate:"required"`
	TechnicalAsset   TechnicalAsset `json:"technical_asset"`
}

func (t TechnicalAssetLink) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(t.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(t.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if v, ok := any(t.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(t.TechnicalAsset).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAsset", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalAssetOutputPortPendingAction struct {
	ID                uuid.UUID      `json:"id" validate:"required"`
	OutputPortID      uuid.UUID      `json:"output_port_id" validate:"required"`
	TechnicalAssetID  uuid.UUID      `json:"technical_asset_id" validate:"required"`
	Status            DecisionStatus `json:"status" validate:"required"`
	RequestedOn       time.Time      `json:"requested_on" validate:"required"`
	DeniedOn          time.Time      `json:"denied_on"`
	ApprovedOn        time.Time      `json:"approved_on"`
	RequestedBy       User           `json:"requested_by"`
	DeniedBy          User           `json:"denied_by"`
	ApprovedBy        User           `json:"approved_by"`
	PendingActionType *string        `json:"pending_action_type,omitempty"`
}

func (t TechnicalAssetOutputPortPendingAction) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(t.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(t.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if v, ok := any(t.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if err := typesValidator.Var(t.RequestedOn, "required"); err != nil {
		errors = errors.Append("RequestedOn", err)
	}
	if v, ok := any(t.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(t.DeniedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DeniedBy", err)
		}
	}
	if v, ok := any(t.ApprovedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ApprovedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalInfo struct {
	EnvironmentID uuid.UUID `json:"environment_id" validate:"required"`
	Environment   string    `json:"environment" validate:"required"`
	Info          string    `json:"info"`
}

func (t TechnicalInfo) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.EnvironmentID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("EnvironmentID", err)
		}
	}
	if err := typesValidator.Var(t.Environment, "required"); err != nil {
		errors = errors.Append("Environment", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ThemeSettings struct {
	PortalName string `json:"portal_name" validate:"required"`
}

func (t ThemeSettings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type UIElementCheckbox struct {
	InitialValue *bool `json:"initial_value,omitempty"`
}

type UIElementMetadata struct {
	Label                            string             `json:"label" validate:"required"`
	Type                             UIElementType      `json:"type" validate:"required"`
	Required                         bool               `json:"required"`
	Name                             string             `json:"name" validate:"required"`
	Tooltip                          *string            `json:"tooltip,omitempty"`
	Hidden                           *bool              `json:"hidden,omitempty"`
	Checkbox                         *UIElementCheckbox `json:"checkbox,omitempty"`
	Select                           *UIElementSelect   `json:"select,omitempty"`
	String                           *UIElementString   `json:"string,omitempty"`
	Radio                            *UIElementRadio    `json:"radio,omitempty"`
	DependsOn                        []FieldDependency  `json:"depends_on,omitempty"`
	Disabled                         *bool              `json:"disabled,omitempty"`
	UseNamespaceWhenNotSourceAligned *bool              `json:"use_namespace_when_not_source_aligned,omitempty"`
}

func (u UIElementMetadata) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(u.Label, "required"); err != nil {
		errors = errors.Append("Label", err)
	}
	if v, ok := any(u.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(u.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if u.Checkbox != nil {
		if v, ok := any(u.Checkbox).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Checkbox", err)
			}
		}
	}
	if u.Select != nil {
		if v, ok := any(u.Select).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Select", err)
			}
		}
	}
	if u.String != nil {
		if v, ok := any(u.String).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("String", err)
			}
		}
	}
	if u.Radio != nil {
		if v, ok := any(u.Radio).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Radio", err)
			}
		}
	}
	for i, item := range u.DependsOn {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DependsOn[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UIElementMetadataResponse struct {
	NotConfigured  *bool               `json:"not_configured,omitempty"`
	UIMetadata     []UIElementMetadata `json:"ui_metadata" validate:"required"`
	Plugin         string              `json:"plugin" validate:"required"`
	ResultLabel    *string             `json:"result_label,omitempty"`
	ResultTooltip  *string             `json:"result_tooltip,omitempty"`
	Platform       string              `json:"platform" validate:"required"`
	DisplayName    string              `json:"display_name" validate:"required"`
	IconName       string              `json:"icon_name" validate:"required"`
	ParentPlatform *string             `json:"parent_platform,omitempty"`
	PlatformTile   *PlatformTile       `json:"platform_tile,omitempty"`
	DetailedName   string              `json:"detailed_name" validate:"required"`
}

func (u UIElementMetadataResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.UIMetadata {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("UIMetadata[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(u.Plugin, "required"); err != nil {
		errors = errors.Append("Plugin", err)
	}
	if err := typesValidator.Var(u.Platform, "required"); err != nil {
		errors = errors.Append("Platform", err)
	}
	if err := typesValidator.Var(u.DisplayName, "required"); err != nil {
		errors = errors.Append("DisplayName", err)
	}
	if err := typesValidator.Var(u.IconName, "required"); err != nil {
		errors = errors.Append("IconName", err)
	}
	if u.PlatformTile != nil {
		if v, ok := any(u.PlatformTile).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PlatformTile", err)
			}
		}
	}
	if err := typesValidator.Var(u.DetailedName, "required"); err != nil {
		errors = errors.Append("DetailedName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UIElementRadio struct {
	MaxCount     *int           `json:"max_count,omitempty"`
	InitialValue *string        `json:"initial_value,omitempty"`
	Options      []SelectOption `json:"options,omitempty"`
}

func (u UIElementRadio) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.Options {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Options[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UIElementSelect struct {
	MaxCount *int           `json:"max_count,omitempty"`
	Options  []SelectOption `json:"options,omitempty"`
}

func (u UIElementSelect) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.Options {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Options[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UIElementString struct {
	InitialValue *string `json:"initial_value,omitempty"`
}

type UnLinkTechnicalAssetToOutputPortRequest struct {
	TechnicalAssetID uuid.UUID `json:"technical_asset_id" validate:"required"`
}

func (u UnLinkTechnicalAssetToOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductLifeCycleResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductLifeCycleResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductSettingResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductSettingResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductTypeResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductTypeResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDomainResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDomainResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortQueryStatus struct {
	OutputPortQueryStatsUpdates []OutputPortQueryStatsUpdate `json:"output_port_query_stats_updates" validate:"required"`
}

func (u UpdateOutputPortQueryStatus) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.OutputPortQueryStatsUpdates {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortQueryStatsUpdates[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateRole struct {
	Name        *string               `json:"name,omitempty"`
	Description *string               `json:"description,omitempty"`
	Permissions []AuthorizationAction `json:"permissions,omitempty"`
}

func (u UpdateRole) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.Permissions {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Permissions[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateTagResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateTagResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type User struct {
	ID             uuid.UUID     `json:"id" validate:"required"`
	Email          runtime.Email `json:"email" validate:"required"`
	ExternalID     string        `json:"external_id" validate:"required"`
	FirstName      string        `json:"first_name" validate:"required"`
	LastName       string        `json:"last_name" validate:"required"`
	HasSeenTour    bool          `json:"has_seen_tour"`
	CanBecomeAdmin bool          `json:"can_become_admin"`
	AdminExpiry    *time.Time    `json:"admin_expiry,omitempty"`
}

func (u User) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.ExternalID, "required"); err != nil {
		errors = errors.Append("ExternalID", err)
	}
	if err := typesValidator.Var(u.FirstName, "required"); err != nil {
		errors = errors.Append("FirstName", err)
	}
	if err := typesValidator.Var(u.LastName, "required"); err != nil {
		errors = errors.Append("LastName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserCreate struct {
	Email      runtime.Email `json:"email" validate:"required"`
	ExternalID string        `json:"external_id" validate:"required"`
	FirstName  string        `json:"first_name" validate:"required"`
	LastName   string        `json:"last_name" validate:"required"`
}

func (u UserCreate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.ExternalID, "required"); err != nil {
		errors = errors.Append("ExternalID", err)
	}
	if err := typesValidator.Var(u.FirstName, "required"); err != nil {
		errors = errors.Append("FirstName", err)
	}
	if err := typesValidator.Var(u.LastName, "required"); err != nil {
		errors = errors.Append("LastName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserCreateResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UserCreateResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UsersGet struct {
	ID             uuid.UUID                    `json:"id" validate:"required"`
	Email          runtime.Email                `json:"email" validate:"required"`
	ExternalID     string                       `json:"external_id" validate:"required"`
	FirstName      string                       `json:"first_name" validate:"required"`
	LastName       string                       `json:"last_name" validate:"required"`
	HasSeenTour    bool                         `json:"has_seen_tour"`
	CanBecomeAdmin bool                         `json:"can_become_admin"`
	AdminExpiry    *time.Time                   `json:"admin_expiry,omitempty"`
	GlobalRole     GlobalRoleAssignmentResponse `json:"global_role"`
}

func (u UsersGet) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.ExternalID, "required"); err != nil {
		errors = errors.Append("ExternalID", err)
	}
	if err := typesValidator.Var(u.FirstName, "required"); err != nil {
		errors = errors.Append("FirstName", err)
	}
	if err := typesValidator.Var(u.LastName, "required"); err != nil {
		errors = errors.Append("LastName", err)
	}
	if v, ok := any(u.GlobalRole).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("GlobalRole", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError struct {
	Loc  ValidationError_Loc `json:"loc" validate:"required"`
	Msg  string              `json:"msg" validate:"required"`
	Type string              `json:"type" validate:"required"`
}

func (v ValidationError) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(v.Loc).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Loc", err)
		}
	}
	if err := typesValidator.Var(v.Msg, "required"); err != nil {
		errors = errors.Append("Msg", err)
	}
	if err := typesValidator.Var(v.Type, "required"); err != nil {
		errors = errors.Append("Type", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError_Loc []ValidationError_Loc_Item

func (v ValidationError_Loc) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range v {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError_Loc_Item struct {
	ValidationError_Loc_AnyOf *ValidationError_Loc_AnyOf `json:"-"`
}

func (v ValidationError_Loc_Item) Validate() error {
	var errors runtime.ValidationErrors
	if v.ValidationError_Loc_AnyOf != nil {
		if v, ok := any(v.ValidationError_Loc_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("ValidationError_Loc_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (v ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(v.ValidationError_Loc_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("ValidationError_Loc_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (v *ValidationError_Loc_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if v.ValidationError_Loc_AnyOf == nil {
		v.ValidationError_Loc_AnyOf = &ValidationError_Loc_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, v.ValidationError_Loc_AnyOf); err != nil {
		return fmt.Errorf("ValidationError_Loc_AnyOf unmarshal: %w", err)
	}

	return nil
}

type AppAuthorizationRoleAssignmentsDataProductSchemaListRoleAssignmentsResponse struct {
	RoleAssignments []DataProductRoleAssignmentResponse `json:"role_assignments" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaListRoleAssignmentsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range a.RoleAssignments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RoleAssignments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignment struct {
	ID            uuid.UUID      `json:"id" validate:"required"`
	DataProduct   DataProduct    `json:"data_product"`
	User          User           `json:"user"`
	Role          Role           `json:"role"`
	Decision      DecisionStatus `json:"decision" validate:"required"`
	RequestedOn   time.Time      `json:"requested_on"`
	RequestedBy   User           `json:"requested_by"`
	DecidedOn     time.Time      `json:"decided_on"`
	DecidedBy     User           `json:"decided_by"`
	DataProductID uuid.UUID      `json:"data_product_id" validate:"required"`
	UserID        uuid.UUID      `json:"user_id" validate:"required"`
	RoleID        uuid.UUID      `json:"role_id"`
	RequestedByID uuid.UUID      `json:"requested_by_id"`
	DecidedByID   uuid.UUID      `json:"decided_by_id"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(a.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(a.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(a.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(a.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(a.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if v, ok := any(a.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.RequestedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedByID", err)
		}
	}
	if v, ok := any(a.DecidedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedByID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsGlobalSchemaListRoleAssignmentsResponse struct {
	RoleAssignments []GlobalRoleAssignmentResponse `json:"role_assignments" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaListRoleAssignmentsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range a.RoleAssignments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RoleAssignments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaListRoleAssignmentsResponse struct {
	RoleAssignments []OutputPortRoleAssignmentResponse `json:"role_assignments" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaListRoleAssignmentsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range a.RoleAssignments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RoleAssignments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignment struct {
	ID            uuid.UUID      `json:"id" validate:"required"`
	OutputPort    OutputPort     `json:"output_port"`
	User          User           `json:"user"`
	Role          Role           `json:"role"`
	Decision      DecisionStatus `json:"decision" validate:"required"`
	RequestedOn   time.Time      `json:"requested_on"`
	RequestedBy   User           `json:"requested_by"`
	DecidedOn     time.Time      `json:"decided_on"`
	DecidedBy     User           `json:"decided_by"`
	OutputPortID  uuid.UUID      `json:"output_port_id" validate:"required"`
	UserID        uuid.UUID      `json:"user_id" validate:"required"`
	RoleID        uuid.UUID      `json:"role_id"`
	RequestedByID uuid.UUID      `json:"requested_by_id"`
	DecidedByID   uuid.UUID      `json:"decided_by_id"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(a.OutputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPort", err)
		}
	}
	if v, ok := any(a.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(a.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(a.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(a.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if v, ok := any(a.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.RequestedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedByID", err)
		}
	}
	if v, ok := any(a.DecidedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedByID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateGlobalRoleAssignment_RoleID_AnyOf_0 = uuid.UUID

type Edge_ID_AnyOf_1 = uuid.UUID

type Edge_Source_AnyOf_1 = uuid.UUID

type Edge_Target_AnyOf_1 = uuid.UUID

type ModifyGlobalRoleAssignment_RoleID_AnyOf_0 = uuid.UUID

type Node_ID_AnyOf_1 = uuid.UUID

type NodeData_ID_AnyOf_1 = uuid.UUID

type NodeData_LinkToID_AnyOf_1 = uuid.UUID

type NodeData_DomainID_AnyOf_1 = uuid.UUID

type CreateGlobalRoleAssignment_RoleID_AnyOf struct {
	runtime.Either[CreateGlobalRoleAssignment_RoleID_AnyOf_0, string]
}

func (c *CreateGlobalRoleAssignment_RoleID_AnyOf) Validate() error {
	if c.IsA() {
		if v, ok := any(c.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if c.IsB() {
		if v, ok := any(c.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type CreateTechnicalAssetRequest_Configuration_OneOf struct {
	union json.RawMessage
}

func (c *CreateTechnicalAssetRequest_Configuration_OneOf) Validate() error {
	// NOTE: Validation is not supported for unions with more than 2 elements.
	// Validating would require unmarshaling against each possible type, which is inefficient.
	// Use AsValidated<Type>() methods to validate after retrieving the specific type.
	return nil
}

// Raw returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as bytes
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) Raw() json.RawMessage {
	return c.union
}

// AsS3DataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a S3DataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsS3DataOutput() (S3DataOutput, error) {
	return runtime.UnmarshalAs[S3DataOutput](c.union)
}

// AsValidatedS3DataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated S3DataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedS3DataOutput() (S3DataOutput, error) {
	val, err := c.AsS3DataOutput()
	if err != nil {
		var zero S3DataOutput
		return zero, err
	}
	if err := c.validateS3DataOutput(val); err != nil {
		var zero S3DataOutput
		return zero, err
	}
	return val, nil
}

// FromS3DataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided S3DataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromS3DataOutput(val S3DataOutput) error {
	// Validate before storing
	if err := c.validateS3DataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// AsGlueDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a GlueDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsGlueDataOutput() (GlueDataOutput, error) {
	return runtime.UnmarshalAs[GlueDataOutput](c.union)
}

// AsValidatedGlueDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated GlueDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedGlueDataOutput() (GlueDataOutput, error) {
	val, err := c.AsGlueDataOutput()
	if err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	if err := c.validateGlueDataOutput(val); err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	return val, nil
}

// FromGlueDataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided GlueDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromGlueDataOutput(val GlueDataOutput) error {
	// Validate before storing
	if err := c.validateGlueDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// AsDatabricksDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a DatabricksDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsDatabricksDataOutput() (DatabricksDataOutput, error) {
	return runtime.UnmarshalAs[DatabricksDataOutput](c.union)
}

// AsValidatedDatabricksDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated DatabricksDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedDatabricksDataOutput() (DatabricksDataOutput, error) {
	val, err := c.AsDatabricksDataOutput()
	if err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	if err := c.validateDatabricksDataOutput(val); err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	return val, nil
}

// FromDatabricksDataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided DatabricksDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromDatabricksDataOutput(val DatabricksDataOutput) error {
	// Validate before storing
	if err := c.validateDatabricksDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// AsSnowflakeDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a SnowflakeDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	return runtime.UnmarshalAs[SnowflakeDataOutput](c.union)
}

// AsValidatedSnowflakeDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated SnowflakeDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	val, err := c.AsSnowflakeDataOutput()
	if err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	if err := c.validateSnowflakeDataOutput(val); err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	return val, nil
}

// FromSnowflakeDataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided SnowflakeDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromSnowflakeDataOutput(val SnowflakeDataOutput) error {
	// Validate before storing
	if err := c.validateSnowflakeDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// AsRedshiftDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a RedshiftDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsRedshiftDataOutput() (RedshiftDataOutput, error) {
	return runtime.UnmarshalAs[RedshiftDataOutput](c.union)
}

// AsValidatedRedshiftDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated RedshiftDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedRedshiftDataOutput() (RedshiftDataOutput, error) {
	val, err := c.AsRedshiftDataOutput()
	if err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	if err := c.validateRedshiftDataOutput(val); err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	return val, nil
}

// FromRedshiftDataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided RedshiftDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromRedshiftDataOutput(val RedshiftDataOutput) error {
	// Validate before storing
	if err := c.validateRedshiftDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// validateS3DataOutput validates a S3DataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateS3DataOutput(val S3DataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateGlueDataOutput validates a GlueDataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateGlueDataOutput(val GlueDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateDatabricksDataOutput validates a DatabricksDataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateDatabricksDataOutput(val DatabricksDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateSnowflakeDataOutput validates a SnowflakeDataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateSnowflakeDataOutput(val SnowflakeDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateRedshiftDataOutput validates a RedshiftDataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateRedshiftDataOutput(val RedshiftDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

func (c CreateTechnicalAssetRequest_Configuration_OneOf) discriminator(data []byte) (string, error) {
	var discriminator struct {
		Value string `json:"configuration_type"`
	}
	if err := json.Unmarshal(data, &discriminator); err != nil {
		return "", err
	}
	return discriminator.Value, nil
}

func (c CreateTechnicalAssetRequest_Configuration_OneOf) ValueByDiscriminator() (any, error) {
	discriminator, err := c.discriminator(c.union)
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DatabricksDataOutput":
		return c.AsDatabricksDataOutput()
	case "GlueDataOutput":
		return c.AsGlueDataOutput()
	case "RedshiftDataOutput":
		return c.AsRedshiftDataOutput()
	case "S3DataOutput":
		return c.AsS3DataOutput()
	case "SnowflakeDataOutput":
		return c.AsSnowflakeDataOutput()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (c CreateTechnicalAssetRequest_Configuration_OneOf) MarshalJSON() ([]byte, error) {
	bts, err := c.union.MarshalJSON()

	return bts, err
}

func (c *CreateTechnicalAssetRequest_Configuration_OneOf) UnmarshalJSON(bts []byte) error {
	err := c.union.UnmarshalJSON(bts)

	return err
}

type Edge_ID_AnyOf struct {
	runtime.Either[string, Edge_ID_AnyOf_1]
}

func (e *Edge_ID_AnyOf) Validate() error {
	if e.IsA() {
		if v, ok := any(e.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if e.IsB() {
		if v, ok := any(e.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type Edge_Source_AnyOf struct {
	runtime.Either[string, Edge_Source_AnyOf_1]
}

func (e *Edge_Source_AnyOf) Validate() error {
	if e.IsA() {
		if v, ok := any(e.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if e.IsB() {
		if v, ok := any(e.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type Edge_Target_AnyOf struct {
	runtime.Either[string, Edge_Target_AnyOf_1]
}

func (e *Edge_Target_AnyOf) Validate() error {
	if e.IsA() {
		if v, ok := any(e.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if e.IsB() {
		if v, ok := any(e.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type EnvironmentConfigsGetItem_Config_AnyOf struct {
	union json.RawMessage
}

func (e *EnvironmentConfigsGetItem_Config_AnyOf) Validate() error {
	// NOTE: Validation is not supported for unions with more than 2 elements.
	// Validating would require unmarshaling against each possible type, which is inefficient.
	// Use AsValidated<Type>() methods to validate after retrieving the specific type.
	return nil
}

// Raw returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as bytes
func (e *EnvironmentConfigsGetItem_Config_AnyOf) Raw() json.RawMessage {
	return e.union
}

// AsAWSS3Config returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a AWSS3Config
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsAWSS3Config() (AWSS3Config, error) {
	return runtime.UnmarshalAs[AWSS3Config](e.union)
}

// AsValidatedAWSS3Config returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated AWSS3Config
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedAWSS3Config() (AWSS3Config, error) {
	val, err := e.AsAWSS3Config()
	if err != nil {
		var zero AWSS3Config
		return zero, err
	}
	if err := e.validateAWSS3Config(val); err != nil {
		var zero AWSS3Config
		return zero, err
	}
	return val, nil
}

// FromAWSS3Config overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided AWSS3Config
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromAWSS3Config(val AWSS3Config) error {
	// Validate before storing
	if err := e.validateAWSS3Config(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// AsAWSGlueConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a AWSGlueConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsAWSGlueConfig() (AWSGlueConfig, error) {
	return runtime.UnmarshalAs[AWSGlueConfig](e.union)
}

// AsValidatedAWSGlueConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated AWSGlueConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedAWSGlueConfig() (AWSGlueConfig, error) {
	val, err := e.AsAWSGlueConfig()
	if err != nil {
		var zero AWSGlueConfig
		return zero, err
	}
	if err := e.validateAWSGlueConfig(val); err != nil {
		var zero AWSGlueConfig
		return zero, err
	}
	return val, nil
}

// FromAWSGlueConfig overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided AWSGlueConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromAWSGlueConfig(val AWSGlueConfig) error {
	// Validate before storing
	if err := e.validateAWSGlueConfig(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// AsDatabricksConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a DatabricksConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsDatabricksConfig() (DatabricksConfig, error) {
	return runtime.UnmarshalAs[DatabricksConfig](e.union)
}

// AsValidatedDatabricksConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated DatabricksConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedDatabricksConfig() (DatabricksConfig, error) {
	val, err := e.AsDatabricksConfig()
	if err != nil {
		var zero DatabricksConfig
		return zero, err
	}
	if err := e.validateDatabricksConfig(val); err != nil {
		var zero DatabricksConfig
		return zero, err
	}
	return val, nil
}

// FromDatabricksConfig overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided DatabricksConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromDatabricksConfig(val DatabricksConfig) error {
	// Validate before storing
	if err := e.validateDatabricksConfig(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// AsSnowflakeConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a SnowflakeConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsSnowflakeConfig() (SnowflakeConfig, error) {
	return runtime.UnmarshalAs[SnowflakeConfig](e.union)
}

// AsValidatedSnowflakeConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated SnowflakeConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedSnowflakeConfig() (SnowflakeConfig, error) {
	val, err := e.AsSnowflakeConfig()
	if err != nil {
		var zero SnowflakeConfig
		return zero, err
	}
	if err := e.validateSnowflakeConfig(val); err != nil {
		var zero SnowflakeConfig
		return zero, err
	}
	return val, nil
}

// FromSnowflakeConfig overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided SnowflakeConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromSnowflakeConfig(val SnowflakeConfig) error {
	// Validate before storing
	if err := e.validateSnowflakeConfig(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// AsRedshiftConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a RedshiftConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsRedshiftConfig() (RedshiftConfig, error) {
	return runtime.UnmarshalAs[RedshiftConfig](e.union)
}

// AsValidatedRedshiftConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated RedshiftConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedRedshiftConfig() (RedshiftConfig, error) {
	val, err := e.AsRedshiftConfig()
	if err != nil {
		var zero RedshiftConfig
		return zero, err
	}
	if err := e.validateRedshiftConfig(val); err != nil {
		var zero RedshiftConfig
		return zero, err
	}
	return val, nil
}

// FromRedshiftConfig overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided RedshiftConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromRedshiftConfig(val RedshiftConfig) error {
	// Validate before storing
	if err := e.validateRedshiftConfig(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// validateAWSS3Config validates a AWSS3Config value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateAWSS3Config(val AWSS3Config) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateAWSGlueConfig validates a AWSGlueConfig value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateAWSGlueConfig(val AWSGlueConfig) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateDatabricksConfig validates a DatabricksConfig value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateDatabricksConfig(val DatabricksConfig) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateSnowflakeConfig validates a SnowflakeConfig value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateSnowflakeConfig(val SnowflakeConfig) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateRedshiftConfig validates a RedshiftConfig value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateRedshiftConfig(val RedshiftConfig) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

func (e EnvironmentConfigsGetItem_Config_AnyOf) MarshalJSON() ([]byte, error) {
	bts, err := e.union.MarshalJSON()

	return bts, err
}

func (e *EnvironmentConfigsGetItem_Config_AnyOf) UnmarshalJSON(bts []byte) error {
	err := e.union.UnmarshalJSON(bts)

	return err
}

type EnvironmentPlatformConfigGet_Config_AnyOf struct {
	runtime.Either[AWSEnvironmentPlatformConfiguration, DatabricksEnvironmentPlatformConfiguration]
}

func (e *EnvironmentPlatformConfigGet_Config_AnyOf) Validate() error {
	if e.IsA() {
		if v, ok := any(e.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if e.IsB() {
		if v, ok := any(e.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type GetTechnicalAssetsResponseItem_Configuration_OneOf struct {
	union json.RawMessage
}

func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) Validate() error {
	// NOTE: Validation is not supported for unions with more than 2 elements.
	// Validating would require unmarshaling against each possible type, which is inefficient.
	// Use AsValidated<Type>() methods to validate after retrieving the specific type.
	return nil
}

// Raw returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as bytes
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) Raw() json.RawMessage {
	return g.union
}

// AsS3DataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a S3DataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsS3DataOutput() (S3DataOutput, error) {
	return runtime.UnmarshalAs[S3DataOutput](g.union)
}

// AsValidatedS3DataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated S3DataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedS3DataOutput() (S3DataOutput, error) {
	val, err := g.AsS3DataOutput()
	if err != nil {
		var zero S3DataOutput
		return zero, err
	}
	if err := g.validateS3DataOutput(val); err != nil {
		var zero S3DataOutput
		return zero, err
	}
	return val, nil
}

// FromS3DataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided S3DataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromS3DataOutput(val S3DataOutput) error {
	// Validate before storing
	if err := g.validateS3DataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// AsGlueDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a GlueDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsGlueDataOutput() (GlueDataOutput, error) {
	return runtime.UnmarshalAs[GlueDataOutput](g.union)
}

// AsValidatedGlueDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated GlueDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedGlueDataOutput() (GlueDataOutput, error) {
	val, err := g.AsGlueDataOutput()
	if err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	if err := g.validateGlueDataOutput(val); err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	return val, nil
}

// FromGlueDataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided GlueDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromGlueDataOutput(val GlueDataOutput) error {
	// Validate before storing
	if err := g.validateGlueDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// AsDatabricksDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a DatabricksDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsDatabricksDataOutput() (DatabricksDataOutput, error) {
	return runtime.UnmarshalAs[DatabricksDataOutput](g.union)
}

// AsValidatedDatabricksDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated DatabricksDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedDatabricksDataOutput() (DatabricksDataOutput, error) {
	val, err := g.AsDatabricksDataOutput()
	if err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	if err := g.validateDatabricksDataOutput(val); err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	return val, nil
}

// FromDatabricksDataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided DatabricksDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromDatabricksDataOutput(val DatabricksDataOutput) error {
	// Validate before storing
	if err := g.validateDatabricksDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// AsSnowflakeDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a SnowflakeDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	return runtime.UnmarshalAs[SnowflakeDataOutput](g.union)
}

// AsValidatedSnowflakeDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated SnowflakeDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	val, err := g.AsSnowflakeDataOutput()
	if err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	if err := g.validateSnowflakeDataOutput(val); err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	return val, nil
}

// FromSnowflakeDataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided SnowflakeDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromSnowflakeDataOutput(val SnowflakeDataOutput) error {
	// Validate before storing
	if err := g.validateSnowflakeDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// AsRedshiftDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a RedshiftDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsRedshiftDataOutput() (RedshiftDataOutput, error) {
	return runtime.UnmarshalAs[RedshiftDataOutput](g.union)
}

// AsValidatedRedshiftDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated RedshiftDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedRedshiftDataOutput() (RedshiftDataOutput, error) {
	val, err := g.AsRedshiftDataOutput()
	if err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	if err := g.validateRedshiftDataOutput(val); err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	return val, nil
}

// FromRedshiftDataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided RedshiftDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromRedshiftDataOutput(val RedshiftDataOutput) error {
	// Validate before storing
	if err := g.validateRedshiftDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// validateS3DataOutput validates a S3DataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateS3DataOutput(val S3DataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateGlueDataOutput validates a GlueDataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateGlueDataOutput(val GlueDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateDatabricksDataOutput validates a DatabricksDataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateDatabricksDataOutput(val DatabricksDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateSnowflakeDataOutput validates a SnowflakeDataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateSnowflakeDataOutput(val SnowflakeDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateRedshiftDataOutput validates a RedshiftDataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateRedshiftDataOutput(val RedshiftDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

func (g GetTechnicalAssetsResponseItem_Configuration_OneOf) discriminator(data []byte) (string, error) {
	var discriminator struct {
		Value string `json:"configuration_type"`
	}
	if err := json.Unmarshal(data, &discriminator); err != nil {
		return "", err
	}
	return discriminator.Value, nil
}

func (g GetTechnicalAssetsResponseItem_Configuration_OneOf) ValueByDiscriminator() (any, error) {
	discriminator, err := g.discriminator(g.union)
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DatabricksDataOutput":
		return g.AsDatabricksDataOutput()
	case "GlueDataOutput":
		return g.AsGlueDataOutput()
	case "RedshiftDataOutput":
		return g.AsRedshiftDataOutput()
	case "S3DataOutput":
		return g.AsS3DataOutput()
	case "SnowflakeDataOutput":
		return g.AsSnowflakeDataOutput()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (g GetTechnicalAssetsResponseItem_Configuration_OneOf) MarshalJSON() ([]byte, error) {
	bts, err := g.union.MarshalJSON()

	return bts, err
}

func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) UnmarshalJSON(bts []byte) error {
	err := g.union.UnmarshalJSON(bts)

	return err
}

type ModifyGlobalRoleAssignment_RoleID_AnyOf struct {
	runtime.Either[ModifyGlobalRoleAssignment_RoleID_AnyOf_0, string]
}

func (m *ModifyGlobalRoleAssignment_RoleID_AnyOf) Validate() error {
	if m.IsA() {
		if v, ok := any(m.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if m.IsB() {
		if v, ok := any(m.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type Node_ID_AnyOf struct {
	runtime.Either[string, Node_ID_AnyOf_1]
}

func (n *Node_ID_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type NodeData_ID_AnyOf struct {
	runtime.Either[string, NodeData_ID_AnyOf_1]
}

func (n *NodeData_ID_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type NodeData_LinkToID_AnyOf struct {
	runtime.Either[string, NodeData_LinkToID_AnyOf_1]
}

func (n *NodeData_LinkToID_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type NodeData_DomainID_AnyOf struct {
	runtime.Either[string, NodeData_DomainID_AnyOf_1]
}

func (n *NodeData_DomainID_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type NodeData_Assignments_AnyOf_AnyOf struct {
	runtime.Either[AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignment, AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignment]
}

func (n *NodeData_Assignments_AnyOf_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type PendingActionResponse_PendingActions_AnyOf struct {
	union json.RawMessage
}

func (p *PendingActionResponse_PendingActions_AnyOf) Validate() error {
	// NOTE: Validation is not supported for unions with more than 2 elements.
	// Validating would require unmarshaling against each possible type, which is inefficient.
	// Use AsValidated<Type>() methods to validate after retrieving the specific type.
	return nil
}

// Raw returns the union data inside the PendingActionResponse_PendingActions_AnyOf as bytes
func (p *PendingActionResponse_PendingActions_AnyOf) Raw() json.RawMessage {
	return p.union
}

// AsDataProductOutputPortPendingAction returns the union data inside the PendingActionResponse_PendingActions_AnyOf as a DataProductOutputPortPendingAction
func (p *PendingActionResponse_PendingActions_AnyOf) AsDataProductOutputPortPendingAction() (DataProductOutputPortPendingAction, error) {
	return runtime.UnmarshalAs[DataProductOutputPortPendingAction](p.union)
}

// AsValidatedDataProductOutputPortPendingAction returns the union data inside the PendingActionResponse_PendingActions_AnyOf as a validated DataProductOutputPortPendingAction
func (p *PendingActionResponse_PendingActions_AnyOf) AsValidatedDataProductOutputPortPendingAction() (DataProductOutputPortPendingAction, error) {
	val, err := p.AsDataProductOutputPortPendingAction()
	if err != nil {
		var zero DataProductOutputPortPendingAction
		return zero, err
	}
	if err := p.validateDataProductOutputPortPendingAction(val); err != nil {
		var zero DataProductOutputPortPendingAction
		return zero, err
	}
	return val, nil
}

// FromDataProductOutputPortPendingAction overwrites any union data inside the PendingActionResponse_PendingActions_AnyOf as the provided DataProductOutputPortPendingAction
func (p *PendingActionResponse_PendingActions_AnyOf) FromDataProductOutputPortPendingAction(val DataProductOutputPortPendingAction) error {
	// Validate before storing
	if err := p.validateDataProductOutputPortPendingAction(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	p.union = bts
	return err
}

// AsTechnicalAssetOutputPortPendingAction returns the union data inside the PendingActionResponse_PendingActions_AnyOf as a TechnicalAssetOutputPortPendingAction
func (p *PendingActionResponse_PendingActions_AnyOf) AsTechnicalAssetOutputPortPendingAction() (TechnicalAssetOutputPortPendingAction, error) {
	return runtime.UnmarshalAs[TechnicalAssetOutputPortPendingAction](p.union)
}

// AsValidatedTechnicalAssetOutputPortPendingAction returns the union data inside the PendingActionResponse_PendingActions_AnyOf as a validated TechnicalAssetOutputPortPendingAction
func (p *PendingActionResponse_PendingActions_AnyOf) AsValidatedTechnicalAssetOutputPortPendingAction() (TechnicalAssetOutputPortPendingAction, error) {
	val, err := p.AsTechnicalAssetOutputPortPendingAction()
	if err != nil {
		var zero TechnicalAssetOutputPortPendingAction
		return zero, err
	}
	if err := p.validateTechnicalAssetOutputPortPendingAction(val); err != nil {
		var zero TechnicalAssetOutputPortPendingAction
		return zero, err
	}
	return val, nil
}

// FromTechnicalAssetOutputPortPendingAction overwrites any union data inside the PendingActionResponse_PendingActions_AnyOf as the provided TechnicalAssetOutputPortPendingAction
func (p *PendingActionResponse_PendingActions_AnyOf) FromTechnicalAssetOutputPortPendingAction(val TechnicalAssetOutputPortPendingAction) error {
	// Validate before storing
	if err := p.validateTechnicalAssetOutputPortPendingAction(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	p.union = bts
	return err
}

// AsDataProductRoleAssignmentPendingAction returns the union data inside the PendingActionResponse_PendingActions_AnyOf as a DataProductRoleAssignmentPendingAction
func (p *PendingActionResponse_PendingActions_AnyOf) AsDataProductRoleAssignmentPendingAction() (DataProductRoleAssignmentPendingAction, error) {
	return runtime.UnmarshalAs[DataProductRoleAssignmentPendingAction](p.union)
}

// AsValidatedDataProductRoleAssignmentPendingAction returns the union data inside the PendingActionResponse_PendingActions_AnyOf as a validated DataProductRoleAssignmentPendingAction
func (p *PendingActionResponse_PendingActions_AnyOf) AsValidatedDataProductRoleAssignmentPendingAction() (DataProductRoleAssignmentPendingAction, error) {
	val, err := p.AsDataProductRoleAssignmentPendingAction()
	if err != nil {
		var zero DataProductRoleAssignmentPendingAction
		return zero, err
	}
	if err := p.validateDataProductRoleAssignmentPendingAction(val); err != nil {
		var zero DataProductRoleAssignmentPendingAction
		return zero, err
	}
	return val, nil
}

// FromDataProductRoleAssignmentPendingAction overwrites any union data inside the PendingActionResponse_PendingActions_AnyOf as the provided DataProductRoleAssignmentPendingAction
func (p *PendingActionResponse_PendingActions_AnyOf) FromDataProductRoleAssignmentPendingAction(val DataProductRoleAssignmentPendingAction) error {
	// Validate before storing
	if err := p.validateDataProductRoleAssignmentPendingAction(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	p.union = bts
	return err
}

// validateDataProductOutputPortPendingAction validates a DataProductOutputPortPendingAction value
func (p *PendingActionResponse_PendingActions_AnyOf) validateDataProductOutputPortPendingAction(val DataProductOutputPortPendingAction) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateTechnicalAssetOutputPortPendingAction validates a TechnicalAssetOutputPortPendingAction value
func (p *PendingActionResponse_PendingActions_AnyOf) validateTechnicalAssetOutputPortPendingAction(val TechnicalAssetOutputPortPendingAction) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateDataProductRoleAssignmentPendingAction validates a DataProductRoleAssignmentPendingAction value
func (p *PendingActionResponse_PendingActions_AnyOf) validateDataProductRoleAssignmentPendingAction(val DataProductRoleAssignmentPendingAction) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

func (p PendingActionResponse_PendingActions_AnyOf) MarshalJSON() ([]byte, error) {
	bts, err := p.union.MarshalJSON()

	return bts, err
}

func (p *PendingActionResponse_PendingActions_AnyOf) UnmarshalJSON(bts []byte) error {
	err := p.union.UnmarshalJSON(bts)

	return err
}

type SelectOption_Value_AnyOf struct {
	runtime.Either[string, bool]
}

func (s *SelectOption_Value_AnyOf) Validate() error {
	if s.IsA() {
		if v, ok := any(s.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if s.IsB() {
		if v, ok := any(s.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type TechnicalAsset_Configuration_OneOf struct {
	union json.RawMessage
}

func (t *TechnicalAsset_Configuration_OneOf) Validate() error {
	// NOTE: Validation is not supported for unions with more than 2 elements.
	// Validating would require unmarshaling against each possible type, which is inefficient.
	// Use AsValidated<Type>() methods to validate after retrieving the specific type.
	return nil
}

// Raw returns the union data inside the TechnicalAsset_Configuration_OneOf as bytes
func (t *TechnicalAsset_Configuration_OneOf) Raw() json.RawMessage {
	return t.union
}

// AsS3DataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a S3DataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsS3DataOutput() (S3DataOutput, error) {
	return runtime.UnmarshalAs[S3DataOutput](t.union)
}

// AsValidatedS3DataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated S3DataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedS3DataOutput() (S3DataOutput, error) {
	val, err := t.AsS3DataOutput()
	if err != nil {
		var zero S3DataOutput
		return zero, err
	}
	if err := t.validateS3DataOutput(val); err != nil {
		var zero S3DataOutput
		return zero, err
	}
	return val, nil
}

// FromS3DataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided S3DataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromS3DataOutput(val S3DataOutput) error {
	// Validate before storing
	if err := t.validateS3DataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// AsGlueDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a GlueDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsGlueDataOutput() (GlueDataOutput, error) {
	return runtime.UnmarshalAs[GlueDataOutput](t.union)
}

// AsValidatedGlueDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated GlueDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedGlueDataOutput() (GlueDataOutput, error) {
	val, err := t.AsGlueDataOutput()
	if err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	if err := t.validateGlueDataOutput(val); err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	return val, nil
}

// FromGlueDataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided GlueDataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromGlueDataOutput(val GlueDataOutput) error {
	// Validate before storing
	if err := t.validateGlueDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// AsDatabricksDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a DatabricksDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsDatabricksDataOutput() (DatabricksDataOutput, error) {
	return runtime.UnmarshalAs[DatabricksDataOutput](t.union)
}

// AsValidatedDatabricksDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated DatabricksDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedDatabricksDataOutput() (DatabricksDataOutput, error) {
	val, err := t.AsDatabricksDataOutput()
	if err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	if err := t.validateDatabricksDataOutput(val); err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	return val, nil
}

// FromDatabricksDataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided DatabricksDataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromDatabricksDataOutput(val DatabricksDataOutput) error {
	// Validate before storing
	if err := t.validateDatabricksDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// AsSnowflakeDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a SnowflakeDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	return runtime.UnmarshalAs[SnowflakeDataOutput](t.union)
}

// AsValidatedSnowflakeDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated SnowflakeDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	val, err := t.AsSnowflakeDataOutput()
	if err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	if err := t.validateSnowflakeDataOutput(val); err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	return val, nil
}

// FromSnowflakeDataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided SnowflakeDataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromSnowflakeDataOutput(val SnowflakeDataOutput) error {
	// Validate before storing
	if err := t.validateSnowflakeDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// AsRedshiftDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a RedshiftDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsRedshiftDataOutput() (RedshiftDataOutput, error) {
	return runtime.UnmarshalAs[RedshiftDataOutput](t.union)
}

// AsValidatedRedshiftDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated RedshiftDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedRedshiftDataOutput() (RedshiftDataOutput, error) {
	val, err := t.AsRedshiftDataOutput()
	if err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	if err := t.validateRedshiftDataOutput(val); err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	return val, nil
}

// FromRedshiftDataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided RedshiftDataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromRedshiftDataOutput(val RedshiftDataOutput) error {
	// Validate before storing
	if err := t.validateRedshiftDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// validateS3DataOutput validates a S3DataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateS3DataOutput(val S3DataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateGlueDataOutput validates a GlueDataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateGlueDataOutput(val GlueDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateDatabricksDataOutput validates a DatabricksDataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateDatabricksDataOutput(val DatabricksDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateSnowflakeDataOutput validates a SnowflakeDataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateSnowflakeDataOutput(val SnowflakeDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateRedshiftDataOutput validates a RedshiftDataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateRedshiftDataOutput(val RedshiftDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

func (t TechnicalAsset_Configuration_OneOf) discriminator(data []byte) (string, error) {
	var discriminator struct {
		Value string `json:"configuration_type"`
	}
	if err := json.Unmarshal(data, &discriminator); err != nil {
		return "", err
	}
	return discriminator.Value, nil
}

func (t TechnicalAsset_Configuration_OneOf) ValueByDiscriminator() (any, error) {
	discriminator, err := t.discriminator(t.union)
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DatabricksDataOutput":
		return t.AsDatabricksDataOutput()
	case "GlueDataOutput":
		return t.AsGlueDataOutput()
	case "RedshiftDataOutput":
		return t.AsRedshiftDataOutput()
	case "S3DataOutput":
		return t.AsS3DataOutput()
	case "SnowflakeDataOutput":
		return t.AsSnowflakeDataOutput()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TechnicalAsset_Configuration_OneOf) MarshalJSON() ([]byte, error) {
	bts, err := t.union.MarshalJSON()

	return bts, err
}

func (t *TechnicalAsset_Configuration_OneOf) UnmarshalJSON(bts []byte) error {
	err := t.union.UnmarshalJSON(bts)

	return err
}

type ValidationError_Loc_AnyOf struct {
	runtime.Either[string, int]
}

func (v *ValidationError_Loc_AnyOf) Validate() error {
	if v.IsA() {
		if v, ok := any(v.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if v.IsB() {
		if v, ok := any(v.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
