// Code generated by oapi-codegen. DO NOT EDIT.

package portalsdk

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
)

// Client is the client for the API implementing the Client interface.
type Client struct {
	apiClient runtime.APIClient
}

// NewClient creates a new instance of the Client client.
func NewClient(apiClient runtime.APIClient) *Client {
	return &Client{apiClient: apiClient}
}

// NewDefaultClient creates a new instance of the Client client with default api client.
func NewDefaultClient(baseURL string, opts ...runtime.APIClientOption) (*Client, error) {
	apiClient, err := runtime.NewAPIClient(baseURL, opts...)
	if err != nil {
		return nil, fmt.Errorf("error creating API client: %w", err)
	}
	return &Client{apiClient: apiClient}, nil
}

// ClientInterface is the interface for the API client.
type ClientInterface interface {
	// CheckAccess Check Access
	CheckAccess(ctx context.Context, options *CheckAccessRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CheckAccessResponse, error)

	// IsAdmin Is Admin
	IsAdmin(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*IsAdminResponseJSON, error)

	// SearchOutputPorts Search Output Ports
	SearchOutputPorts(ctx context.Context, options *SearchOutputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SearchOutputPortsResponseJSON, error)

	// GetOutputPortQueryStats Get Output Port Query Stats
	GetOutputPortQueryStats(ctx context.Context, options *GetOutputPortQueryStatsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortQueryStatsResponse, error)

	// UpdateOutputPortQueryStats Update Output Port Query Stats
	UpdateOutputPortQueryStats(ctx context.Context, options *UpdateOutputPortQueryStatsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortQueryStatsResponse, error)

	// DeleteOutputPortQueryStat Delete Output Port Query Stat
	DeleteOutputPortQueryStat(ctx context.Context, options *DeleteOutputPortQueryStatRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteOutputPortQueryStatResponse, error)

	// GetOutputPortCuratedQueries Get Output Port Curated Queries
	GetOutputPortCuratedQueries(ctx context.Context, options *GetOutputPortCuratedQueriesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortCuratedQueriesResponse, error)

	// ReplaceOutputPortCuratedQueries Replace Output Port Curated Queries
	ReplaceOutputPortCuratedQueries(ctx context.Context, options *ReplaceOutputPortCuratedQueriesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ReplaceOutputPortCuratedQueriesResponse, error)

	// GetDataProductOutputPorts Get Data Product Output Ports
	GetDataProductOutputPorts(ctx context.Context, options *GetDataProductOutputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductOutputPortsResponseJSON, error)

	// CreateOutputPort Create Output Port
	CreateOutputPort(ctx context.Context, options *CreateOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateOutputPortResponseJSON, error)

	// GetOutputPort Get Output Port
	GetOutputPort(ctx context.Context, options *GetOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortResponseJSON, error)

	// RemoveDataset Remove Dataset
	RemoveDataset(ctx context.Context, options *RemoveDatasetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDatasetResponse, error)

	// UpdateOutputPort Update Output Port
	UpdateOutputPort(ctx context.Context, options *UpdateOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortResponseJSON, error)

	// GetEventHistory Get Event History
	GetEventHistory(ctx context.Context, options *GetEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEventHistoryResponseJSON, error)

	// UpdateOutputPortAbout Update Output Port About
	UpdateOutputPortAbout(ctx context.Context, options *UpdateOutputPortAboutRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortAboutResponse, error)

	// UpdateOutputPortStatus Update Output Port Status
	UpdateOutputPortStatus(ctx context.Context, options *UpdateOutputPortStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortStatusResponse, error)

	// GetGraphData Get Graph Data
	GetGraphData(ctx context.Context, options *GetGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetGraphDataResponse, error)

	// SetValueForOutputPort Set Value For Output Port
	SetValueForOutputPort(ctx context.Context, options *SetValueForOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetValueForOutputPortResponse, error)

	// GetDataProductNamespaceSuggestion Get Data Product Namespace Suggestion
	GetDataProductNamespaceSuggestion(ctx context.Context, options *GetDataProductNamespaceSuggestionRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductNamespaceSuggestionResponse, error)

	// ValidateDataProductNamespace Validate Data Product Namespace
	ValidateDataProductNamespace(ctx context.Context, options *ValidateDataProductNamespaceRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ValidateDataProductNamespaceResponse, error)

	// GetDataProductNamespaceLengthLimits Get Data Product Namespace Length Limits
	GetDataProductNamespaceLengthLimits(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductNamespaceLengthLimitsResponse, error)

	// CreateDataProduct Create Data Product
	CreateDataProduct(ctx context.Context, options *CreateDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductResponseJSON, error)

	// GetDataProducts Get Data Products
	GetDataProducts(ctx context.Context, options *GetDataProductsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsResponseJSON, error)

	// RemoveDataProduct Remove Data Product
	RemoveDataProduct(ctx context.Context, options *RemoveDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductResponse, error)

	// UpdateDataProduct Update Data Product
	UpdateDataProduct(ctx context.Context, options *UpdateDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductResponseJSON, error)

	// GetDataProduct Get Data Product
	GetDataProduct(ctx context.Context, options *GetDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductResponseJSON, error)

	// UpdateDataProductAbout Update Data Product About
	UpdateDataProductAbout(ctx context.Context, options *UpdateDataProductAboutRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductAboutResponse, error)

	// UpdateDataProductStatus Update Data Product Status
	UpdateDataProductStatus(ctx context.Context, options *UpdateDataProductStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductStatusResponse, error)

	// UpdateDataProductUsage Update Data Product Usage
	UpdateDataProductUsage(ctx context.Context, options *UpdateDataProductUsageRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductUsageResponse, error)

	// GetGraphData_1 Get Graph Data
	GetGraphData_1(ctx context.Context, options *GetGraphData_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetGraphDataResponseJSON, error)

	// SetValueForDataProduct Set Value For Data Product
	SetValueForDataProduct(ctx context.Context, options *SetValueForDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetValueForDataProductResponse, error)

	// LinkInputPortsToDataProduct Link Input Ports To Data Product
	LinkInputPortsToDataProduct(ctx context.Context, options *LinkInputPortsToDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*LinkInputPortsToDataProductResponse, error)

	// CreateTechnicalAsset Create Technical Asset
	CreateTechnicalAsset(ctx context.Context, options *CreateTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateTechnicalAssetResponseJSON, error)

	// GetSigninURL Get Signin Url
	GetSigninURL(ctx context.Context, options *GetSigninURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSigninURLResponseJSON, error)

	// GetConveyorIdeURL Get Conveyor Ide Url
	GetConveyorIdeURL(ctx context.Context, options *GetConveyorIdeURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetConveyorIdeURLResponseJSON, error)

	// GetDatabricksWorkspaceURL Get Databricks Workspace Url
	GetDatabricksWorkspaceURL(ctx context.Context, options *GetDatabricksWorkspaceURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDatabricksWorkspaceURLResponseJSON, error)

	// GetSnowflakeURL Get Snowflake Url
	GetSnowflakeURL(ctx context.Context, options *GetSnowflakeURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSnowflakeURLResponseJSON, error)

	// GetTechnicalAssets Get Technical Assets
	GetTechnicalAssets(ctx context.Context, options *GetTechnicalAssetsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetsResponseJSON, error)

	// GetDataProductInputPorts Get Data Product Input Ports
	GetDataProductInputPorts(ctx context.Context, options *GetDataProductInputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductInputPortsResponseJSON, error)

	// GetDataProductRolledUpTags Get Data Product Rolled Up Tags
	GetDataProductRolledUpTags(ctx context.Context, options *GetDataProductRolledUpTagsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductRolledUpTagsResponseJSON, error)

	// UnlinkInputPortFromDataProduct Unlink Input Port From Data Product
	UnlinkInputPortFromDataProduct(ctx context.Context, options *UnlinkInputPortFromDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UnlinkInputPortFromDataProductResponse, error)

	// ValidateTechnicalAssetNamespace Validate Technical Asset Namespace
	ValidateTechnicalAssetNamespace(ctx context.Context, options *ValidateTechnicalAssetNamespaceRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ValidateTechnicalAssetNamespaceResponse, error)

	// GetDataProductType Get Data Product Type
	GetDataProductType(ctx context.Context, options *GetDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductTypeResponse, error)

	// UpdateDataProductType Update Data Product Type
	UpdateDataProductType(ctx context.Context, options *UpdateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductTypeResponseJSON, error)

	// RemoveDataProductType Remove Data Product Type
	RemoveDataProductType(ctx context.Context, options *RemoveDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductTypeResponse, error)

	// GetDataProductsTypes Get Data Products Types
	GetDataProductsTypes(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsTypesResponse, error)

	// CreateDataProductType Create Data Product Type
	CreateDataProductType(ctx context.Context, options *CreateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductTypeResponseJSON, error)

	// MigrateDataProductType Migrate Data Product Type
	MigrateDataProductType(ctx context.Context, options *MigrateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*MigrateDataProductTypeResponse, error)

	// GetDataProductsLifecycles Get Data Products Lifecycles
	GetDataProductsLifecycles(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsLifecyclesResponse, error)

	// CreateDataProductLifecycle Create Data Product Lifecycle
	CreateDataProductLifecycle(ctx context.Context, options *CreateDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductLifecycleResponse, error)

	// UpdateDataProductLifecycle Update Data Product Lifecycle
	UpdateDataProductLifecycle(ctx context.Context, options *UpdateDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductLifecycleResponse, error)

	// DeleteDataProductLifecycle Delete Data Product Lifecycle
	DeleteDataProductLifecycle(ctx context.Context, options *DeleteDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteDataProductLifecycleResponse, error)

	// GetDataProductsSettings Get Data Products Settings
	GetDataProductsSettings(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsSettingsResponse, error)

	// CreateDataProductSetting Create Data Product Setting
	CreateDataProductSetting(ctx context.Context, options *CreateDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductSettingResponseJSON, error)

	// GetDataProductSettingsNamespaceSuggestion Get Data Product Settings Namespace Suggestion
	GetDataProductSettingsNamespaceSuggestion(ctx context.Context, options *GetDataProductSettingsNamespaceSuggestionRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductSettingsNamespaceSuggestionResponse, error)

	// ValidateDataProductSettingsNamespace Validate Data Product Settings Namespace
	ValidateDataProductSettingsNamespace(ctx context.Context, options *ValidateDataProductSettingsNamespaceRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ValidateDataProductSettingsNamespaceResponse, error)

	// GetDataProductSettingsNamespaceLengthLimits Get Data Product Settings Namespace Length Limits
	GetDataProductSettingsNamespaceLengthLimits(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductSettingsNamespaceLengthLimitsResponse, error)

	// UpdateDataProductSetting Update Data Product Setting
	UpdateDataProductSetting(ctx context.Context, options *UpdateDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductSettingResponseJSON, error)

	// DeleteDataProductSetting Delete Data Product Setting
	DeleteDataProductSetting(ctx context.Context, options *DeleteDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteDataProductSettingResponse, error)

	// GetTechnicalAsset Get Technical Asset
	GetTechnicalAsset(ctx context.Context, options *GetTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetResponse, error)

	// RemoveTechnicalAsset Remove Technical Asset
	RemoveTechnicalAsset(ctx context.Context, options *RemoveTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveTechnicalAssetResponse, error)

	// GetTechnicalAssetEventHistory Get Technical Asset Event History
	GetTechnicalAssetEventHistory(ctx context.Context, options *GetTechnicalAssetEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetEventHistoryResponse, error)

	// UpdateTechnicalAssetStatus Update Technical Asset Status
	UpdateTechnicalAssetStatus(ctx context.Context, options *UpdateTechnicalAssetStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateTechnicalAssetStatusResponse, error)

	// LinkOutputPortToTechnicalAsset Link Output Port To Technical Asset
	LinkOutputPortToTechnicalAsset(ctx context.Context, options *LinkOutputPortToTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*LinkOutputPortToTechnicalAssetResponse, error)

	// UnlinkOutputPortFromTechnicalAsset Unlink Output Port From Technical Asset
	UnlinkOutputPortFromTechnicalAsset(ctx context.Context, options *UnlinkOutputPortFromTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UnlinkOutputPortFromTechnicalAssetResponse, error)

	// GetGraphData_2 Get Graph Data
	GetGraphData_2(ctx context.Context, options *GetGraphData_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetGraphDataResponseJSON200, error)

	// GetDomains Get Domains
	GetDomains(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDomainsResponseJSON, error)

	// CreateDomain Create Domain
	CreateDomain(ctx context.Context, options *CreateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDomainResponseJSON, error)

	// UpdateDomain Update Domain
	UpdateDomain(ctx context.Context, options *UpdateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDomainResponseJSON, error)

	// RemoveDomain Remove Domain
	RemoveDomain(ctx context.Context, options *RemoveDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDomainResponse, error)

	// GetDomain Get Domain
	GetDomain(ctx context.Context, options *GetDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDomainResponseJSON, error)

	// MigrateDomain Migrate Domain
	MigrateDomain(ctx context.Context, options *MigrateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*MigrateDomainResponse, error)

	// GetEnvironment Get Environment
	GetEnvironment(ctx context.Context, options *GetEnvironmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentResponse, error)

	// GetEnvironmentConfigsByID Get Environment Configs By Id
	GetEnvironmentConfigsByID(ctx context.Context, options *GetEnvironmentConfigsByIDRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentConfigsByIDResponse, error)

	// GetEnvironmentPlatformServiceConfig Get Environment Platform Service Config
	GetEnvironmentPlatformServiceConfig(ctx context.Context, options *GetEnvironmentPlatformServiceConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformServiceConfigResponse, error)

	// GetEnvironmentPlatformConfig Get Environment Platform Config
	GetEnvironmentPlatformConfig(ctx context.Context, options *GetEnvironmentPlatformConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformConfigResponse, error)

	// GetEnvironments Get Environments
	GetEnvironments(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentsResponse, error)

	// GetEnvironmentConfigs Get Environment Configs
	GetEnvironmentConfigs(ctx context.Context, options *GetEnvironmentConfigsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentConfigsResponse, error)

	// GetEnvironmentPlatformServiceConfigForAllEnvs Get Environment Platform Service Config For All Envs
	GetEnvironmentPlatformServiceConfigForAllEnvs(ctx context.Context, options *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformServiceConfigForAllEnvsResponse, error)

	// GetPlatformServiceConfig Get Platform Service Config
	GetPlatformServiceConfig(ctx context.Context, options *GetPlatformServiceConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPlatformServiceConfigResponse, error)

	// GetSinglePlatformServiceConfiguration Get Single Platform Service Configuration
	GetSinglePlatformServiceConfiguration(ctx context.Context, options *GetSinglePlatformServiceConfigurationRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSinglePlatformServiceConfigurationResponse, error)

	// GetAllPlatformServiceConfigurations Get All Platform Service Configurations
	GetAllPlatformServiceConfigurations(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetAllPlatformServiceConfigurationsResponseJSON, error)

	// GetAllPlatforms Get All Platforms
	GetAllPlatforms(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetAllPlatformsResponseJSON, error)

	// GetPlatformServices Get Platform Services
	GetPlatformServices(ctx context.Context, options *GetPlatformServicesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPlatformServicesResponseJSON, error)

	// GetTags Get Tags
	GetTags(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetTagsResponse, error)

	// CreateTag Create Tag
	CreateTag(ctx context.Context, options *CreateTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateTagResponseJSON, error)

	// UpdateTag Update Tag
	UpdateTag(ctx context.Context, options *UpdateTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateTagResponseJSON, error)

	// RemoveTag Remove Tag
	RemoveTag(ctx context.Context, options *RemoveTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveTagResponse, error)

	// RemoveUser Remove User
	RemoveUser(ctx context.Context, options *RemoveUserRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveUserResponse, error)

	// GetUsers Get Users
	GetUsers(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetUsersResponseJSON, error)

	// CreateUser Create User
	CreateUser(ctx context.Context, options *CreateUserRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateUserResponse, error)

	// SetCanBecomeAdmin Set Can Become Admin
	SetCanBecomeAdmin(ctx context.Context, options *SetCanBecomeAdminRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetCanBecomeAdminResponse, error)

	// MarkTourAsSeen Mark Tour As Seen
	MarkTourAsSeen(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*MarkTourAsSeenResponse, error)

	// CreateRole Create Role
	CreateRole(ctx context.Context, options *CreateRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateRoleResponse, error)

	// RemoveRole Remove Role
	RemoveRole(ctx context.Context, options *RemoveRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveRoleResponse, error)

	// UpdateRole Update Role
	UpdateRole(ctx context.Context, options *UpdateRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateRoleResponse, error)

	// GetRoles Get Roles
	GetRoles(ctx context.Context, options *GetRolesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetRolesResponseJSON, error)

	// BecomeAdmin Become Admin
	BecomeAdmin(ctx context.Context, options *BecomeAdminRequestOptions, reqEditors ...runtime.RequestEditorFn) (*BecomeAdminResponse, error)

	// RevokeAdmin Revoke Admin
	RevokeAdmin(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*RevokeAdminResponse, error)

	// CreateAssignment Create Assignment
	CreateAssignment(ctx context.Context, options *CreateAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateAssignmentResponse, error)

	// ListAssignments List Assignments
	ListAssignments(ctx context.Context, options *ListAssignmentsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListAssignmentsResponse, error)

	// DeleteAssignment Delete Assignment
	DeleteAssignment(ctx context.Context, options *DeleteAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteAssignmentResponse, error)

	// DecideAssignment Decide Assignment
	DecideAssignment(ctx context.Context, options *DecideAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideAssignmentResponse, error)

	// ModifyAssignedRole Modify Assigned Role
	ModifyAssignedRole(ctx context.Context, options *ModifyAssignedRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyAssignedRoleResponse, error)

	// DeleteAssignment_1 Delete Assignment
	DeleteAssignment_1(ctx context.Context, options *DeleteAssignment_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteAssignmentResponseJSON, error)

	// ModifyAssignedRole_1 Modify Assigned Role
	ModifyAssignedRole_1(ctx context.Context, options *ModifyAssignedRole_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyAssignedRoleResponseJSON, error)

	// ListAssignments_1 List Assignments
	ListAssignments_1(ctx context.Context, options *ListAssignments_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListAssignmentsResponseJSON, error)

	// CreateAssignment_1 Create Assignment
	CreateAssignment_1(ctx context.Context, options *CreateAssignment_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateAssignmentResponseJSON, error)

	// RequestAssignment Request Assignment
	RequestAssignment(ctx context.Context, options *RequestAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RequestAssignmentResponse, error)

	// DecideAssignment_1 Decide Assignment
	DecideAssignment_1(ctx context.Context, options *DecideAssignment_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideAssignmentResponseJSON, error)

	// DeleteAssignment_2 Delete Assignment
	DeleteAssignment_2(ctx context.Context, options *DeleteAssignment_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteAssignmentResponseJSON200, error)

	// ModifyAssignedRole_2 Modify Assigned Role
	ModifyAssignedRole_2(ctx context.Context, options *ModifyAssignedRole_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyAssignedRoleResponseJSON200, error)

	// ListAssignments_2 List Assignments
	ListAssignments_2(ctx context.Context, options *ListAssignments_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListAssignmentsResponseJSON200, error)

	// CreateAssignment_2 Create Assignment
	CreateAssignment_2(ctx context.Context, options *CreateAssignment_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateAssignmentResponseJSON200, error)

	// RequestAssignment_1 Request Assignment
	RequestAssignment_1(ctx context.Context, options *RequestAssignment_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*RequestAssignmentResponseJSON, error)

	// DecideAssignment_2 Decide Assignment
	DecideAssignment_2(ctx context.Context, options *DecideAssignment_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideAssignmentResponseJSON200, error)

	// GetSettings Get Settings
	GetSettings(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetSettingsResponse, error)

	// UpdateSettings Update Settings
	UpdateSettings(ctx context.Context, options *UpdateSettingsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateSettingsResponse, error)
}

// CheckAccess Check Access
func (c *Client) CheckAccess(ctx context.Context, options *CheckAccessRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CheckAccessResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/access/{action}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CheckAccessResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CheckAccessErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CheckAccessResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/access/{action}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// IsAdmin Is Admin
func (c *Client) IsAdmin(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*IsAdminResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/admin",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*IsAdminResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(IsAdminResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/admin")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// SearchOutputPorts Search Output Ports
func (c *Client) SearchOutputPorts(ctx context.Context, options *SearchOutputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SearchOutputPortsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/search/output_ports",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*SearchOutputPortsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(SearchOutputPortsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(SearchOutputPortsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/search/output_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetOutputPortQueryStats Get Output Port Query Stats
func (c *Client) GetOutputPortQueryStats(ctx context.Context, options *GetOutputPortQueryStatsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortQueryStatsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetOutputPortQueryStatsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetOutputPortQueryStatsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetOutputPortQueryStatsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateOutputPortQueryStats Update Output Port Query Stats
func (c *Client) UpdateOutputPortQueryStats(ctx context.Context, options *UpdateOutputPortQueryStatsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortQueryStatsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats",
		Method:      "PATCH",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateOutputPortQueryStatsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateOutputPortQueryStatsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateOutputPortQueryStatsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteOutputPortQueryStat Delete Output Port Query Stat
func (c *Client) DeleteOutputPortQueryStat(ctx context.Context, options *DeleteOutputPortQueryStatRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteOutputPortQueryStatResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats",
		Method:      "DELETE",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteOutputPortQueryStatResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteOutputPortQueryStatErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteOutputPortQueryStatResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/query_stats")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetOutputPortCuratedQueries Get Output Port Curated Queries
func (c *Client) GetOutputPortCuratedQueries(ctx context.Context, options *GetOutputPortCuratedQueriesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortCuratedQueriesResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/curated_queries",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetOutputPortCuratedQueriesResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetOutputPortCuratedQueriesErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetOutputPortCuratedQueriesResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/curated_queries")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ReplaceOutputPortCuratedQueries Replace Output Port Curated Queries
func (c *Client) ReplaceOutputPortCuratedQueries(ctx context.Context, options *ReplaceOutputPortCuratedQueriesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ReplaceOutputPortCuratedQueriesResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/curated_queries",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ReplaceOutputPortCuratedQueriesResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ReplaceOutputPortCuratedQueriesResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/curated_queries")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductOutputPorts Get Data Product Output Ports
func (c *Client) GetDataProductOutputPorts(ctx context.Context, options *GetDataProductOutputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductOutputPortsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductOutputPortsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductOutputPortsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductOutputPortsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateOutputPort Create Output Port
func (c *Client) CreateOutputPort(ctx context.Context, options *CreateOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateOutputPortResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateOutputPortResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateOutputPortResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetOutputPort Get Output Port
func (c *Client) GetOutputPort(ctx context.Context, options *GetOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetOutputPortResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetOutputPortResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetOutputPortErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetOutputPortResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDataset Remove Dataset
func (c *Client) RemoveDataset(ctx context.Context, options *RemoveDatasetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDatasetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDatasetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDatasetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateOutputPort Update Output Port
func (c *Client) UpdateOutputPort(ctx context.Context, options *UpdateOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateOutputPortResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateOutputPortResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEventHistory Get Event History
func (c *Client) GetEventHistory(ctx context.Context, options *GetEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEventHistoryResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/history",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEventHistoryResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEventHistoryErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEventHistoryResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/history")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateOutputPortAbout Update Output Port About
func (c *Client) UpdateOutputPortAbout(ctx context.Context, options *UpdateOutputPortAboutRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortAboutResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/about",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateOutputPortAboutResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateOutputPortAboutResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/about")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateOutputPortStatus Update Output Port Status
func (c *Client) UpdateOutputPortStatus(ctx context.Context, options *UpdateOutputPortStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateOutputPortStatusResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/status",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateOutputPortStatusResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateOutputPortStatusResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/status")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetGraphData Get Graph Data
func (c *Client) GetGraphData(ctx context.Context, options *GetGraphDataRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetGraphDataResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/graph",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetGraphDataResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetGraphDataErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetGraphDataResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/graph")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// SetValueForOutputPort Set Value For Output Port
func (c *Client) SetValueForOutputPort(ctx context.Context, options *SetValueForOutputPortRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetValueForOutputPortResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/output_ports/{id}/settings/{setting_id}",
		Method:     "POST",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*SetValueForOutputPortResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(SetValueForOutputPortErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(SetValueForOutputPortResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/output_ports/{id}/settings/{setting_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductNamespaceSuggestion Get Data Product Namespace Suggestion
func (c *Client) GetDataProductNamespaceSuggestion(ctx context.Context, options *GetDataProductNamespaceSuggestionRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductNamespaceSuggestionResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/namespace_suggestion",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductNamespaceSuggestionResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductNamespaceSuggestionErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductNamespaceSuggestionResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/namespace_suggestion")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ValidateDataProductNamespace Validate Data Product Namespace
func (c *Client) ValidateDataProductNamespace(ctx context.Context, options *ValidateDataProductNamespaceRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ValidateDataProductNamespaceResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/validate_namespace",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ValidateDataProductNamespaceResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ValidateDataProductNamespaceErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ValidateDataProductNamespaceResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/validate_namespace")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductNamespaceLengthLimits Get Data Product Namespace Length Limits
func (c *Client) GetDataProductNamespaceLengthLimits(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductNamespaceLengthLimitsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/namespace_length_limits",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductNamespaceLengthLimitsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductNamespaceLengthLimitsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/namespace_length_limits")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDataProduct Create Data Product
func (c *Client) CreateDataProduct(ctx context.Context, options *CreateDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDataProductResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDataProductResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProducts Get Data Products
func (c *Client) GetDataProducts(ctx context.Context, options *GetDataProductsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDataProduct Remove Data Product
func (c *Client) RemoveDataProduct(ctx context.Context, options *RemoveDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDataProductResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDataProductResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProduct Update Data Product
func (c *Client) UpdateDataProduct(ctx context.Context, options *UpdateDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProduct Get Data Product
func (c *Client) GetDataProduct(ctx context.Context, options *GetDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductAbout Update Data Product About
func (c *Client) UpdateDataProductAbout(ctx context.Context, options *UpdateDataProductAboutRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductAboutResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/about",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductAboutResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductAboutResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/about")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductStatus Update Data Product Status
func (c *Client) UpdateDataProductStatus(ctx context.Context, options *UpdateDataProductStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductStatusResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/status",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductStatusResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductStatusResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/status")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductUsage Update Data Product Usage
func (c *Client) UpdateDataProductUsage(ctx context.Context, options *UpdateDataProductUsageRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductUsageResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/usage",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductUsageResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateDataProductUsageErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductUsageResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/usage")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetGraphData_1 Get Graph Data
func (c *Client) GetGraphData_1(ctx context.Context, options *GetGraphData_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetGraphDataResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/graph",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetGraphDataResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetGraphDataErrorResponseJSON)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetGraphDataResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/graph")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// SetValueForDataProduct Set Value For Data Product
func (c *Client) SetValueForDataProduct(ctx context.Context, options *SetValueForDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetValueForDataProductResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/settings/{setting_id}",
		Method:     "POST",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*SetValueForDataProductResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(SetValueForDataProductErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(SetValueForDataProductResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/settings/{setting_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// LinkInputPortsToDataProduct Link Input Ports To Data Product
func (c *Client) LinkInputPortsToDataProduct(ctx context.Context, options *LinkInputPortsToDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*LinkInputPortsToDataProductResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/link_input_ports",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*LinkInputPortsToDataProductResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(LinkInputPortsToDataProductResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/link_input_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateTechnicalAsset Create Technical Asset
func (c *Client) CreateTechnicalAsset(ctx context.Context, options *CreateTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateTechnicalAssetResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/technical_asset",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateTechnicalAssetResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateTechnicalAssetErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateTechnicalAssetResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/technical_asset")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetSigninURL Get Signin Url
func (c *Client) GetSigninURL(ctx context.Context, options *GetSigninURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSigninURLResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/signin_url",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetSigninURLResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetSigninURLErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetSigninURLResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/signin_url")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetConveyorIdeURL Get Conveyor Ide Url
func (c *Client) GetConveyorIdeURL(ctx context.Context, options *GetConveyorIdeURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetConveyorIdeURLResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/conveyor_ide_url",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetConveyorIdeURLResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetConveyorIdeURLErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetConveyorIdeURLResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/conveyor_ide_url")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDatabricksWorkspaceURL Get Databricks Workspace Url
func (c *Client) GetDatabricksWorkspaceURL(ctx context.Context, options *GetDatabricksWorkspaceURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDatabricksWorkspaceURLResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/databricks_workspace_url",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDatabricksWorkspaceURLResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDatabricksWorkspaceURLErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDatabricksWorkspaceURLResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/databricks_workspace_url")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetSnowflakeURL Get Snowflake Url
func (c *Client) GetSnowflakeURL(ctx context.Context, options *GetSnowflakeURLRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSnowflakeURLResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/snowflake_url",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetSnowflakeURLResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetSnowflakeURLErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetSnowflakeURLResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/snowflake_url")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetTechnicalAssets Get Technical Assets
func (c *Client) GetTechnicalAssets(ctx context.Context, options *GetTechnicalAssetsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/technical_assets",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetTechnicalAssetsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetTechnicalAssetsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetTechnicalAssetsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/technical_assets")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductInputPorts Get Data Product Input Ports
func (c *Client) GetDataProductInputPorts(ctx context.Context, options *GetDataProductInputPortsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductInputPortsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/input_ports",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductInputPortsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductInputPortsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductInputPortsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/input_ports")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductRolledUpTags Get Data Product Rolled Up Tags
func (c *Client) GetDataProductRolledUpTags(ctx context.Context, options *GetDataProductRolledUpTagsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductRolledUpTagsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/rolled_up_tags",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductRolledUpTagsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductRolledUpTagsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductRolledUpTagsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/rolled_up_tags")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UnlinkInputPortFromDataProduct Unlink Input Port From Data Product
func (c *Client) UnlinkInputPortFromDataProduct(ctx context.Context, options *UnlinkInputPortFromDataProductRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UnlinkInputPortFromDataProductResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/input_ports/{input_port_id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UnlinkInputPortFromDataProductResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UnlinkInputPortFromDataProductResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/input_ports/{input_port_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ValidateTechnicalAssetNamespace Validate Technical Asset Namespace
func (c *Client) ValidateTechnicalAssetNamespace(ctx context.Context, options *ValidateTechnicalAssetNamespaceRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ValidateTechnicalAssetNamespaceResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{id}/technical_asset/validate_namespace",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ValidateTechnicalAssetNamespaceResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ValidateTechnicalAssetNamespaceErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ValidateTechnicalAssetNamespaceResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{id}/technical_asset/validate_namespace")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductType Get Data Product Type
func (c *Client) GetDataProductType(ctx context.Context, options *GetDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductTypeResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductTypeResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductTypeErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductTypeResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductType Update Data Product Type
func (c *Client) UpdateDataProductType(ctx context.Context, options *UpdateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductTypeResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductTypeResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateDataProductTypeErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductTypeResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDataProductType Remove Data Product Type
func (c *Client) RemoveDataProductType(ctx context.Context, options *RemoveDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDataProductTypeResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDataProductTypeResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveDataProductTypeErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDataProductTypeResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductsTypes Get Data Products Types
func (c *Client) GetDataProductsTypes(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsTypesResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductsTypesResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductsTypesResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDataProductType Create Data Product Type
func (c *Client) CreateDataProductType(ctx context.Context, options *CreateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductTypeResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDataProductTypeResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDataProductTypeResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// MigrateDataProductType Migrate Data Product Type
func (c *Client) MigrateDataProductType(ctx context.Context, options *MigrateDataProductTypeRequestOptions, reqEditors ...runtime.RequestEditorFn) (*MigrateDataProductTypeResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_types/migrate/{from_id}/{to_id}",
		Method:     "PUT",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*MigrateDataProductTypeResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(MigrateDataProductTypeErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(MigrateDataProductTypeResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_types/migrate/{from_id}/{to_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductsLifecycles Get Data Products Lifecycles
func (c *Client) GetDataProductsLifecycles(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsLifecyclesResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_lifecycles",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductsLifecyclesResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductsLifecyclesResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_lifecycles")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDataProductLifecycle Create Data Product Lifecycle
func (c *Client) CreateDataProductLifecycle(ctx context.Context, options *CreateDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductLifecycleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_lifecycles",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDataProductLifecycleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDataProductLifecycleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_lifecycles")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductLifecycle Update Data Product Lifecycle
func (c *Client) UpdateDataProductLifecycle(ctx context.Context, options *UpdateDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductLifecycleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_lifecycles/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductLifecycleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductLifecycleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_lifecycles/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteDataProductLifecycle Delete Data Product Lifecycle
func (c *Client) DeleteDataProductLifecycle(ctx context.Context, options *DeleteDataProductLifecycleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteDataProductLifecycleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_lifecycles/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteDataProductLifecycleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteDataProductLifecycleErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteDataProductLifecycleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_lifecycles/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductsSettings Get Data Products Settings
func (c *Client) GetDataProductsSettings(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductsSettingsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductsSettingsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductsSettingsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDataProductSetting Create Data Product Setting
func (c *Client) CreateDataProductSetting(ctx context.Context, options *CreateDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDataProductSettingResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDataProductSettingResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateDataProductSettingErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDataProductSettingResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductSettingsNamespaceSuggestion Get Data Product Settings Namespace Suggestion
func (c *Client) GetDataProductSettingsNamespaceSuggestion(ctx context.Context, options *GetDataProductSettingsNamespaceSuggestionRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDataProductSettingsNamespaceSuggestionResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings/namespace_suggestion",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductSettingsNamespaceSuggestionResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDataProductSettingsNamespaceSuggestionErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductSettingsNamespaceSuggestionResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings/namespace_suggestion")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ValidateDataProductSettingsNamespace Validate Data Product Settings Namespace
func (c *Client) ValidateDataProductSettingsNamespace(ctx context.Context, options *ValidateDataProductSettingsNamespaceRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ValidateDataProductSettingsNamespaceResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings/validate_namespace",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ValidateDataProductSettingsNamespaceResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ValidateDataProductSettingsNamespaceErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ValidateDataProductSettingsNamespaceResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings/validate_namespace")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDataProductSettingsNamespaceLengthLimits Get Data Product Settings Namespace Length Limits
func (c *Client) GetDataProductSettingsNamespaceLengthLimits(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDataProductSettingsNamespaceLengthLimitsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings/namespace_length_limits",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDataProductSettingsNamespaceLengthLimitsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDataProductSettingsNamespaceLengthLimitsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings/namespace_length_limits")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDataProductSetting Update Data Product Setting
func (c *Client) UpdateDataProductSetting(ctx context.Context, options *UpdateDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDataProductSettingResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDataProductSettingResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateDataProductSettingErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDataProductSettingResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteDataProductSetting Delete Data Product Setting
func (c *Client) DeleteDataProductSetting(ctx context.Context, options *DeleteDataProductSettingRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteDataProductSettingResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/data_product_settings/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteDataProductSettingResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteDataProductSettingErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteDataProductSettingResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/data_product_settings/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetTechnicalAsset Get Technical Asset
func (c *Client) GetTechnicalAsset(ctx context.Context, options *GetTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetTechnicalAssetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetTechnicalAssetErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetTechnicalAssetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveTechnicalAsset Remove Technical Asset
func (c *Client) RemoveTechnicalAsset(ctx context.Context, options *RemoveTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveTechnicalAssetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveTechnicalAssetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveTechnicalAssetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetTechnicalAssetEventHistory Get Technical Asset Event History
func (c *Client) GetTechnicalAssetEventHistory(ctx context.Context, options *GetTechnicalAssetEventHistoryRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetTechnicalAssetEventHistoryResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}/history",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetTechnicalAssetEventHistoryResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetTechnicalAssetEventHistoryErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetTechnicalAssetEventHistoryResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}/history")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateTechnicalAssetStatus Update Technical Asset Status
func (c *Client) UpdateTechnicalAssetStatus(ctx context.Context, options *UpdateTechnicalAssetStatusRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateTechnicalAssetStatusResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}/status",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateTechnicalAssetStatusResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateTechnicalAssetStatusResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}/status")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// LinkOutputPortToTechnicalAsset Link Output Port To Technical Asset
func (c *Client) LinkOutputPortToTechnicalAsset(ctx context.Context, options *LinkOutputPortToTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*LinkOutputPortToTechnicalAssetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}/link_output_port",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*LinkOutputPortToTechnicalAssetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(LinkOutputPortToTechnicalAssetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}/link_output_port")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UnlinkOutputPortFromTechnicalAsset Unlink Output Port From Technical Asset
func (c *Client) UnlinkOutputPortFromTechnicalAsset(ctx context.Context, options *UnlinkOutputPortFromTechnicalAssetRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UnlinkOutputPortFromTechnicalAssetResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}/unlink_output_port",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UnlinkOutputPortFromTechnicalAssetResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UnlinkOutputPortFromTechnicalAssetResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}/unlink_output_port")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetGraphData_2 Get Graph Data
func (c *Client) GetGraphData_2(ctx context.Context, options *GetGraphData_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetGraphDataResponseJSON200, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/data_products/{data_product_id}/technical_assets/{id}/graph",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetGraphDataResponseJSON200, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetGraphDataErrorResponseJSON422)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetGraphDataResponseJSON200)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/data_products/{data_product_id}/technical_assets/{id}/graph")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDomains Get Domains
func (c *Client) GetDomains(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetDomainsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/domains",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDomainsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDomainsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateDomain Create Domain
func (c *Client) CreateDomain(ctx context.Context, options *CreateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateDomainResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/domains",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateDomainResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateDomainResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateDomain Update Domain
func (c *Client) UpdateDomain(ctx context.Context, options *UpdateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateDomainResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/domains/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateDomainResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateDomainResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveDomain Remove Domain
func (c *Client) RemoveDomain(ctx context.Context, options *RemoveDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveDomainResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/domains/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveDomainResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveDomainResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetDomain Get Domain
func (c *Client) GetDomain(ctx context.Context, options *GetDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetDomainResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/domains/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetDomainResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetDomainResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// MigrateDomain Migrate Domain
func (c *Client) MigrateDomain(ctx context.Context, options *MigrateDomainRequestOptions, reqEditors ...runtime.RequestEditorFn) (*MigrateDomainResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/domains/migrate/{from_id}/{to_id}",
		Method:     "PUT",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*MigrateDomainResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(MigrateDomainErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(MigrateDomainResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/domains/migrate/{from_id}/{to_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironment Get Environment
func (c *Client) GetEnvironment(ctx context.Context, options *GetEnvironmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/{id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentConfigsByID Get Environment Configs By Id
func (c *Client) GetEnvironmentConfigsByID(ctx context.Context, options *GetEnvironmentConfigsByIDRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentConfigsByIDResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/configs/{config_id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentConfigsByIDResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentConfigsByIDErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentConfigsByIDResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/configs/{config_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentPlatformServiceConfig Get Environment Platform Service Config
func (c *Client) GetEnvironmentPlatformServiceConfig(ctx context.Context, options *GetEnvironmentPlatformServiceConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformServiceConfigResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/{id}/platforms/{platform_id}/services/{service_id}/config",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentPlatformServiceConfigResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentPlatformServiceConfigErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentPlatformServiceConfigResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/{id}/platforms/{platform_id}/services/{service_id}/config")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentPlatformConfig Get Environment Platform Config
func (c *Client) GetEnvironmentPlatformConfig(ctx context.Context, options *GetEnvironmentPlatformConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformConfigResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/{id}/platforms/{platform_id}/config",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentPlatformConfigResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentPlatformConfigErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentPlatformConfigResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/{id}/platforms/{platform_id}/config")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironments Get Environments
func (c *Client) GetEnvironments(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentConfigs Get Environment Configs
func (c *Client) GetEnvironmentConfigs(ctx context.Context, options *GetEnvironmentConfigsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentConfigsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/{id}/configs",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentConfigsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentConfigsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentConfigsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/{id}/configs")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetEnvironmentPlatformServiceConfigForAllEnvs Get Environment Platform Service Config For All Envs
func (c *Client) GetEnvironmentPlatformServiceConfigForAllEnvs(ctx context.Context, options *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetEnvironmentPlatformServiceConfigForAllEnvsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/environments/platforms/{platform_id}/services/{service_id}/config",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetEnvironmentPlatformServiceConfigForAllEnvsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetEnvironmentPlatformServiceConfigForAllEnvsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetEnvironmentPlatformServiceConfigForAllEnvsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/environments/platforms/{platform_id}/services/{service_id}/config")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetPlatformServiceConfig Get Platform Service Config
func (c *Client) GetPlatformServiceConfig(ctx context.Context, options *GetPlatformServiceConfigRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPlatformServiceConfigResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms/{id}/services/{service_id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetPlatformServiceConfigResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetPlatformServiceConfigResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms/{id}/services/{service_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetSinglePlatformServiceConfiguration Get Single Platform Service Configuration
func (c *Client) GetSinglePlatformServiceConfiguration(ctx context.Context, options *GetSinglePlatformServiceConfigurationRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetSinglePlatformServiceConfigurationResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms/configs/{config_id}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetSinglePlatformServiceConfigurationResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetSinglePlatformServiceConfigurationErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetSinglePlatformServiceConfigurationResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms/configs/{config_id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetAllPlatformServiceConfigurations Get All Platform Service Configurations
func (c *Client) GetAllPlatformServiceConfigurations(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetAllPlatformServiceConfigurationsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms/configs",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetAllPlatformServiceConfigurationsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetAllPlatformServiceConfigurationsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms/configs")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetAllPlatforms Get All Platforms
func (c *Client) GetAllPlatforms(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetAllPlatformsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetAllPlatformsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetAllPlatformsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetPlatformServices Get Platform Services
func (c *Client) GetPlatformServices(ctx context.Context, options *GetPlatformServicesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetPlatformServicesResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/platforms/{id}/services",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetPlatformServicesResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetPlatformServicesErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetPlatformServicesResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/platforms/{id}/services")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetTags Get Tags
func (c *Client) GetTags(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetTagsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/tags",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetTagsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetTagsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/tags")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateTag Create Tag
func (c *Client) CreateTag(ctx context.Context, options *CreateTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateTagResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/tags",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateTagResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateTagErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateTagResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/tags")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateTag Update Tag
func (c *Client) UpdateTag(ctx context.Context, options *UpdateTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateTagResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/tags/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateTagResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateTagErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateTagResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/tags/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveTag Remove Tag
func (c *Client) RemoveTag(ctx context.Context, options *RemoveTagRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveTagResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/tags/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveTagResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RemoveTagErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveTagResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/tags/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveUser Remove User
func (c *Client) RemoveUser(ctx context.Context, options *RemoveUserRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveUserResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveUserResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveUserResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetUsers Get Users
func (c *Client) GetUsers(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetUsersResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetUsersResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetUsersResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateUser Create User
func (c *Client) CreateUser(ctx context.Context, options *CreateUserRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateUserResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/users",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateUserResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateUserErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateUserResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// SetCanBecomeAdmin Set Can Become Admin
func (c *Client) SetCanBecomeAdmin(ctx context.Context, options *SetCanBecomeAdminRequestOptions, reqEditors ...runtime.RequestEditorFn) (*SetCanBecomeAdminResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/users/set_can_become_admin",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*SetCanBecomeAdminResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(SetCanBecomeAdminErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(SetCanBecomeAdminResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/set_can_become_admin")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// MarkTourAsSeen Mark Tour As Seen
func (c *Client) MarkTourAsSeen(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*MarkTourAsSeenResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/users/current/seen_tour",
		Method:     "POST",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*MarkTourAsSeenResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(MarkTourAsSeenResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/users/current/seen_tour")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateRole Create Role
func (c *Client) CreateRole(ctx context.Context, options *CreateRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateRoleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/roles",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateRoleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateRoleErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateRoleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/roles")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RemoveRole Remove Role
func (c *Client) RemoveRole(ctx context.Context, options *RemoveRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RemoveRoleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/roles/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RemoveRoleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RemoveRoleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/roles/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateRole Update Role
func (c *Client) UpdateRole(ctx context.Context, options *UpdateRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateRoleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/roles/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateRoleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateRoleErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateRoleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/roles/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetRoles Get Roles
func (c *Client) GetRoles(ctx context.Context, options *GetRolesRequestOptions, reqEditors ...runtime.RequestEditorFn) (*GetRolesResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/roles/{scope}",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetRolesResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(GetRolesErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetRolesResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/roles/{scope}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// BecomeAdmin Become Admin
func (c *Client) BecomeAdmin(ctx context.Context, options *BecomeAdminRequestOptions, reqEditors ...runtime.RequestEditorFn) (*BecomeAdminResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/become_admin",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*BecomeAdminResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(BecomeAdminErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(BecomeAdminResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/become_admin")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RevokeAdmin Revoke Admin
func (c *Client) RevokeAdmin(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*RevokeAdminResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/revoke_admin",
		Method:     "POST",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RevokeAdminResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RevokeAdminResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/revoke_admin")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateAssignment Create Assignment
func (c *Client) CreateAssignment(ctx context.Context, options *CreateAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ListAssignments List Assignments
func (c *Client) ListAssignments(ctx context.Context, options *ListAssignmentsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListAssignmentsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ListAssignmentsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ListAssignmentsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ListAssignmentsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteAssignment Delete Assignment
func (c *Client) DeleteAssignment(ctx context.Context, options *DeleteAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DecideAssignment Decide Assignment
func (c *Client) DecideAssignment(ctx context.Context, options *DecideAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/{id}/decide",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DecideAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DecideAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DecideAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/{id}/decide")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ModifyAssignedRole Modify Assigned Role
func (c *Client) ModifyAssignedRole(ctx context.Context, options *ModifyAssignedRoleRequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyAssignedRoleResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/global/{id}/role",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ModifyAssignedRoleResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ModifyAssignedRoleErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ModifyAssignedRoleResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/global/{id}/role")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteAssignment_1 Delete Assignment
func (c *Client) DeleteAssignment_1(ctx context.Context, options *DeleteAssignment_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteAssignmentResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteAssignmentResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteAssignmentErrorResponseJSON)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteAssignmentResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ModifyAssignedRole_1 Modify Assigned Role
func (c *Client) ModifyAssignedRole_1(ctx context.Context, options *ModifyAssignedRole_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyAssignedRoleResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ModifyAssignedRoleResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ModifyAssignedRoleErrorResponseJSON)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ModifyAssignedRoleResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ListAssignments_1 List Assignments
func (c *Client) ListAssignments_1(ctx context.Context, options *ListAssignments_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListAssignmentsResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ListAssignmentsResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ListAssignmentsErrorResponseJSON)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ListAssignmentsResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateAssignment_1 Create Assignment
func (c *Client) CreateAssignment_1(ctx context.Context, options *CreateAssignment_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateAssignmentResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateAssignmentResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateAssignmentErrorResponseJSON)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateAssignmentResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RequestAssignment Request Assignment
func (c *Client) RequestAssignment(ctx context.Context, options *RequestAssignmentRequestOptions, reqEditors ...runtime.RequestEditorFn) (*RequestAssignmentResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product/request",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RequestAssignmentResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RequestAssignmentErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RequestAssignmentResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product/request")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DecideAssignment_1 Decide Assignment
func (c *Client) DecideAssignment_1(ctx context.Context, options *DecideAssignment_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideAssignmentResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/data_product/{id}/decide",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DecideAssignmentResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DecideAssignmentErrorResponseJSON)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DecideAssignmentResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/data_product/{id}/decide")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DeleteAssignment_2 Delete Assignment
func (c *Client) DeleteAssignment_2(ctx context.Context, options *DeleteAssignment_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*DeleteAssignmentResponseJSON200, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port/{id}",
		Method:     "DELETE",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DeleteAssignmentResponseJSON200, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DeleteAssignmentErrorResponseJSON422)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DeleteAssignmentResponseJSON200)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ModifyAssignedRole_2 Modify Assigned Role
func (c *Client) ModifyAssignedRole_2(ctx context.Context, options *ModifyAssignedRole_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*ModifyAssignedRoleResponseJSON200, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port/{id}",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ModifyAssignedRoleResponseJSON200, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ModifyAssignedRoleErrorResponseJSON422)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ModifyAssignedRoleResponseJSON200)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port/{id}")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// ListAssignments_2 List Assignments
func (c *Client) ListAssignments_2(ctx context.Context, options *ListAssignments_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*ListAssignmentsResponseJSON200, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port",
		Method:     "GET",
		Options:    options,
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*ListAssignmentsResponseJSON200, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(ListAssignmentsErrorResponseJSON422)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(ListAssignmentsResponseJSON200)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// CreateAssignment_2 Create Assignment
func (c *Client) CreateAssignment_2(ctx context.Context, options *CreateAssignment_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*CreateAssignmentResponseJSON200, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*CreateAssignmentResponseJSON200, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(CreateAssignmentErrorResponseJSON422)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(CreateAssignmentResponseJSON200)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// RequestAssignment_1 Request Assignment
func (c *Client) RequestAssignment_1(ctx context.Context, options *RequestAssignment_1RequestOptions, reqEditors ...runtime.RequestEditorFn) (*RequestAssignmentResponseJSON, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port/request",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*RequestAssignmentResponseJSON, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(RequestAssignmentErrorResponseJSON)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(RequestAssignmentResponseJSON)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port/request")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// DecideAssignment_2 Decide Assignment
func (c *Client) DecideAssignment_2(ctx context.Context, options *DecideAssignment_2RequestOptions, reqEditors ...runtime.RequestEditorFn) (*DecideAssignmentResponseJSON200, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/authz/role_assignments/output_port/{id}/decide",
		Method:      "POST",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*DecideAssignmentResponseJSON200, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(DecideAssignmentErrorResponseJSON422)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(DecideAssignmentResponseJSON200)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/authz/role_assignments/output_port/{id}/decide")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// GetSettings Get Settings
func (c *Client) GetSettings(ctx context.Context, reqEditors ...runtime.RequestEditorFn) (*GetSettingsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL: c.apiClient.GetBaseURL() + "/api/v2/configuration/theme_settings",
		Method:     "GET",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*GetSettingsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(GetSettingsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/theme_settings")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

// UpdateSettings Update Settings
func (c *Client) UpdateSettings(ctx context.Context, options *UpdateSettingsRequestOptions, reqEditors ...runtime.RequestEditorFn) (*UpdateSettingsResponse, error) {
	var err error
	reqParams := runtime.RequestOptionsParameters{
		RequestURL:  c.apiClient.GetBaseURL() + "/api/v2/configuration/theme_settings",
		Method:      "PUT",
		Options:     options,
		ContentType: "application/json",
	}

	req, err := c.apiClient.CreateRequest(ctx, reqParams, reqEditors...)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	responseParser := func(ctx context.Context, resp *runtime.Response) (*UpdateSettingsResponse, error) {
		bodyBytes := resp.Content
		if resp.StatusCode != 200 {
			target := new(UpdateSettingsErrorResponse)
			err = json.Unmarshal(bodyBytes, target)
			if err != nil {
				return nil, fmt.Errorf("error decoding response: %w", err)
			}

			if errTarget, ok := any(*target).(error); ok {
				return nil, runtime.NewClientAPIError(errTarget, runtime.WithStatusCode(resp.StatusCode))
			}
			return nil, runtime.NewClientAPIError(fmt.Errorf("API error (status %d): %v", resp.StatusCode, *target),
				runtime.WithStatusCode(resp.StatusCode))
		}
		target := new(UpdateSettingsResponse)
		if err = json.Unmarshal(bodyBytes, target); err != nil {
			err = fmt.Errorf("error decoding response: %w", err)
			return nil, err
		}
		return target, nil
	}

	resp, err := c.apiClient.ExecuteRequest(ctx, req, "/api/v2/configuration/theme_settings")
	if err != nil {
		return nil, fmt.Errorf("error executing request: %w", err)
	}
	return responseParser(ctx, resp)
}

var _ ClientInterface = (*Client)(nil)

// CheckAccessRequestOptions is the options needed to make a request to CheckAccess.
type CheckAccessRequestOptions struct {
	PathParams *CheckAccessPath
	Query      *CheckAccessQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CheckAccessRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CheckAccessRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *CheckAccessRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CheckAccessRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *CheckAccessRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// SearchOutputPortsRequestOptions is the options needed to make a request to SearchOutputPorts.
type SearchOutputPortsRequestOptions struct {
	Query *SearchOutputPortsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *SearchOutputPortsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *SearchOutputPortsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *SearchOutputPortsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *SearchOutputPortsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *SearchOutputPortsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetOutputPortQueryStatsRequestOptions is the options needed to make a request to GetOutputPortQueryStats.
type GetOutputPortQueryStatsRequestOptions struct {
	PathParams *GetOutputPortQueryStatsPath
	Query      *GetOutputPortQueryStatsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetOutputPortQueryStatsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetOutputPortQueryStatsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetOutputPortQueryStatsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetOutputPortQueryStatsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetOutputPortQueryStatsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateOutputPortQueryStatsRequestOptions is the options needed to make a request to UpdateOutputPortQueryStats.
type UpdateOutputPortQueryStatsRequestOptions struct {
	PathParams *UpdateOutputPortQueryStatsPath
	Body       *UpdateOutputPortQueryStatsBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateOutputPortQueryStatsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateOutputPortQueryStatsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateOutputPortQueryStatsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateOutputPortQueryStatsRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateOutputPortQueryStatsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteOutputPortQueryStatRequestOptions is the options needed to make a request to DeleteOutputPortQueryStat.
type DeleteOutputPortQueryStatRequestOptions struct {
	PathParams *DeleteOutputPortQueryStatPath
	Body       *DeleteOutputPortQueryStatBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteOutputPortQueryStatRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteOutputPortQueryStatRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteOutputPortQueryStatRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteOutputPortQueryStatRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DeleteOutputPortQueryStatRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetOutputPortCuratedQueriesRequestOptions is the options needed to make a request to GetOutputPortCuratedQueries.
type GetOutputPortCuratedQueriesRequestOptions struct {
	PathParams *GetOutputPortCuratedQueriesPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetOutputPortCuratedQueriesRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetOutputPortCuratedQueriesRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetOutputPortCuratedQueriesRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetOutputPortCuratedQueriesRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetOutputPortCuratedQueriesRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ReplaceOutputPortCuratedQueriesRequestOptions is the options needed to make a request to ReplaceOutputPortCuratedQueries.
type ReplaceOutputPortCuratedQueriesRequestOptions struct {
	PathParams *ReplaceOutputPortCuratedQueriesPath
	Body       *ReplaceOutputPortCuratedQueriesBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ReplaceOutputPortCuratedQueriesRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductOutputPortsRequestOptions is the options needed to make a request to GetDataProductOutputPorts.
type GetDataProductOutputPortsRequestOptions struct {
	PathParams *GetDataProductOutputPortsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductOutputPortsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductOutputPortsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductOutputPortsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductOutputPortsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductOutputPortsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateOutputPortRequestOptions is the options needed to make a request to CreateOutputPort.
type CreateOutputPortRequestOptions struct {
	PathParams *CreateOutputPortPath
	Body       *CreateOutputPortBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateOutputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateOutputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *CreateOutputPortRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateOutputPortRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateOutputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetOutputPortRequestOptions is the options needed to make a request to GetOutputPort.
type GetOutputPortRequestOptions struct {
	PathParams *GetOutputPortPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetOutputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetOutputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetOutputPortRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetOutputPortRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetOutputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDatasetRequestOptions is the options needed to make a request to RemoveDataset.
type RemoveDatasetRequestOptions struct {
	PathParams *RemoveDatasetPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDatasetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDatasetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDatasetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDatasetRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDatasetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateOutputPortRequestOptions is the options needed to make a request to UpdateOutputPort.
type UpdateOutputPortRequestOptions struct {
	PathParams *UpdateOutputPortPath
	Body       *UpdateOutputPortBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateOutputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateOutputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateOutputPortRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateOutputPortRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateOutputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEventHistoryRequestOptions is the options needed to make a request to GetEventHistory.
type GetEventHistoryRequestOptions struct {
	PathParams *GetEventHistoryPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEventHistoryRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEventHistoryRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEventHistoryRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEventHistoryRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEventHistoryRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateOutputPortAboutRequestOptions is the options needed to make a request to UpdateOutputPortAbout.
type UpdateOutputPortAboutRequestOptions struct {
	PathParams *UpdateOutputPortAboutPath
	Body       *UpdateOutputPortAboutBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateOutputPortAboutRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateOutputPortAboutRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateOutputPortAboutRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateOutputPortAboutRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateOutputPortAboutRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateOutputPortStatusRequestOptions is the options needed to make a request to UpdateOutputPortStatus.
type UpdateOutputPortStatusRequestOptions struct {
	PathParams *UpdateOutputPortStatusPath
	Body       *UpdateOutputPortStatusBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateOutputPortStatusRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateOutputPortStatusRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateOutputPortStatusRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateOutputPortStatusRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateOutputPortStatusRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetGraphDataRequestOptions is the options needed to make a request to GetGraphData.
type GetGraphDataRequestOptions struct {
	PathParams *GetGraphDataPath
	Query      *GetGraphDataQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetGraphDataRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetGraphDataRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetGraphDataRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetGraphDataRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetGraphDataRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// SetValueForOutputPortRequestOptions is the options needed to make a request to SetValueForOutputPort.
type SetValueForOutputPortRequestOptions struct {
	PathParams *SetValueForOutputPortPath
	Query      *SetValueForOutputPortQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *SetValueForOutputPortRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *SetValueForOutputPortRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *SetValueForOutputPortRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *SetValueForOutputPortRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *SetValueForOutputPortRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductNamespaceSuggestionRequestOptions is the options needed to make a request to GetDataProductNamespaceSuggestion.
type GetDataProductNamespaceSuggestionRequestOptions struct {
	Query *GetDataProductNamespaceSuggestionQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductNamespaceSuggestionRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductNamespaceSuggestionRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *GetDataProductNamespaceSuggestionRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductNamespaceSuggestionRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductNamespaceSuggestionRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ValidateDataProductNamespaceRequestOptions is the options needed to make a request to ValidateDataProductNamespace.
type ValidateDataProductNamespaceRequestOptions struct {
	Query *ValidateDataProductNamespaceQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ValidateDataProductNamespaceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ValidateDataProductNamespaceRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *ValidateDataProductNamespaceRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ValidateDataProductNamespaceRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *ValidateDataProductNamespaceRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDataProductRequestOptions is the options needed to make a request to CreateDataProduct.
type CreateDataProductRequestOptions struct {
	Body *CreateDataProductBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDataProductRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductsRequestOptions is the options needed to make a request to GetDataProducts.
type GetDataProductsRequestOptions struct {
	Query *GetDataProductsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *GetDataProductsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDataProductRequestOptions is the options needed to make a request to RemoveDataProduct.
type RemoveDataProductRequestOptions struct {
	PathParams *RemoveDataProductPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDataProductRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductRequestOptions is the options needed to make a request to UpdateDataProduct.
type UpdateDataProductRequestOptions struct {
	PathParams *UpdateDataProductPath
	Body       *UpdateDataProductBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductRequestOptions is the options needed to make a request to GetDataProduct.
type GetDataProductRequestOptions struct {
	PathParams *GetDataProductPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductAboutRequestOptions is the options needed to make a request to UpdateDataProductAbout.
type UpdateDataProductAboutRequestOptions struct {
	PathParams *UpdateDataProductAboutPath
	Body       *UpdateDataProductAboutBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductAboutRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductAboutRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductAboutRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductAboutRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductAboutRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductStatusRequestOptions is the options needed to make a request to UpdateDataProductStatus.
type UpdateDataProductStatusRequestOptions struct {
	PathParams *UpdateDataProductStatusPath
	Body       *UpdateDataProductStatusBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductStatusRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductStatusRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductStatusRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductStatusRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductStatusRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductUsageRequestOptions is the options needed to make a request to UpdateDataProductUsage.
type UpdateDataProductUsageRequestOptions struct {
	PathParams *UpdateDataProductUsagePath
	Body       *UpdateDataProductUsageBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductUsageRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductUsageRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductUsageRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductUsageRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductUsageRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetGraphData_1RequestOptions is the options needed to make a request to GetGraphData_1.
type GetGraphData_1RequestOptions struct {
	PathParams *GetGraphDataPath
	Query      *GetGraphDataQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetGraphData_1RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetGraphData_1RequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetGraphData_1RequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetGraphData_1RequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetGraphData_1RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// SetValueForDataProductRequestOptions is the options needed to make a request to SetValueForDataProduct.
type SetValueForDataProductRequestOptions struct {
	PathParams *SetValueForDataProductPath
	Query      *SetValueForDataProductQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *SetValueForDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *SetValueForDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *SetValueForDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *SetValueForDataProductRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *SetValueForDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// LinkInputPortsToDataProductRequestOptions is the options needed to make a request to LinkInputPortsToDataProduct.
type LinkInputPortsToDataProductRequestOptions struct {
	PathParams *LinkInputPortsToDataProductPath
	Body       *LinkInputPortsToDataProductBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *LinkInputPortsToDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *LinkInputPortsToDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *LinkInputPortsToDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *LinkInputPortsToDataProductRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *LinkInputPortsToDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateTechnicalAssetRequestOptions is the options needed to make a request to CreateTechnicalAsset.
type CreateTechnicalAssetRequestOptions struct {
	PathParams *CreateTechnicalAssetPath
	Body       *CreateTechnicalAssetBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *CreateTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateTechnicalAssetRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetSigninURLRequestOptions is the options needed to make a request to GetSigninURL.
type GetSigninURLRequestOptions struct {
	PathParams *GetSigninURLPath
	Query      *GetSigninURLQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetSigninURLRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetSigninURLRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetSigninURLRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetSigninURLRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetSigninURLRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetConveyorIdeURLRequestOptions is the options needed to make a request to GetConveyorIdeURL.
type GetConveyorIdeURLRequestOptions struct {
	PathParams *GetConveyorIdeURLPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetConveyorIdeURLRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetConveyorIdeURLRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetConveyorIdeURLRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetConveyorIdeURLRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetConveyorIdeURLRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDatabricksWorkspaceURLRequestOptions is the options needed to make a request to GetDatabricksWorkspaceURL.
type GetDatabricksWorkspaceURLRequestOptions struct {
	PathParams *GetDatabricksWorkspaceURLPath
	Query      *GetDatabricksWorkspaceURLQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDatabricksWorkspaceURLRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDatabricksWorkspaceURLRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDatabricksWorkspaceURLRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDatabricksWorkspaceURLRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDatabricksWorkspaceURLRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetSnowflakeURLRequestOptions is the options needed to make a request to GetSnowflakeURL.
type GetSnowflakeURLRequestOptions struct {
	PathParams *GetSnowflakeURLPath
	Query      *GetSnowflakeURLQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetSnowflakeURLRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetSnowflakeURLRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetSnowflakeURLRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetSnowflakeURLRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetSnowflakeURLRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetTechnicalAssetsRequestOptions is the options needed to make a request to GetTechnicalAssets.
type GetTechnicalAssetsRequestOptions struct {
	PathParams *GetTechnicalAssetsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetTechnicalAssetsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetTechnicalAssetsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetTechnicalAssetsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetTechnicalAssetsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetTechnicalAssetsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductInputPortsRequestOptions is the options needed to make a request to GetDataProductInputPorts.
type GetDataProductInputPortsRequestOptions struct {
	PathParams *GetDataProductInputPortsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductInputPortsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductInputPortsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductInputPortsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductInputPortsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductInputPortsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductRolledUpTagsRequestOptions is the options needed to make a request to GetDataProductRolledUpTags.
type GetDataProductRolledUpTagsRequestOptions struct {
	PathParams *GetDataProductRolledUpTagsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductRolledUpTagsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductRolledUpTagsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductRolledUpTagsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductRolledUpTagsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductRolledUpTagsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UnlinkInputPortFromDataProductRequestOptions is the options needed to make a request to UnlinkInputPortFromDataProduct.
type UnlinkInputPortFromDataProductRequestOptions struct {
	PathParams *UnlinkInputPortFromDataProductPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UnlinkInputPortFromDataProductRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UnlinkInputPortFromDataProductRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UnlinkInputPortFromDataProductRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UnlinkInputPortFromDataProductRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *UnlinkInputPortFromDataProductRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ValidateTechnicalAssetNamespaceRequestOptions is the options needed to make a request to ValidateTechnicalAssetNamespace.
type ValidateTechnicalAssetNamespaceRequestOptions struct {
	PathParams *ValidateTechnicalAssetNamespacePath
	Query      *ValidateTechnicalAssetNamespaceQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ValidateTechnicalAssetNamespaceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ValidateTechnicalAssetNamespaceRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ValidateTechnicalAssetNamespaceRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ValidateTechnicalAssetNamespaceRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *ValidateTechnicalAssetNamespaceRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductTypeRequestOptions is the options needed to make a request to GetDataProductType.
type GetDataProductTypeRequestOptions struct {
	PathParams *GetDataProductTypePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductTypeRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductTypeRequestOptions is the options needed to make a request to UpdateDataProductType.
type UpdateDataProductTypeRequestOptions struct {
	PathParams *UpdateDataProductTypePath
	Body       *UpdateDataProductTypeBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductTypeRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDataProductTypeRequestOptions is the options needed to make a request to RemoveDataProductType.
type RemoveDataProductTypeRequestOptions struct {
	PathParams *RemoveDataProductTypePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDataProductTypeRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDataProductTypeRequestOptions is the options needed to make a request to CreateDataProductType.
type CreateDataProductTypeRequestOptions struct {
	Body *CreateDataProductTypeBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDataProductTypeRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// MigrateDataProductTypeRequestOptions is the options needed to make a request to MigrateDataProductType.
type MigrateDataProductTypeRequestOptions struct {
	PathParams *MigrateDataProductTypePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *MigrateDataProductTypeRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *MigrateDataProductTypeRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *MigrateDataProductTypeRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *MigrateDataProductTypeRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *MigrateDataProductTypeRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDataProductLifecycleRequestOptions is the options needed to make a request to CreateDataProductLifecycle.
type CreateDataProductLifecycleRequestOptions struct {
	Body *CreateDataProductLifecycleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDataProductLifecycleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDataProductLifecycleRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDataProductLifecycleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDataProductLifecycleRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDataProductLifecycleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductLifecycleRequestOptions is the options needed to make a request to UpdateDataProductLifecycle.
type UpdateDataProductLifecycleRequestOptions struct {
	PathParams *UpdateDataProductLifecyclePath
	Body       *UpdateDataProductLifecycleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductLifecycleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductLifecycleRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductLifecycleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductLifecycleRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductLifecycleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteDataProductLifecycleRequestOptions is the options needed to make a request to DeleteDataProductLifecycle.
type DeleteDataProductLifecycleRequestOptions struct {
	PathParams *DeleteDataProductLifecyclePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteDataProductLifecycleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteDataProductLifecycleRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteDataProductLifecycleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteDataProductLifecycleRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *DeleteDataProductLifecycleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDataProductSettingRequestOptions is the options needed to make a request to CreateDataProductSetting.
type CreateDataProductSettingRequestOptions struct {
	Body *CreateDataProductSettingBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDataProductSettingRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDataProductSettingRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDataProductSettingRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDataProductSettingRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDataProductSettingRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDataProductSettingsNamespaceSuggestionRequestOptions is the options needed to make a request to GetDataProductSettingsNamespaceSuggestion.
type GetDataProductSettingsNamespaceSuggestionRequestOptions struct {
	Query *GetDataProductSettingsNamespaceSuggestionQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDataProductSettingsNamespaceSuggestionRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDataProductSettingsNamespaceSuggestionRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *GetDataProductSettingsNamespaceSuggestionRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDataProductSettingsNamespaceSuggestionRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDataProductSettingsNamespaceSuggestionRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ValidateDataProductSettingsNamespaceRequestOptions is the options needed to make a request to ValidateDataProductSettingsNamespace.
type ValidateDataProductSettingsNamespaceRequestOptions struct {
	Query *ValidateDataProductSettingsNamespaceQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ValidateDataProductSettingsNamespaceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ValidateDataProductSettingsNamespaceRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *ValidateDataProductSettingsNamespaceRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ValidateDataProductSettingsNamespaceRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *ValidateDataProductSettingsNamespaceRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDataProductSettingRequestOptions is the options needed to make a request to UpdateDataProductSetting.
type UpdateDataProductSettingRequestOptions struct {
	PathParams *UpdateDataProductSettingPath
	Body       *UpdateDataProductSettingBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDataProductSettingRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDataProductSettingRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDataProductSettingRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDataProductSettingRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDataProductSettingRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteDataProductSettingRequestOptions is the options needed to make a request to DeleteDataProductSetting.
type DeleteDataProductSettingRequestOptions struct {
	PathParams *DeleteDataProductSettingPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteDataProductSettingRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteDataProductSettingRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteDataProductSettingRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteDataProductSettingRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *DeleteDataProductSettingRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetTechnicalAssetRequestOptions is the options needed to make a request to GetTechnicalAsset.
type GetTechnicalAssetRequestOptions struct {
	PathParams *GetTechnicalAssetPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetTechnicalAssetRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveTechnicalAssetRequestOptions is the options needed to make a request to RemoveTechnicalAsset.
type RemoveTechnicalAssetRequestOptions struct {
	PathParams *RemoveTechnicalAssetPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveTechnicalAssetRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetTechnicalAssetEventHistoryRequestOptions is the options needed to make a request to GetTechnicalAssetEventHistory.
type GetTechnicalAssetEventHistoryRequestOptions struct {
	PathParams *GetTechnicalAssetEventHistoryPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetTechnicalAssetEventHistoryRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetTechnicalAssetEventHistoryRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetTechnicalAssetEventHistoryRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetTechnicalAssetEventHistoryRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetTechnicalAssetEventHistoryRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateTechnicalAssetStatusRequestOptions is the options needed to make a request to UpdateTechnicalAssetStatus.
type UpdateTechnicalAssetStatusRequestOptions struct {
	PathParams *UpdateTechnicalAssetStatusPath
	Body       *UpdateTechnicalAssetStatusBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateTechnicalAssetStatusRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateTechnicalAssetStatusRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateTechnicalAssetStatusRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateTechnicalAssetStatusRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateTechnicalAssetStatusRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// LinkOutputPortToTechnicalAssetRequestOptions is the options needed to make a request to LinkOutputPortToTechnicalAsset.
type LinkOutputPortToTechnicalAssetRequestOptions struct {
	PathParams *LinkOutputPortToTechnicalAssetPath
	Body       *LinkOutputPortToTechnicalAssetBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *LinkOutputPortToTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UnlinkOutputPortFromTechnicalAssetRequestOptions is the options needed to make a request to UnlinkOutputPortFromTechnicalAsset.
type UnlinkOutputPortFromTechnicalAssetRequestOptions struct {
	PathParams *UnlinkOutputPortFromTechnicalAssetPath
	Query      *UnlinkOutputPortFromTechnicalAssetQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *UnlinkOutputPortFromTechnicalAssetRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetGraphData_2RequestOptions is the options needed to make a request to GetGraphData_2.
type GetGraphData_2RequestOptions struct {
	PathParams *GetGraphDataPath
	Query      *GetGraphDataQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetGraphData_2RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetGraphData_2RequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetGraphData_2RequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetGraphData_2RequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetGraphData_2RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateDomainRequestOptions is the options needed to make a request to CreateDomain.
type CreateDomainRequestOptions struct {
	Body *CreateDomainBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateDomainRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateDomainRequestOptions is the options needed to make a request to UpdateDomain.
type UpdateDomainRequestOptions struct {
	PathParams *UpdateDomainPath
	Body       *UpdateDomainBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateDomainRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveDomainRequestOptions is the options needed to make a request to RemoveDomain.
type RemoveDomainRequestOptions struct {
	PathParams *RemoveDomainPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveDomainRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetDomainRequestOptions is the options needed to make a request to GetDomain.
type GetDomainRequestOptions struct {
	PathParams *GetDomainPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetDomainRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// MigrateDomainRequestOptions is the options needed to make a request to MigrateDomain.
type MigrateDomainRequestOptions struct {
	PathParams *MigrateDomainPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *MigrateDomainRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *MigrateDomainRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *MigrateDomainRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *MigrateDomainRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *MigrateDomainRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentRequestOptions is the options needed to make a request to GetEnvironment.
type GetEnvironmentRequestOptions struct {
	PathParams *GetEnvironmentPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentConfigsByIDRequestOptions is the options needed to make a request to GetEnvironmentConfigsByID.
type GetEnvironmentConfigsByIDRequestOptions struct {
	PathParams *GetEnvironmentConfigsByIDPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentConfigsByIDRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentConfigsByIDRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentConfigsByIDRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentConfigsByIDRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentConfigsByIDRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentPlatformServiceConfigRequestOptions is the options needed to make a request to GetEnvironmentPlatformServiceConfig.
type GetEnvironmentPlatformServiceConfigRequestOptions struct {
	PathParams *GetEnvironmentPlatformServiceConfigPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentPlatformServiceConfigRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentPlatformConfigRequestOptions is the options needed to make a request to GetEnvironmentPlatformConfig.
type GetEnvironmentPlatformConfigRequestOptions struct {
	PathParams *GetEnvironmentPlatformConfigPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentPlatformConfigRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentPlatformConfigRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentPlatformConfigRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentPlatformConfigRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentPlatformConfigRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentConfigsRequestOptions is the options needed to make a request to GetEnvironmentConfigs.
type GetEnvironmentConfigsRequestOptions struct {
	PathParams *GetEnvironmentConfigsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentConfigsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentConfigsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentConfigsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentConfigsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentConfigsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions is the options needed to make a request to GetEnvironmentPlatformServiceConfigForAllEnvs.
type GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions struct {
	PathParams *GetEnvironmentPlatformServiceConfigForAllEnvsPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetEnvironmentPlatformServiceConfigForAllEnvsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetPlatformServiceConfigRequestOptions is the options needed to make a request to GetPlatformServiceConfig.
type GetPlatformServiceConfigRequestOptions struct {
	PathParams *GetPlatformServiceConfigPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetPlatformServiceConfigRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetPlatformServiceConfigRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetPlatformServiceConfigRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetPlatformServiceConfigRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetPlatformServiceConfigRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetSinglePlatformServiceConfigurationRequestOptions is the options needed to make a request to GetSinglePlatformServiceConfiguration.
type GetSinglePlatformServiceConfigurationRequestOptions struct {
	PathParams *GetSinglePlatformServiceConfigurationPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetSinglePlatformServiceConfigurationRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetPlatformServicesRequestOptions is the options needed to make a request to GetPlatformServices.
type GetPlatformServicesRequestOptions struct {
	PathParams *GetPlatformServicesPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetPlatformServicesRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetPlatformServicesRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetPlatformServicesRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetPlatformServicesRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetPlatformServicesRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateTagRequestOptions is the options needed to make a request to CreateTag.
type CreateTagRequestOptions struct {
	Body *CreateTagBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateTagRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateTagRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateTagRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateTagRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateTagRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateTagRequestOptions is the options needed to make a request to UpdateTag.
type UpdateTagRequestOptions struct {
	PathParams *UpdateTagPath
	Body       *UpdateTagBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateTagRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateTagRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateTagRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateTagRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateTagRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveTagRequestOptions is the options needed to make a request to RemoveTag.
type RemoveTagRequestOptions struct {
	PathParams *RemoveTagPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveTagRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveTagRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveTagRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveTagRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveTagRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveUserRequestOptions is the options needed to make a request to RemoveUser.
type RemoveUserRequestOptions struct {
	PathParams *RemoveUserPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveUserRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveUserRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveUserRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveUserRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveUserRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateUserRequestOptions is the options needed to make a request to CreateUser.
type CreateUserRequestOptions struct {
	Body *CreateUserBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateUserRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateUserRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateUserRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateUserRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateUserRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// SetCanBecomeAdminRequestOptions is the options needed to make a request to SetCanBecomeAdmin.
type SetCanBecomeAdminRequestOptions struct {
	Body *SetCanBecomeAdminBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *SetCanBecomeAdminRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *SetCanBecomeAdminRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *SetCanBecomeAdminRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *SetCanBecomeAdminRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *SetCanBecomeAdminRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateRoleRequestOptions is the options needed to make a request to CreateRole.
type CreateRoleRequestOptions struct {
	Body *CreateRoleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateRoleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateRoleRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateRoleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateRoleRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateRoleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RemoveRoleRequestOptions is the options needed to make a request to RemoveRole.
type RemoveRoleRequestOptions struct {
	PathParams *RemoveRolePath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RemoveRoleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RemoveRoleRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *RemoveRoleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RemoveRoleRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *RemoveRoleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateRoleRequestOptions is the options needed to make a request to UpdateRole.
type UpdateRoleRequestOptions struct {
	PathParams *UpdateRolePath
	Body       *UpdateRoleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateRoleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateRoleRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *UpdateRoleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateRoleRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateRoleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// GetRolesRequestOptions is the options needed to make a request to GetRoles.
type GetRolesRequestOptions struct {
	PathParams *GetRolesPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *GetRolesRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *GetRolesRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *GetRolesRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *GetRolesRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *GetRolesRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// BecomeAdminRequestOptions is the options needed to make a request to BecomeAdmin.
type BecomeAdminRequestOptions struct {
	Body *BecomeAdminBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *BecomeAdminRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *BecomeAdminRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *BecomeAdminRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *BecomeAdminRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *BecomeAdminRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateAssignmentRequestOptions is the options needed to make a request to CreateAssignment.
type CreateAssignmentRequestOptions struct {
	Body *CreateAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ListAssignmentsRequestOptions is the options needed to make a request to ListAssignments.
type ListAssignmentsRequestOptions struct {
	Query *ListAssignmentsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ListAssignmentsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ListAssignmentsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *ListAssignmentsRequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ListAssignmentsRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *ListAssignmentsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteAssignmentRequestOptions is the options needed to make a request to DeleteAssignment.
type DeleteAssignmentRequestOptions struct {
	PathParams *DeleteAssignmentPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteAssignmentRequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *DeleteAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DecideAssignmentRequestOptions is the options needed to make a request to DecideAssignment.
type DecideAssignmentRequestOptions struct {
	PathParams *DecideAssignmentPath
	Body       *DecideAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DecideAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DecideAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DecideAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DecideAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DecideAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ModifyAssignedRoleRequestOptions is the options needed to make a request to ModifyAssignedRole.
type ModifyAssignedRoleRequestOptions struct {
	PathParams *ModifyAssignedRolePath
	Body       *ModifyAssignedRoleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ModifyAssignedRoleRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ModifyAssignedRoleRequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ModifyAssignedRoleRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ModifyAssignedRoleRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ModifyAssignedRoleRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteAssignment_1RequestOptions is the options needed to make a request to DeleteAssignment_1.
type DeleteAssignment_1RequestOptions struct {
	PathParams *DeleteAssignmentPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteAssignment_1RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteAssignment_1RequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteAssignment_1RequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteAssignment_1RequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *DeleteAssignment_1RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ModifyAssignedRole_1RequestOptions is the options needed to make a request to ModifyAssignedRole_1.
type ModifyAssignedRole_1RequestOptions struct {
	PathParams *ModifyAssignedRolePath
	Body       *ModifyAssignedRoleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ModifyAssignedRole_1RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ModifyAssignedRole_1RequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ModifyAssignedRole_1RequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ModifyAssignedRole_1RequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ModifyAssignedRole_1RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ListAssignments_1RequestOptions is the options needed to make a request to ListAssignments_1.
type ListAssignments_1RequestOptions struct {
	Query *ListAssignmentsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ListAssignments_1RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ListAssignments_1RequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *ListAssignments_1RequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ListAssignments_1RequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *ListAssignments_1RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateAssignment_1RequestOptions is the options needed to make a request to CreateAssignment_1.
type CreateAssignment_1RequestOptions struct {
	Body *CreateAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateAssignment_1RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateAssignment_1RequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateAssignment_1RequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateAssignment_1RequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateAssignment_1RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RequestAssignmentRequestOptions is the options needed to make a request to RequestAssignment.
type RequestAssignmentRequestOptions struct {
	Body *RequestAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RequestAssignmentRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RequestAssignmentRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *RequestAssignmentRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RequestAssignmentRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *RequestAssignmentRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DecideAssignment_1RequestOptions is the options needed to make a request to DecideAssignment_1.
type DecideAssignment_1RequestOptions struct {
	PathParams *DecideAssignmentPath
	Body       *DecideAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DecideAssignment_1RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DecideAssignment_1RequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DecideAssignment_1RequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DecideAssignment_1RequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DecideAssignment_1RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DeleteAssignment_2RequestOptions is the options needed to make a request to DeleteAssignment_2.
type DeleteAssignment_2RequestOptions struct {
	PathParams *DeleteAssignmentPath
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DeleteAssignment_2RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DeleteAssignment_2RequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DeleteAssignment_2RequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DeleteAssignment_2RequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *DeleteAssignment_2RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ModifyAssignedRole_2RequestOptions is the options needed to make a request to ModifyAssignedRole_2.
type ModifyAssignedRole_2RequestOptions struct {
	PathParams *ModifyAssignedRolePath
	Body       *ModifyAssignedRoleBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ModifyAssignedRole_2RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ModifyAssignedRole_2RequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *ModifyAssignedRole_2RequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ModifyAssignedRole_2RequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *ModifyAssignedRole_2RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// ListAssignments_2RequestOptions is the options needed to make a request to ListAssignments_2.
type ListAssignments_2RequestOptions struct {
	Query *ListAssignmentsQuery
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *ListAssignments_2RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *ListAssignments_2RequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *ListAssignments_2RequestOptions) GetQuery() (map[string]any, error) {
	return runtime.AsMap[any](o.Query)
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *ListAssignments_2RequestOptions) GetBody() any {
	return nil
}

// GetHeader returns the headers as a map.
func (o *ListAssignments_2RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// CreateAssignment_2RequestOptions is the options needed to make a request to CreateAssignment_2.
type CreateAssignment_2RequestOptions struct {
	Body *CreateAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *CreateAssignment_2RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *CreateAssignment_2RequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *CreateAssignment_2RequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *CreateAssignment_2RequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *CreateAssignment_2RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// RequestAssignment_1RequestOptions is the options needed to make a request to RequestAssignment_1.
type RequestAssignment_1RequestOptions struct {
	Body *RequestAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *RequestAssignment_1RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *RequestAssignment_1RequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *RequestAssignment_1RequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *RequestAssignment_1RequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *RequestAssignment_1RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// DecideAssignment_2RequestOptions is the options needed to make a request to DecideAssignment_2.
type DecideAssignment_2RequestOptions struct {
	PathParams *DecideAssignmentPath
	Body       *DecideAssignmentBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *DecideAssignment_2RequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *DecideAssignment_2RequestOptions) GetPathParams() (map[string]any, error) {
	return runtime.AsMap[any](o.PathParams)
}

// GetQuery returns the query params as a map.
func (o *DecideAssignment_2RequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *DecideAssignment_2RequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *DecideAssignment_2RequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// UpdateSettingsRequestOptions is the options needed to make a request to UpdateSettings.
type UpdateSettingsRequestOptions struct {
	Body *UpdateSettingsBody
}

// Validate validates all the fields in the options.
// Use it if fields validation was not run.
func (o *UpdateSettingsRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetPathParams returns the path params as a map.
func (o *UpdateSettingsRequestOptions) GetPathParams() (map[string]any, error) {
	return nil, nil
}

// GetQuery returns the query params as a map.
func (o *UpdateSettingsRequestOptions) GetQuery() (map[string]any, error) {
	return nil, nil
}

// GetBody returns the payload in any type that can be marshalled to JSON by the client.
func (o *UpdateSettingsRequestOptions) GetBody() any {
	return o.Body
}

// GetHeader returns the headers as a map.
func (o *UpdateSettingsRequestOptions) GetHeader() (map[string]string, error) {
	return nil, nil
}

// AuthorizationAction The integer values for the authorization actions are stored directly in the DB.
// This means you can change the name of the actions, but not their integer values.
// The values for the actions are spaced on purpose, to make it easier to extend.
// This has no technical benefit, but it makes it easier to read for developers.
type AuthorizationAction int

const (
	AuthorizationActionN101 AuthorizationAction = 101
	AuthorizationActionN102 AuthorizationAction = 102
	AuthorizationActionN103 AuthorizationAction = 103
	AuthorizationActionN104 AuthorizationAction = 104
	AuthorizationActionN105 AuthorizationAction = 105
	AuthorizationActionN106 AuthorizationAction = 106
	AuthorizationActionN107 AuthorizationAction = 107
	AuthorizationActionN301 AuthorizationAction = 301
	AuthorizationActionN302 AuthorizationAction = 302
	AuthorizationActionN303 AuthorizationAction = 303
	AuthorizationActionN304 AuthorizationAction = 304
	AuthorizationActionN305 AuthorizationAction = 305
	AuthorizationActionN306 AuthorizationAction = 306
	AuthorizationActionN307 AuthorizationAction = 307
	AuthorizationActionN308 AuthorizationAction = 308
	AuthorizationActionN309 AuthorizationAction = 309
	AuthorizationActionN310 AuthorizationAction = 310
	AuthorizationActionN311 AuthorizationAction = 311
	AuthorizationActionN312 AuthorizationAction = 312
	AuthorizationActionN313 AuthorizationAction = 313
	AuthorizationActionN314 AuthorizationAction = 314
	AuthorizationActionN315 AuthorizationAction = 315
	AuthorizationActionN401 AuthorizationAction = 401
	AuthorizationActionN402 AuthorizationAction = 402
	AuthorizationActionN403 AuthorizationAction = 403
	AuthorizationActionN404 AuthorizationAction = 404
	AuthorizationActionN405 AuthorizationAction = 405
	AuthorizationActionN406 AuthorizationAction = 406
	AuthorizationActionN407 AuthorizationAction = 407
	AuthorizationActionN408 AuthorizationAction = 408
	AuthorizationActionN409 AuthorizationAction = 409
	AuthorizationActionN410 AuthorizationAction = 410
	AuthorizationActionN411 AuthorizationAction = 411
	AuthorizationActionN412 AuthorizationAction = 412
	AuthorizationActionN413 AuthorizationAction = 413
)

// Validate checks if the AuthorizationAction value is valid
func (a AuthorizationAction) Validate() error {
	switch a {
	case AuthorizationActionN101, AuthorizationActionN102, AuthorizationActionN103, AuthorizationActionN104, AuthorizationActionN105, AuthorizationActionN106, AuthorizationActionN107, AuthorizationActionN301, AuthorizationActionN302, AuthorizationActionN303, AuthorizationActionN304, AuthorizationActionN305, AuthorizationActionN306, AuthorizationActionN307, AuthorizationActionN308, AuthorizationActionN309, AuthorizationActionN310, AuthorizationActionN311, AuthorizationActionN312, AuthorizationActionN313, AuthorizationActionN314, AuthorizationActionN315, AuthorizationActionN401, AuthorizationActionN402, AuthorizationActionN403, AuthorizationActionN404, AuthorizationActionN405, AuthorizationActionN406, AuthorizationActionN407, AuthorizationActionN408, AuthorizationActionN409, AuthorizationActionN410, AuthorizationActionN411, AuthorizationActionN412, AuthorizationActionN413:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid AuthorizationAction value, got: %v", a))
	}
}

type DataProductIconKey string

const (
	DataProductIconKeyAnalytics       DataProductIconKey = "analytics"
	DataProductIconKeyDefault         DataProductIconKey = "default"
	DataProductIconKeyExploration     DataProductIconKey = "exploration"
	DataProductIconKeyIngestion       DataProductIconKey = "ingestion"
	DataProductIconKeyMachineLearning DataProductIconKey = "machine_learning"
	DataProductIconKeyProcessing      DataProductIconKey = "processing"
	DataProductIconKeyReporting       DataProductIconKey = "reporting"
)

// Validate checks if the DataProductIconKey value is valid
func (d DataProductIconKey) Validate() error {
	switch d {
	case DataProductIconKeyAnalytics, DataProductIconKeyDefault, DataProductIconKeyExploration, DataProductIconKeyIngestion, DataProductIconKeyMachineLearning, DataProductIconKeyProcessing, DataProductIconKeyReporting:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DataProductIconKey value, got: %v", d))
	}
}

type DataProductSettingScope string

const (
	DataProductSettingScopeDataproduct DataProductSettingScope = "dataproduct"
	DataProductSettingScopeDataset     DataProductSettingScope = "dataset"
)

// Validate checks if the DataProductSettingScope value is valid
func (d DataProductSettingScope) Validate() error {
	switch d {
	case DataProductSettingScopeDataproduct, DataProductSettingScopeDataset:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DataProductSettingScope value, got: %v", d))
	}
}

type DataProductSettingType string

const (
	DataProductSettingTypeCheckbox DataProductSettingType = "checkbox"
	DataProductSettingTypeInput    DataProductSettingType = "input"
	DataProductSettingTypeTags     DataProductSettingType = "tags"
)

// Validate checks if the DataProductSettingType value is valid
func (d DataProductSettingType) Validate() error {
	switch d {
	case DataProductSettingTypeCheckbox, DataProductSettingTypeInput, DataProductSettingTypeTags:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DataProductSettingType value, got: %v", d))
	}
}

type DataProductStatus string

const (
	DataProductStatusActive   DataProductStatus = "active"
	DataProductStatusArchived DataProductStatus = "archived"
	DataProductStatusPending  DataProductStatus = "pending"
)

// Validate checks if the DataProductStatus value is valid
func (d DataProductStatus) Validate() error {
	switch d {
	case DataProductStatusActive, DataProductStatusArchived, DataProductStatusPending:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DataProductStatus value, got: %v", d))
	}
}

type DecisionStatus string

const (
	DecisionStatusApproved DecisionStatus = "approved"
	DecisionStatusDenied   DecisionStatus = "denied"
	DecisionStatusPending  DecisionStatus = "pending"
)

// Validate checks if the DecisionStatus value is valid
func (d DecisionStatus) Validate() error {
	switch d {
	case DecisionStatusApproved, DecisionStatusDenied, DecisionStatusPending:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid DecisionStatus value, got: %v", d))
	}
}

type EventReferenceEntity string

const (
	EventReferenceEntityDataOutput  EventReferenceEntity = "data_output"
	EventReferenceEntityDataProduct EventReferenceEntity = "data_product"
	EventReferenceEntityDataset     EventReferenceEntity = "dataset"
	EventReferenceEntityUser        EventReferenceEntity = "user"
)

// Validate checks if the EventReferenceEntity value is valid
func (e EventReferenceEntity) Validate() error {
	switch e {
	case EventReferenceEntityDataOutput, EventReferenceEntityDataProduct, EventReferenceEntityDataset, EventReferenceEntityUser:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid EventReferenceEntity value, got: %v", e))
	}
}

type NamespaceValidityType string

const (
	NamespaceValidityTypeDUPLICATENAMESPACE NamespaceValidityType = "DUPLICATE_NAMESPACE"
	NamespaceValidityTypeINVALIDCHARACTERS  NamespaceValidityType = "INVALID_CHARACTERS"
	NamespaceValidityTypeINVALIDLENGTH      NamespaceValidityType = "INVALID_LENGTH"
	NamespaceValidityTypeVALID              NamespaceValidityType = "VALID"
)

// Validate checks if the NamespaceValidityType value is valid
func (n NamespaceValidityType) Validate() error {
	switch n {
	case NamespaceValidityTypeDUPLICATENAMESPACE, NamespaceValidityTypeINVALIDCHARACTERS, NamespaceValidityTypeINVALIDLENGTH, NamespaceValidityTypeVALID:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid NamespaceValidityType value, got: %v", n))
	}
}

type NodeType string

const (
	NodeTypeDataOutputNode  NodeType = "dataOutputNode"
	NodeTypeDataProductNode NodeType = "dataProductNode"
	NodeTypeDatasetNode     NodeType = "datasetNode"
	NodeTypeDomainNode      NodeType = "domainNode"
)

// Validate checks if the NodeType value is valid
func (n NodeType) Validate() error {
	switch n {
	case NodeTypeDataOutputNode, NodeTypeDataProductNode, NodeTypeDatasetNode, NodeTypeDomainNode:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid NodeType value, got: %v", n))
	}
}

type OutputPortAccessType string

const (
	OutputPortAccessTypePrivate    OutputPortAccessType = "private"
	OutputPortAccessTypePublic     OutputPortAccessType = "public"
	OutputPortAccessTypeRestricted OutputPortAccessType = "restricted"
)

// Validate checks if the OutputPortAccessType value is valid
func (o OutputPortAccessType) Validate() error {
	switch o {
	case OutputPortAccessTypePrivate, OutputPortAccessTypePublic, OutputPortAccessTypeRestricted:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid OutputPortAccessType value, got: %v", o))
	}
}

type OutputPortStatus string

const (
	OutputPortStatusActive   OutputPortStatus = "active"
	OutputPortStatusArchived OutputPortStatus = "archived"
	OutputPortStatusPending  OutputPortStatus = "pending"
)

// Validate checks if the OutputPortStatus value is valid
func (o OutputPortStatus) Validate() error {
	switch o {
	case OutputPortStatusActive, OutputPortStatusArchived, OutputPortStatusPending:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid OutputPortStatus value, got: %v", o))
	}
}

type Prototype int

const (
	PrototypeN0 Prototype = 0
	PrototypeN1 Prototype = 1
	PrototypeN2 Prototype = 2
	PrototypeN3 Prototype = 3
)

// Validate checks if the Prototype value is valid
func (p Prototype) Validate() error {
	switch p {
	case PrototypeN0, PrototypeN1, PrototypeN2, PrototypeN3:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid Prototype value, got: %v", p))
	}
}

type QueryStatsGranularity string

const (
	QueryStatsGranularityDay   QueryStatsGranularity = "day"
	QueryStatsGranularityMonth QueryStatsGranularity = "month"
	QueryStatsGranularityWeek  QueryStatsGranularity = "week"
)

// Validate checks if the QueryStatsGranularity value is valid
func (q QueryStatsGranularity) Validate() error {
	switch q {
	case QueryStatsGranularityDay, QueryStatsGranularityMonth, QueryStatsGranularityWeek:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid QueryStatsGranularity value, got: %v", q))
	}
}

type Scope string

const (
	ScopeDataProduct Scope = "data_product"
	ScopeDataset     Scope = "dataset"
	ScopeDomain      Scope = "domain"
	ScopeGlobal      Scope = "global"
)

// Validate checks if the Scope value is valid
func (s Scope) Validate() error {
	switch s {
	case ScopeDataProduct, ScopeDataset, ScopeDomain, ScopeGlobal:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid Scope value, got: %v", s))
	}
}

type TechnicalAssetStatus string

const (
	TechnicalAssetStatusActive   TechnicalAssetStatus = "active"
	TechnicalAssetStatusArchived TechnicalAssetStatus = "archived"
	TechnicalAssetStatusPending  TechnicalAssetStatus = "pending"
)

// Validate checks if the TechnicalAssetStatus value is valid
func (t TechnicalAssetStatus) Validate() error {
	switch t {
	case TechnicalAssetStatusActive, TechnicalAssetStatusArchived, TechnicalAssetStatusPending:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid TechnicalAssetStatus value, got: %v", t))
	}
}

type CheckAccessPath struct {
	Action AuthorizationAction `json:"action" validate:"required"`
}

func (c CheckAccessPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.Action).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Action", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortQueryStatsPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetOutputPortQueryStatsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortQueryStatsPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortQueryStatsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteOutputPortQueryStatPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteOutputPortQueryStatPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortCuratedQueriesPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetOutputPortCuratedQueriesPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ReplaceOutputPortCuratedQueriesPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (r ReplaceOutputPortCuratedQueriesPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductOutputPortsPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (g GetDataProductOutputPortsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateOutputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (c CreateOutputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetOutputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDatasetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDatasetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEventHistoryPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetEventHistoryPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortAboutPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortAboutPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortStatusPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortStatusPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetGraphDataPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetGraphDataPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SetValueForOutputPortPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
	SettingID     uuid.UUID `json:"setting_id" validate:"required"`
}

func (s SetValueForOutputPortPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(s.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(s.SettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SettingID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDataProductPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductAboutPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductAboutPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductStatusPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductStatusPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductUsagePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductUsagePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SetValueForDataProductPath struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	SettingID uuid.UUID `json:"setting_id" validate:"required"`
}

func (s SetValueForDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(s.SettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SettingID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkInputPortsToDataProductPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (l LinkInputPortsToDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTechnicalAssetPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSigninURLPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetSigninURLPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetConveyorIdeURLPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetConveyorIdeURLPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDatabricksWorkspaceURLPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDatabricksWorkspaceURLPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSnowflakeURLPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetSnowflakeURLPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetsPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetTechnicalAssetsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductInputPortsPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductInputPortsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductRolledUpTagsPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductRolledUpTagsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UnlinkInputPortFromDataProductPath struct {
	ID          uuid.UUID `json:"id" validate:"required"`
	InputPortID uuid.UUID `json:"input_port_id" validate:"required"`
}

func (u UnlinkInputPortFromDataProductPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(u.InputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("InputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidateTechnicalAssetNamespacePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (v ValidateTechnicalAssetNamespacePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(v.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductTypePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDataProductTypePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductTypePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductTypePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDataProductTypePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDataProductTypePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MigrateDataProductTypePath struct {
	FromID uuid.UUID `json:"from_id" validate:"required"`
	ToID   uuid.UUID `json:"to_id" validate:"required"`
}

func (m MigrateDataProductTypePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.FromID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("FromID", err)
		}
	}
	if v, ok := any(m.ToID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ToID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductLifecyclePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductLifecyclePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteDataProductLifecyclePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteDataProductLifecyclePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductSettingPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductSettingPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteDataProductSettingPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteDataProductSettingPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveTechnicalAssetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetEventHistoryPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (g GetTechnicalAssetEventHistoryPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateTechnicalAssetStatusPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateTechnicalAssetStatusPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkOutputPortToTechnicalAssetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (l LinkOutputPortToTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(l.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UnlinkOutputPortFromTechnicalAssetPath struct {
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
	ID            uuid.UUID `json:"id" validate:"required"`
}

func (u UnlinkOutputPortFromTechnicalAssetPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDomainPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDomainPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveDomainPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveDomainPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDomainPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetDomainPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type MigrateDomainPath struct {
	FromID uuid.UUID `json:"from_id" validate:"required"`
	ToID   uuid.UUID `json:"to_id" validate:"required"`
}

func (m MigrateDomainPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.FromID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("FromID", err)
		}
	}
	if v, ok := any(m.ToID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ToID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetEnvironmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentConfigsByIDPath struct {
	ConfigID uuid.UUID `json:"config_id" validate:"required"`
}

func (g GetEnvironmentConfigsByIDPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfigID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfigID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentPlatformServiceConfigPath struct {
	ID         uuid.UUID `json:"id" validate:"required"`
	PlatformID uuid.UUID `json:"platform_id" validate:"required"`
	ServiceID  uuid.UUID `json:"service_id" validate:"required"`
}

func (g GetEnvironmentPlatformServiceConfigPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(g.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentPlatformConfigPath struct {
	ID         uuid.UUID `json:"id" validate:"required"`
	PlatformID uuid.UUID `json:"platform_id" validate:"required"`
}

func (g GetEnvironmentPlatformConfigPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentConfigsPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetEnvironmentConfigsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEnvironmentPlatformServiceConfigForAllEnvsPath struct {
	PlatformID uuid.UUID `json:"platform_id" validate:"required"`
	ServiceID  uuid.UUID `json:"service_id" validate:"required"`
}

func (g GetEnvironmentPlatformServiceConfigForAllEnvsPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(g.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetPlatformServiceConfigPath struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	ServiceID uuid.UUID `json:"service_id" validate:"required"`
}

func (g GetPlatformServiceConfigPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(g.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSinglePlatformServiceConfigurationPath struct {
	ConfigID uuid.UUID `json:"config_id" validate:"required"`
}

func (g GetSinglePlatformServiceConfigurationPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ConfigID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConfigID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetPlatformServicesPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (g GetPlatformServicesPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateTagPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateTagPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveTagPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveTagPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveUserPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveUserPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RemoveRolePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (r RemoveRolePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateRolePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateRolePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRolesPath struct {
	Scope Scope `json:"scope" validate:"required"`
}

func (g GetRolesPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DeleteAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DeleteAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DecideAssignmentPath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (d DecideAssignmentPath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ModifyAssignedRolePath struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (m ModifyAssignedRolePath) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(m.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortQueryStatsBody = UpdateOutputPortQueryStatus

type DeleteOutputPortQueryStatBody = OutputPortQueryStatsDelete

type ReplaceOutputPortCuratedQueriesBody = OutputPortCuratedQueriesUpdate

type CreateOutputPortBody = CreateOutputPortRequest

type UpdateOutputPortBody = DatasetUpdate

type UpdateOutputPortAboutBody = DatasetAboutUpdate

type UpdateOutputPortStatusBody = DatasetStatusUpdate

type CreateDataProductBody = DataProductCreate

type UpdateDataProductBody = DataProductUpdate

type UpdateDataProductAboutBody = DataProductAboutUpdate

type UpdateDataProductStatusBody = DataProductStatusUpdate

type UpdateDataProductUsageBody = DataProductUsageUpdate

type LinkInputPortsToDataProductBody = LinkInputPortsToDataProduct

type CreateTechnicalAssetBody = CreateTechnicalAssetRequest

type UpdateDataProductTypeBody = DataProductTypeUpdate

type CreateDataProductTypeBody = DataProductTypeCreate

type CreateDataProductLifecycleBody = DataProductLifeCycleCreate

type UpdateDataProductLifecycleBody = DataProductLifeCycleUpdate

type CreateDataProductSettingBody = DataProductSettingCreate

type UpdateDataProductSettingBody = DataProductSettingUpdate

type UpdateTechnicalAssetStatusBody = DataOutputStatusUpdate

type LinkOutputPortToTechnicalAssetBody = LinkTechnicalAssetToOutputPortRequest

type CreateDomainBody = DomainCreate

type UpdateDomainBody = DomainUpdate

type CreateTagBody = TagCreate

type UpdateTagBody = TagUpdate

type CreateUserBody = UserCreate

type SetCanBecomeAdminBody = CanBecomeAdminUpdate

type CreateRoleBody = CreateRole

type UpdateRoleBody = UpdateRole

type BecomeAdminBody = BecomeAdmin

type CreateAssignmentBody = AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment

type DecideAssignmentBody = AppAuthorizationRoleAssignmentsOutputPortSchemaDecideRoleAssignment

type ModifyAssignedRoleBody = AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment

type RequestAssignmentBody = AppAuthorizationRoleAssignmentsDataProductSchemaRequestRoleAssignment

type UpdateSettingsBody = ThemeSettings

type CheckAccessQuery struct {
	Resource *uuid.UUID `json:"resource,omitempty"`
	Domain   *uuid.UUID `json:"domain,omitempty"`
}

func (c CheckAccessQuery) Validate() error {
	var errors runtime.ValidationErrors
	if c.Resource != nil {
		if v, ok := any(c.Resource).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Resource", err)
			}
		}
	}
	if c.Domain != nil {
		if v, ok := any(c.Domain).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Domain", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchOutputPortsQuery struct {
	Query string `json:"query" validate:"required,min=3"`
	Limit *int   `json:"limit,omitempty" validate:"omitempty,gte=1,lte=100"`
}

func (s SearchOutputPortsQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetOutputPortQueryStatsQuery struct {
	Granularity *QueryStatsGranularity `json:"granularity,omitempty"`
	DayRange    *int                   `json:"day_range,omitempty" validate:"omitempty,gte=1"`
}

func (g GetOutputPortQueryStatsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if g.Granularity != nil {
		if v, ok := any(g.Granularity).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Granularity", err)
			}
		}
	}
	if g.DayRange != nil {
		if err := typesValidator.Var(g.DayRange, "omitempty,gte=1"); err != nil {
			errors = errors.Append("DayRange", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetGraphDataQuery struct {
	Level *int `json:"level,omitempty"`
}

type SetValueForOutputPortQuery struct {
	Value string `json:"value" validate:"required"`
}

func (s SetValueForOutputPortQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetDataProductNamespaceSuggestionQuery struct {
	Name string `json:"name" validate:"required"`
}

func (g GetDataProductNamespaceSuggestionQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ValidateDataProductNamespaceQuery struct {
	Namespace string `json:"namespace" validate:"required"`
}

func (v ValidateDataProductNamespaceQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(v))
}

type GetDataProductsQuery struct {
	FilterToUserWithAssigment *uuid.UUID `json:"filter_to_user_with_assigment,omitempty"`
}

func (g GetDataProductsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if g.FilterToUserWithAssigment != nil {
		if v, ok := any(g.FilterToUserWithAssigment).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("FilterToUserWithAssigment", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SetValueForDataProductQuery struct {
	Value string `json:"value" validate:"required"`
}

func (s SetValueForDataProductQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type GetSigninURLQuery struct {
	Environment string `json:"environment" validate:"required"`
}

func (g GetSigninURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetDatabricksWorkspaceURLQuery struct {
	Environment string `json:"environment" validate:"required"`
}

func (g GetDatabricksWorkspaceURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetSnowflakeURLQuery struct {
	Environment string `json:"environment" validate:"required"`
}

func (g GetSnowflakeURLQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ValidateTechnicalAssetNamespaceQuery struct {
	Namespace string `json:"namespace" validate:"required"`
}

func (v ValidateTechnicalAssetNamespaceQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(v))
}

type GetDataProductSettingsNamespaceSuggestionQuery struct {
	Name string `json:"name" validate:"required"`
}

func (g GetDataProductSettingsNamespaceSuggestionQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type ValidateDataProductSettingsNamespaceQuery struct {
	Namespace string                  `json:"namespace" validate:"required"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (v ValidateDataProductSettingsNamespaceQuery) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(v.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(v.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UnlinkOutputPortFromTechnicalAssetQuery struct {
	DatasetID uuid.UUID `json:"dataset_id" validate:"required"`
}

func (u UnlinkOutputPortFromTechnicalAssetQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.DatasetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DatasetID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ListAssignmentsQuery struct {
	UserID *uuid.UUID `json:"user_id,omitempty"`
	RoleID *uuid.UUID `json:"role_id,omitempty"`
}

func (l ListAssignmentsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if l.UserID != nil {
		if v, ok := any(l.UserID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("UserID", err)
			}
		}
	}
	if l.RoleID != nil {
		if v, ok := any(l.RoleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("RoleID", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CheckAccessResponse = AccessResponse

type CheckAccessErrorResponse = HTTPValidationError

type IsAdminResponseJSON = IsAdminResponse

type SearchOutputPortsResponseJSON = SearchOutputPortsResponse

type SearchOutputPortsErrorResponse = HTTPValidationError

type GetOutputPortQueryStatsResponse = OutputPortQueryStatsResponses

type GetOutputPortQueryStatsErrorResponse = HTTPValidationError

type UpdateOutputPortQueryStatsResponse struct{}

type UpdateOutputPortQueryStatsErrorResponse = HTTPValidationError

type DeleteOutputPortQueryStatResponse struct{}

type DeleteOutputPortQueryStatErrorResponse = HTTPValidationError

type GetOutputPortCuratedQueriesResponse = OutputPortCuratedQueries

type GetOutputPortCuratedQueriesErrorResponse = HTTPValidationError

type ReplaceOutputPortCuratedQueriesResponse = OutputPortCuratedQueries

type ReplaceOutputPortCuratedQueriesErrorResponse = HTTPValidationError

type GetDataProductOutputPortsResponseJSON = GetDataProductOutputPortsResponse

type GetDataProductOutputPortsErrorResponse = HTTPValidationError

type CreateOutputPortResponseJSON = CreateOutputPortResponse

type CreateOutputPortErrorResponse = HTTPValidationError

type GetOutputPortResponseJSON = GetOutputPortResponse

type GetOutputPortErrorResponse = HTTPValidationError

type RemoveDatasetResponse struct{}

type RemoveDatasetErrorResponse = HTTPValidationError

type UpdateOutputPortResponseJSON = UpdateOutputPortResponse

type UpdateOutputPortErrorResponse = HTTPValidationError

type GetEventHistoryResponseJSON = GetEventHistoryResponse

type GetEventHistoryErrorResponse = HTTPValidationError

type UpdateOutputPortAboutResponse struct{}

type UpdateOutputPortAboutErrorResponse = HTTPValidationError

type UpdateOutputPortStatusResponse struct{}

type UpdateOutputPortStatusErrorResponse = HTTPValidationError

type GetGraphDataResponse = Graph

type GetGraphDataErrorResponse = HTTPValidationError

type SetValueForOutputPortResponse struct{}

type SetValueForOutputPortErrorResponse = HTTPValidationError

type GetDataProductNamespaceSuggestionResponse = NamespaceSuggestion

type GetDataProductNamespaceSuggestionErrorResponse = HTTPValidationError

type ValidateDataProductNamespaceResponse = NamespaceValidation

type ValidateDataProductNamespaceErrorResponse = HTTPValidationError

type GetDataProductNamespaceLengthLimitsResponse = NamespaceLengthLimits

type CreateDataProductResponseJSON = CreateDataProductResponse

type CreateDataProductErrorResponse = HTTPValidationError

type GetDataProductsResponseJSON = GetDataProductsResponse

type GetDataProductsErrorResponse = HTTPValidationError

type RemoveDataProductResponse struct{}

type RemoveDataProductErrorResponse = HTTPValidationError

type UpdateDataProductResponseJSON = UpdateDataProductResponse

type UpdateDataProductErrorResponse = HTTPValidationError

type GetDataProductResponseJSON = GetDataProductResponse

type GetDataProductErrorResponse = HTTPValidationError

type UpdateDataProductAboutResponse struct{}

type UpdateDataProductAboutErrorResponse = HTTPValidationError

type UpdateDataProductStatusResponse struct{}

type UpdateDataProductStatusErrorResponse = HTTPValidationError

type UpdateDataProductUsageResponse struct{}

type UpdateDataProductUsageErrorResponse = HTTPValidationError

type GetGraphDataResponseJSON = Graph

type GetGraphDataErrorResponseJSON = HTTPValidationError

type SetValueForDataProductResponse struct{}

type SetValueForDataProductErrorResponse = HTTPValidationError

type LinkInputPortsToDataProductResponse = LinkInputPortsToDataProductPost

type LinkInputPortsToDataProductErrorResponse = HTTPValidationError

type CreateTechnicalAssetResponseJSON = CreateTechnicalAssetResponse

type CreateTechnicalAssetErrorResponse = HTTPValidationError

type GetSigninURLResponseJSON = GetSigninURLResponse

type GetSigninURLErrorResponse = HTTPValidationError

type GetConveyorIdeURLResponseJSON = GetConveyorIdeURLResponse

type GetConveyorIdeURLErrorResponse = HTTPValidationError

type GetDatabricksWorkspaceURLResponseJSON = GetDatabricksWorkspaceURLResponse

type GetDatabricksWorkspaceURLErrorResponse = HTTPValidationError

type GetSnowflakeURLResponseJSON = GetSnowflakeURLResponse

type GetSnowflakeURLErrorResponse = HTTPValidationError

type GetTechnicalAssetsResponseJSON = GetTechnicalAssetsResponse

type GetTechnicalAssetsErrorResponse = HTTPValidationError

type GetDataProductInputPortsResponseJSON = GetDataProductInputPortsResponse

type GetDataProductInputPortsErrorResponse = HTTPValidationError

type GetDataProductRolledUpTagsResponseJSON = GetDataProductRolledUpTagsResponse

type GetDataProductRolledUpTagsErrorResponse = HTTPValidationError

type UnlinkInputPortFromDataProductResponse struct{}

type UnlinkInputPortFromDataProductErrorResponse = HTTPValidationError

type ValidateTechnicalAssetNamespaceResponse = NamespaceValidation

type ValidateTechnicalAssetNamespaceErrorResponse = HTTPValidationError

type GetDataProductTypeResponse = DataProductTypeGet

type GetDataProductTypeErrorResponse = HTTPValidationError

type UpdateDataProductTypeResponseJSON = UpdateDataProductTypeResponse

type UpdateDataProductTypeErrorResponse = HTTPValidationError

type RemoveDataProductTypeResponse struct{}

type RemoveDataProductTypeErrorResponse = HTTPValidationError

type GetDataProductsTypesResponse = DataProductTypesGet

type CreateDataProductTypeResponseJSON = CreateDataProductTypeResponse

type CreateDataProductTypeErrorResponse = HTTPValidationError

type MigrateDataProductTypeResponse struct{}

type MigrateDataProductTypeErrorResponse = HTTPValidationError

type GetDataProductsLifecyclesResponse = DataProductLifeCyclesGet

type CreateDataProductLifecycleResponse = CreateDataProductLifeCycleResponse

type CreateDataProductLifecycleErrorResponse = HTTPValidationError

type UpdateDataProductLifecycleResponse = UpdateDataProductLifeCycleResponse

type UpdateDataProductLifecycleErrorResponse = HTTPValidationError

type DeleteDataProductLifecycleResponse struct{}

type DeleteDataProductLifecycleErrorResponse = HTTPValidationError

type GetDataProductsSettingsResponse = DataProductSettingsGet

type CreateDataProductSettingResponseJSON = CreateDataProductSettingResponse

type CreateDataProductSettingErrorResponse = HTTPValidationError

type GetDataProductSettingsNamespaceSuggestionResponse = NamespaceSuggestion

type GetDataProductSettingsNamespaceSuggestionErrorResponse = HTTPValidationError

type ValidateDataProductSettingsNamespaceResponse = NamespaceValidation

type ValidateDataProductSettingsNamespaceErrorResponse = HTTPValidationError

type GetDataProductSettingsNamespaceLengthLimitsResponse = NamespaceLengthLimits

type UpdateDataProductSettingResponseJSON = UpdateDataProductSettingResponse

type UpdateDataProductSettingErrorResponse = HTTPValidationError

type DeleteDataProductSettingResponse struct{}

type DeleteDataProductSettingErrorResponse = HTTPValidationError

type GetTechnicalAssetResponse = GetTechnicalAssetsResponseItem

type GetTechnicalAssetErrorResponse = HTTPValidationError

type RemoveTechnicalAssetResponse struct{}

type RemoveTechnicalAssetErrorResponse = HTTPValidationError

type GetTechnicalAssetEventHistoryResponse = GetEventHistoryResponse

type GetTechnicalAssetEventHistoryErrorResponse = HTTPValidationError

type UpdateTechnicalAssetStatusResponse struct{}

type UpdateTechnicalAssetStatusErrorResponse = HTTPValidationError

type LinkOutputPortToTechnicalAssetResponse = LinkTechnicalAssetsToOutputPortResponse

type LinkOutputPortToTechnicalAssetErrorResponse = HTTPValidationError

type UnlinkOutputPortFromTechnicalAssetResponse struct{}

type UnlinkOutputPortFromTechnicalAssetErrorResponse = HTTPValidationError

type GetGraphDataResponseJSON200 = Graph

type GetGraphDataErrorResponseJSON422 = HTTPValidationError

type GetDomainsResponseJSON = GetDomainsResponse

type CreateDomainResponseJSON = CreateDomainResponse

type CreateDomainErrorResponse = HTTPValidationError

type UpdateDomainResponseJSON = UpdateDomainResponse

type UpdateDomainErrorResponse = HTTPValidationError

type RemoveDomainResponse struct{}

type RemoveDomainErrorResponse = HTTPValidationError

type GetDomainResponseJSON = GetDomainResponse

type GetDomainErrorResponse = HTTPValidationError

type MigrateDomainResponse struct{}

type MigrateDomainErrorResponse = HTTPValidationError

type GetEnvironmentResponse = Environment

type GetEnvironmentErrorResponse = HTTPValidationError

type GetEnvironmentConfigsByIDResponse = EnvironmentConfigsGetItem

type GetEnvironmentConfigsByIDErrorResponse = HTTPValidationError

type GetEnvironmentPlatformServiceConfigResponse = EnvironmentConfigsGetItem

type GetEnvironmentPlatformServiceConfigErrorResponse = HTTPValidationError

type GetEnvironmentPlatformConfigResponse = EnvironmentPlatformConfigGet

type GetEnvironmentPlatformConfigErrorResponse = HTTPValidationError

type GetEnvironmentsResponse = EnvironmentsGet

type GetEnvironmentConfigsResponse = EnvironmentConfigsGet

type GetEnvironmentConfigsErrorResponse = HTTPValidationError

type GetEnvironmentPlatformServiceConfigForAllEnvsResponse = EnvironmentConfigsGet

type GetEnvironmentPlatformServiceConfigForAllEnvsErrorResponse = HTTPValidationError

type GetPlatformServiceConfigResponse = PlatformServiceConfiguration

type GetPlatformServiceConfigErrorResponse = HTTPValidationError

type GetSinglePlatformServiceConfigurationResponse = PlatformServiceConfiguration

type GetSinglePlatformServiceConfigurationErrorResponse = HTTPValidationError

type GetAllPlatformServiceConfigurationsResponseJSON = GetAllPlatformServiceConfigurationsResponse

type GetAllPlatformsResponseJSON = GetAllPlatformsResponse

type GetPlatformServicesResponseJSON = GetPlatformServicesResponse

type GetPlatformServicesErrorResponse = HTTPValidationError

type GetTagsResponse = TagsGet

type CreateTagResponseJSON = CreateTagResponse

type CreateTagErrorResponse = HTTPValidationError

type UpdateTagResponseJSON = UpdateTagResponse

type UpdateTagErrorResponse = HTTPValidationError

type RemoveTagResponse struct{}

type RemoveTagErrorResponse = HTTPValidationError

type RemoveUserResponse struct{}

type RemoveUserErrorResponse = HTTPValidationError

type GetUsersResponseJSON = GetUsersResponse

type CreateUserResponse = UserCreateResponse

type CreateUserErrorResponse = HTTPValidationError

type SetCanBecomeAdminResponse struct{}

type SetCanBecomeAdminErrorResponse = HTTPValidationError

type MarkTourAsSeenResponse struct{}

type CreateRoleResponse = Role

type CreateRoleErrorResponse = HTTPValidationError

type RemoveRoleResponse struct{}

type RemoveRoleErrorResponse = HTTPValidationError

type UpdateRoleResponse = Role

type UpdateRoleErrorResponse = HTTPValidationError

type GetRolesResponseJSON = GetRolesResponse

type GetRolesErrorResponse = HTTPValidationError

type BecomeAdminResponse struct{}

type BecomeAdminErrorResponse = HTTPValidationError

type RevokeAdminResponse struct{}

type CreateAssignmentResponse = AppAuthorizationRoleAssignmentsGlobalSchemaRoleAssignmentResponse

type CreateAssignmentErrorResponse = HTTPValidationError

type ListAssignmentsResponse = AppAuthorizationRoleAssignmentsGlobalSchemaListRoleAssignmentsResponse

type ListAssignmentsErrorResponse = HTTPValidationError

type DeleteAssignmentResponse struct{}

type DeleteAssignmentErrorResponse = HTTPValidationError

type DecideAssignmentResponse = AppAuthorizationRoleAssignmentsGlobalSchemaRoleAssignmentResponse

type DecideAssignmentErrorResponse = HTTPValidationError

type ModifyAssignedRoleResponse = AppAuthorizationRoleAssignmentsGlobalSchemaRoleAssignmentResponse

type ModifyAssignedRoleErrorResponse = HTTPValidationError

type DeleteAssignmentResponseJSON struct{}

type DeleteAssignmentErrorResponseJSON = HTTPValidationError

type ModifyAssignedRoleResponseJSON = AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignmentResponse

type ModifyAssignedRoleErrorResponseJSON = HTTPValidationError

type ListAssignmentsResponseJSON = AppAuthorizationRoleAssignmentsDataProductSchemaListRoleAssignmentsResponse

type ListAssignmentsErrorResponseJSON = HTTPValidationError

type CreateAssignmentResponseJSON = AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignmentResponse

type CreateAssignmentErrorResponseJSON = HTTPValidationError

type RequestAssignmentResponse = AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignmentResponse

type RequestAssignmentErrorResponse = HTTPValidationError

type DecideAssignmentResponseJSON = AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignmentResponse

type DecideAssignmentErrorResponseJSON = HTTPValidationError

type DeleteAssignmentResponseJSON200 struct{}

type DeleteAssignmentErrorResponseJSON422 = HTTPValidationError

type ModifyAssignedRoleResponseJSON200 = AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignmentResponse

type ModifyAssignedRoleErrorResponseJSON422 = HTTPValidationError

type ListAssignmentsResponseJSON200 = AppAuthorizationRoleAssignmentsOutputPortSchemaListRoleAssignmentsResponse

type ListAssignmentsErrorResponseJSON422 = HTTPValidationError

type CreateAssignmentResponseJSON200 = AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignmentResponse

type CreateAssignmentErrorResponseJSON422 = HTTPValidationError

type RequestAssignmentResponseJSON = AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignmentResponse

type RequestAssignmentErrorResponseJSON = HTTPValidationError

type DecideAssignmentResponseJSON200 = AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignmentResponse

type DecideAssignmentErrorResponseJSON422 = HTTPValidationError

type GetSettingsResponse = ThemeSettings

type UpdateSettingsResponse struct{}

type UpdateSettingsErrorResponse = HTTPValidationError

type AWSEnvironmentPlatformConfiguration struct {
	AccountID   string   `json:"account_id" validate:"required"`
	Region      string   `json:"region" validate:"required"`
	CanReadFrom []string `json:"can_read_from" validate:"required"`
}

func (a AWSEnvironmentPlatformConfiguration) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AWSGlueConfig struct {
	Identifier       string `json:"identifier" validate:"required"`
	DatabaseName     string `json:"database_name" validate:"required"`
	BucketIdentifier string `json:"bucket_identifier" validate:"required"`
	S3Path           string `json:"s3_path" validate:"required"`
}

func (a AWSGlueConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AWSS3Config struct {
	Identifier string `json:"identifier" validate:"required"`
	BucketName string `json:"bucket_name" validate:"required"`
	BucketArn  string `json:"bucket_arn" validate:"required"`
	KmsKeyArn  string `json:"kms_key_arn" validate:"required"`
	IsDefault  bool   `json:"is_default"`
}

func (a AWSS3Config) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type AccessResponse struct {
	Allowed bool `json:"allowed"`
}

type BecomeAdmin struct {
	Expiry string `json:"expiry" validate:"required"`
}

func (b BecomeAdmin) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(b))
}

type CanBecomeAdminUpdate struct {
	UserID         string `json:"user_id" validate:"required"`
	CanBecomeAdmin bool   `json:"can_become_admin"`
}

func (c CanBecomeAdminUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type CreateDataProductLifeCycleResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductLifeCycleResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductSettingResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductSettingResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDataProductTypeResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDataProductTypeResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateDomainResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateDomainResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateOutputPortRequest struct {
	Name        string               `json:"name" validate:"required"`
	Namespace   string               `json:"namespace" validate:"required"`
	Description string               `json:"description" validate:"required"`
	AccessType  OutputPortAccessType `json:"access_type" validate:"required"`
	About       *string              `json:"about,omitempty"`
	LifecycleID *uuid.UUID           `json:"lifecycle_id,omitempty"`
	DomainID    uuid.UUID            `json:"domain_id" validate:"required"`
	TagIds      []uuid.UUID          `json:"tag_ids" validate:"required"`
	Owners      []uuid.UUID          `json:"owners" validate:"required"`
}

func (c CreateOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(c.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(c.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(c.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if c.LifecycleID != nil {
		if v, ok := any(c.LifecycleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LifecycleID", err)
			}
		}
	}
	if v, ok := any(c.DomainID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DomainID", err)
		}
	}
	for i, item := range c.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	for i, item := range c.Owners {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Owners[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateOutputPortResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateRole struct {
	Name        string                `json:"name" validate:"required"`
	Scope       Scope                 `json:"scope" validate:"required"`
	Description string                `json:"description" validate:"required"`
	Permissions []AuthorizationAction `json:"permissions" validate:"required"`
}

func (c CreateRole) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(c.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if err := typesValidator.Var(c.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	for i, item := range c.Permissions {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Permissions[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTagResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateTagResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTechnicalAssetRequest struct {
	Name          string                                    `json:"name" validate:"required"`
	Description   string                                    `json:"description" validate:"required"`
	Namespace     string                                    `json:"namespace" validate:"required"`
	PlatformID    uuid.UUID                                 `json:"platform_id" validate:"required"`
	ServiceID     uuid.UUID                                 `json:"service_id" validate:"required"`
	Status        TechnicalAssetStatus                      `json:"status" validate:"required"`
	Configuration CreateTechnicalAssetRequest_Configuration `json:"configuration"`
	SourceAligned bool                                      `json:"sourceAligned"`
	TagIds        []uuid.UUID                               `json:"tag_ids" validate:"required"`
}

func (c CreateTechnicalAssetRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(c.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(c.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(c.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(c.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if v, ok := any(c.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(c.Configuration).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Configuration", err)
		}
	}
	for i, item := range c.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateTechnicalAssetRequest_Configuration struct {
	CreateTechnicalAssetRequest_Configuration_OneOf *CreateTechnicalAssetRequest_Configuration_OneOf `json:"-"`
}

func (c CreateTechnicalAssetRequest_Configuration) Validate() error {
	var errors runtime.ValidationErrors
	if c.CreateTechnicalAssetRequest_Configuration_OneOf != nil {
		if v, ok := any(c.CreateTechnicalAssetRequest_Configuration_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("CreateTechnicalAssetRequest_Configuration_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (c CreateTechnicalAssetRequest_Configuration) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(c.CreateTechnicalAssetRequest_Configuration_OneOf)
		if err != nil {
			return nil, fmt.Errorf("CreateTechnicalAssetRequest_Configuration_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (c *CreateTechnicalAssetRequest_Configuration) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if c.CreateTechnicalAssetRequest_Configuration_OneOf == nil {
		c.CreateTechnicalAssetRequest_Configuration_OneOf = &CreateTechnicalAssetRequest_Configuration_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, c.CreateTechnicalAssetRequest_Configuration_OneOf); err != nil {
		return fmt.Errorf("CreateTechnicalAssetRequest_Configuration_OneOf unmarshal: %w", err)
	}

	return nil
}

type CreateTechnicalAssetResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (c CreateTechnicalAssetResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(c.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataOutputStatusUpdate struct {
	Status TechnicalAssetStatus `json:"status" validate:"required"`
}

func (d DataOutputStatusUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProduct struct {
	ID          uuid.UUID         `json:"id" validate:"required"`
	Name        string            `json:"name" validate:"required"`
	Namespace   string            `json:"namespace" validate:"required"`
	Description string            `json:"description" validate:"required"`
	Status      DataProductStatus `json:"status" validate:"required"`
	Type        DataProductType   `json:"type"`
}

func (d DataProduct) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductAboutUpdate struct {
	About string `json:"about" validate:"required"`
}

func (d DataProductAboutUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DataProductCreate struct {
	Name        string      `json:"name" validate:"required"`
	Namespace   string      `json:"namespace" validate:"required"`
	Description string      `json:"description" validate:"required"`
	TypeID      uuid.UUID   `json:"type_id" validate:"required"`
	About       *string     `json:"about,omitempty"`
	DomainID    uuid.UUID   `json:"domain_id" validate:"required"`
	TagIds      []uuid.UUID `json:"tag_ids" validate:"required"`
	LifecycleID uuid.UUID   `json:"lifecycle_id" validate:"required"`
	Owners      []uuid.UUID `json:"owners" validate:"required"`
}

func (d DataProductCreate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.TypeID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TypeID", err)
		}
	}
	if v, ok := any(d.DomainID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DomainID", err)
		}
	}
	for i, item := range d.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if v, ok := any(d.LifecycleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("LifecycleID", err)
		}
	}
	for i, item := range d.Owners {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Owners[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductLifeCycle struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Value     int       `json:"value" validate:"required"`
	Color     string    `json:"color" validate:"required"`
	IsDefault bool      `json:"is_default"`
}

func (d DataProductLifeCycle) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(d.Color, "required"); err != nil {
		errors = errors.Append("Color", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductLifeCycleCreate struct {
	Value     int    `json:"value" validate:"required"`
	Name      string `json:"name" validate:"required"`
	Color     string `json:"color" validate:"required"`
	IsDefault *bool  `json:"is_default,omitempty"`
}

func (d DataProductLifeCycleCreate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DataProductLifeCycleUpdate struct {
	Value     int    `json:"value" validate:"required"`
	Name      string `json:"name" validate:"required"`
	Color     string `json:"color" validate:"required"`
	IsDefault *bool  `json:"is_default,omitempty"`
}

func (d DataProductLifeCycleUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DataProductLifeCyclesGet struct {
	DataProductLifeCycles []DataProductLifeCyclesGetItem `json:"data_product_life_cycles" validate:"required"`
}

func (d DataProductLifeCyclesGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.DataProductLifeCycles {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductLifeCycles[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductLifeCyclesGetItem struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Value     int       `json:"value" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Color     string    `json:"color" validate:"required"`
	IsDefault bool      `json:"is_default"`
}

func (d DataProductLifeCyclesGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Color, "required"); err != nil {
		errors = errors.Append("Color", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSetting struct {
	ID        uuid.UUID               `json:"id" validate:"required"`
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSetting) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingCreate struct {
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSettingCreate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingUpdate struct {
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSettingUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingValue struct {
	ID                   uuid.UUID          `json:"id" validate:"required"`
	DataProductSettingID uuid.UUID          `json:"data_product_setting_id" validate:"required"`
	Value                string             `json:"value" validate:"required"`
	DataProductSetting   DataProductSetting `json:"data_product_setting"`
	DataProductID        uuid.UUID          `json:"data_product_id" validate:"required"`
}

func (d DataProductSettingValue) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(d.DataProductSettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSettingID", err)
		}
	}
	if err := typesValidator.Var(d.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if v, ok := any(d.DataProductSetting).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSetting", err)
		}
	}
	if v, ok := any(d.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingsGet struct {
	DataProductSettings []DataProductSettingsGetItem `json:"data_product_settings" validate:"required"`
}

func (d DataProductSettingsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductSettingsGetItem struct {
	ID        uuid.UUID               `json:"id" validate:"required"`
	Category  string                  `json:"category" validate:"required"`
	Type      DataProductSettingType  `json:"type" validate:"required"`
	Tooltip   string                  `json:"tooltip" validate:"required"`
	Namespace string                  `json:"namespace" validate:"required"`
	Name      string                  `json:"name" validate:"required"`
	Default   string                  `json:"default" validate:"required"`
	Order     *int                    `json:"order,omitempty"`
	Scope     DataProductSettingScope `json:"scope" validate:"required"`
}

func (d DataProductSettingsGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Category, "required"); err != nil {
		errors = errors.Append("Category", err)
	}
	if v, ok := any(d.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if err := typesValidator.Var(d.Tooltip, "required"); err != nil {
		errors = errors.Append("Tooltip", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Default, "required"); err != nil {
		errors = errors.Append("Default", err)
	}
	if v, ok := any(d.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductStatusUpdate struct {
	Status DataProductStatus `json:"status" validate:"required"`
}

func (d DataProductStatusUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductType struct {
	ID          uuid.UUID          `json:"id" validate:"required"`
	Name        string             `json:"name" validate:"required"`
	Description string             `json:"description" validate:"required"`
	IconKey     DataProductIconKey `json:"icon_key" validate:"required"`
}

func (d DataProductType) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypeCreate struct {
	Name        string             `json:"name" validate:"required"`
	Description string             `json:"description" validate:"required"`
	IconKey     DataProductIconKey `json:"icon_key" validate:"required"`
}

func (d DataProductTypeCreate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypeGet struct {
	ID           uuid.UUID          `json:"id" validate:"required"`
	Name         string             `json:"name" validate:"required"`
	Description  string             `json:"description" validate:"required"`
	IconKey      DataProductIconKey `json:"icon_key" validate:"required"`
	DataProducts []DataProduct      `json:"data_products" validate:"required"`
}

func (d DataProductTypeGet) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	for i, item := range d.DataProducts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProducts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypeUpdate struct {
	Name        string             `json:"name" validate:"required"`
	Description string             `json:"description" validate:"required"`
	IconKey     DataProductIconKey `json:"icon_key" validate:"required"`
}

func (d DataProductTypeUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypesGet struct {
	DataProductTypes []DataProductTypesGetItem `json:"data_product_types" validate:"required"`
}

func (d DataProductTypesGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range d.DataProductTypes {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductTypes[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductTypesGetItem struct {
	ID               uuid.UUID          `json:"id" validate:"required"`
	Name             string             `json:"name" validate:"required"`
	Description      string             `json:"description" validate:"required"`
	IconKey          DataProductIconKey `json:"icon_key" validate:"required"`
	DataProductCount int                `json:"data_product_count" validate:"required"`
}

func (d DataProductTypesGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.IconKey).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("IconKey", err)
		}
	}
	if err := typesValidator.Var(d.DataProductCount, "required"); err != nil {
		errors = errors.Append("DataProductCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductUpdate struct {
	Name        string      `json:"name" validate:"required"`
	Namespace   string      `json:"namespace" validate:"required"`
	Description string      `json:"description" validate:"required"`
	TypeID      uuid.UUID   `json:"type_id" validate:"required"`
	About       *string     `json:"about,omitempty"`
	DomainID    uuid.UUID   `json:"domain_id" validate:"required"`
	TagIds      []uuid.UUID `json:"tag_ids" validate:"required"`
	LifecycleID uuid.UUID   `json:"lifecycle_id" validate:"required"`
}

func (d DataProductUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.TypeID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TypeID", err)
		}
	}
	if v, ok := any(d.DomainID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DomainID", err)
		}
	}
	for i, item := range d.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if v, ok := any(d.LifecycleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("LifecycleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DataProductUsageUpdate struct {
	Usage string `json:"usage" validate:"required"`
}

func (d DataProductUsageUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatabricksConfig struct {
	Identifier string `json:"identifier" validate:"required"`
}

func (d DatabricksConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatabricksDataOutput struct {
	ConfigurationType string  `json:"configuration_type" validate:"required"`
	Catalog           string  `json:"catalog" validate:"required"`
	Schema            *string `json:"schema,omitempty"`
	Table             *string `json:"table,omitempty"`
	BucketIdentifier  *string `json:"bucket_identifier,omitempty"`
	CatalogPath       *string `json:"catalog_path,omitempty"`
	TablePath         *string `json:"table_path,omitempty"`
}

func (d DatabricksDataOutput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatabricksEnvironmentPlatformConfiguration struct {
	WorkspaceUrls  map[string]string `json:"workspace_urls"`
	AccountID      string            `json:"account_id" validate:"required"`
	MetastoreID    string            `json:"metastore_id" validate:"required"`
	CredentialName string            `json:"credential_name" validate:"required"`
}

func (d DatabricksEnvironmentPlatformConfiguration) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatasetAboutUpdate struct {
	About string `json:"about" validate:"required"`
}

func (d DatasetAboutUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DatasetStatusUpdate struct {
	Status OutputPortStatus `json:"status" validate:"required"`
}

func (d DatasetStatusUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DatasetUpdate struct {
	Name        string               `json:"name" validate:"required"`
	Namespace   string               `json:"namespace" validate:"required"`
	Description string               `json:"description" validate:"required"`
	AccessType  OutputPortAccessType `json:"access_type" validate:"required"`
	About       *string              `json:"about,omitempty"`
	LifecycleID *uuid.UUID           `json:"lifecycle_id,omitempty"`
	DomainID    uuid.UUID            `json:"domain_id" validate:"required"`
	TagIds      []uuid.UUID          `json:"tag_ids" validate:"required"`
}

func (d DatasetUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(d.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if d.LifecycleID != nil {
		if v, ok := any(d.LifecycleID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LifecycleID", err)
			}
		}
	}
	if v, ok := any(d.DomainID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DomainID", err)
		}
	}
	for i, item := range d.TagIds {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TagIds[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Domain struct {
	ID          uuid.UUID `json:"id" validate:"required"`
	Name        string    `json:"name" validate:"required"`
	Description string    `json:"description" validate:"required"`
}

func (d Domain) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(d.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(d.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(d.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DomainCreate struct {
	Name        string `json:"name" validate:"required"`
	Description string `json:"description" validate:"required"`
}

func (d DomainCreate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type DomainUpdate struct {
	Name        string `json:"name" validate:"required"`
	Description string `json:"description" validate:"required"`
}

func (d DomainUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type Edge struct {
	ID           Edge_ID     `json:"id"`
	Source       Edge_Source `json:"source"`
	Target       Edge_Target `json:"target"`
	Animated     bool        `json:"animated"`
	SourceHandle *string     `json:"sourceHandle,omitempty"`
	TargetHandle *string     `json:"targetHandle,omitempty"`
}

func (e Edge) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(e.Source).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Source", err)
		}
	}
	if v, ok := any(e.Target).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Target", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Edge_ID struct {
	Edge_ID_AnyOf *Edge_ID_AnyOf `json:"-"`
}

func (e Edge_ID) Validate() error {
	var errors runtime.ValidationErrors
	if e.Edge_ID_AnyOf != nil {
		if v, ok := any(e.Edge_ID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Edge_ID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e Edge_ID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.Edge_ID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Edge_ID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *Edge_ID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.Edge_ID_AnyOf == nil {
		e.Edge_ID_AnyOf = &Edge_ID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.Edge_ID_AnyOf); err != nil {
		return fmt.Errorf("Edge_ID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Edge_Source struct {
	Edge_Source_AnyOf *Edge_Source_AnyOf `json:"-"`
}

func (e Edge_Source) Validate() error {
	var errors runtime.ValidationErrors
	if e.Edge_Source_AnyOf != nil {
		if v, ok := any(e.Edge_Source_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Edge_Source_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e Edge_Source) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.Edge_Source_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Edge_Source_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *Edge_Source) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.Edge_Source_AnyOf == nil {
		e.Edge_Source_AnyOf = &Edge_Source_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.Edge_Source_AnyOf); err != nil {
		return fmt.Errorf("Edge_Source_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Edge_Target struct {
	Edge_Target_AnyOf *Edge_Target_AnyOf `json:"-"`
}

func (e Edge_Target) Validate() error {
	var errors runtime.ValidationErrors
	if e.Edge_Target_AnyOf != nil {
		if v, ok := any(e.Edge_Target_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Edge_Target_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e Edge_Target) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.Edge_Target_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Edge_Target_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *Edge_Target) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.Edge_Target_AnyOf == nil {
		e.Edge_Target_AnyOf = &Edge_Target_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.Edge_Target_AnyOf); err != nil {
		return fmt.Errorf("Edge_Target_AnyOf unmarshal: %w", err)
	}

	return nil
}

type Environment struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Acronym   string    `json:"acronym" validate:"required"`
	Context   string    `json:"context" validate:"required"`
	IsDefault *bool     `json:"is_default,omitempty"`
}

func (e Environment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(e.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(e.Acronym, "required"); err != nil {
		errors = errors.Append("Acronym", err)
	}
	if err := typesValidator.Var(e.Context, "required"); err != nil {
		errors = errors.Append("Context", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGet struct {
	EnvironmentConfigs []EnvironmentConfigsGetItem `json:"environment_configs" validate:"required"`
}

func (e EnvironmentConfigsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e.EnvironmentConfigs {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("EnvironmentConfigs[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGetItem struct {
	Config      EnvironmentConfigsGetItem_Config `json:"config" validate:"required"`
	ID          uuid.UUID                        `json:"id" validate:"required"`
	Platform    Platform                         `json:"platform"`
	Environment Environment                      `json:"environment"`
	Service     PlatformService                  `json:"service"`
}

func (e EnvironmentConfigsGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Config).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Config", err)
		}
	}
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(e.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if v, ok := any(e.Environment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Environment", err)
		}
	}
	if v, ok := any(e.Service).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Service", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGetItem_Config []EnvironmentConfigsGetItem_Config_Item

func (e EnvironmentConfigsGetItem_Config) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentConfigsGetItem_Config_Item struct {
	EnvironmentConfigsGetItem_Config_AnyOf *EnvironmentConfigsGetItem_Config_AnyOf `json:"-"`
}

func (e EnvironmentConfigsGetItem_Config_Item) Validate() error {
	var errors runtime.ValidationErrors
	if e.EnvironmentConfigsGetItem_Config_AnyOf != nil {
		if v, ok := any(e.EnvironmentConfigsGetItem_Config_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("EnvironmentConfigsGetItem_Config_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e EnvironmentConfigsGetItem_Config_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.EnvironmentConfigsGetItem_Config_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("EnvironmentConfigsGetItem_Config_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *EnvironmentConfigsGetItem_Config_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.EnvironmentConfigsGetItem_Config_AnyOf == nil {
		e.EnvironmentConfigsGetItem_Config_AnyOf = &EnvironmentConfigsGetItem_Config_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.EnvironmentConfigsGetItem_Config_AnyOf); err != nil {
		return fmt.Errorf("EnvironmentConfigsGetItem_Config_AnyOf unmarshal: %w", err)
	}

	return nil
}

type EnvironmentGetItem struct {
	ID        uuid.UUID `json:"id" validate:"required"`
	Name      string    `json:"name" validate:"required"`
	Acronym   string    `json:"acronym" validate:"required"`
	Context   string    `json:"context" validate:"required"`
	IsDefault *bool     `json:"is_default,omitempty"`
}

func (e EnvironmentGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(e.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(e.Acronym, "required"); err != nil {
		errors = errors.Append("Acronym", err)
	}
	if err := typesValidator.Var(e.Context, "required"); err != nil {
		errors = errors.Append("Context", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentPlatformConfigGet struct {
	Config      EnvironmentPlatformConfigGet_Config `json:"config"`
	ID          uuid.UUID                           `json:"id" validate:"required"`
	Environment Environment                         `json:"environment"`
	Platform    Platform                            `json:"platform"`
}

func (e EnvironmentPlatformConfigGet) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Config).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Config", err)
		}
	}
	if v, ok := any(e.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(e.Environment).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Environment", err)
		}
	}
	if v, ok := any(e.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type EnvironmentPlatformConfigGet_Config struct {
	EnvironmentPlatformConfigGet_Config_AnyOf *EnvironmentPlatformConfigGet_Config_AnyOf `json:"-"`
}

func (e EnvironmentPlatformConfigGet_Config) Validate() error {
	var errors runtime.ValidationErrors
	if e.EnvironmentPlatformConfigGet_Config_AnyOf != nil {
		if v, ok := any(e.EnvironmentPlatformConfigGet_Config_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("EnvironmentPlatformConfigGet_Config_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (e EnvironmentPlatformConfigGet_Config) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(e.EnvironmentPlatformConfigGet_Config_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("EnvironmentPlatformConfigGet_Config_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (e *EnvironmentPlatformConfigGet_Config) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if e.EnvironmentPlatformConfigGet_Config_AnyOf == nil {
		e.EnvironmentPlatformConfigGet_Config_AnyOf = &EnvironmentPlatformConfigGet_Config_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, e.EnvironmentPlatformConfigGet_Config_AnyOf); err != nil {
		return fmt.Errorf("EnvironmentPlatformConfigGet_Config_AnyOf unmarshal: %w", err)
	}

	return nil
}

type EnvironmentsGet struct {
	Environments []EnvironmentGetItem `json:"environments" validate:"required"`
}

func (e EnvironmentsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range e.Environments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Environments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAllPlatformServiceConfigurationsResponse struct {
	PlatformServiceConfigurations []PlatformServiceConfiguration `json:"platform_service_configurations" validate:"required"`
}

func (g GetAllPlatformServiceConfigurationsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.PlatformServiceConfigurations {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("PlatformServiceConfigurations[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetAllPlatformsResponse struct {
	Platforms []Platform `json:"platforms" validate:"required"`
}

func (g GetAllPlatformsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Platforms {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Platforms[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetConveyorIdeURLResponse struct {
	IdeURL string `json:"ide_url" validate:"required"`
}

func (g GetConveyorIdeURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetDataProductInputPortsResponse struct {
	InputPorts []InputPort `json:"input_ports" validate:"required"`
}

func (g GetDataProductInputPortsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.InputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("InputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductOutputPortsResponse struct {
	OutputPorts []OutputPort `json:"output_ports" validate:"required"`
}

func (g GetDataProductOutputPortsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.OutputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductResponse struct {
	ID                  uuid.UUID                 `json:"id" validate:"required"`
	Name                string                    `json:"name" validate:"required"`
	Description         string                    `json:"description" validate:"required"`
	Namespace           string                    `json:"namespace" validate:"required"`
	Status              DataProductStatus         `json:"status" validate:"required"`
	Tags                []Tag                     `json:"tags" validate:"required"`
	Usage               string                    `json:"usage"`
	Domain              Domain                    `json:"domain"`
	Type                DataProductType           `json:"type"`
	Lifecycle           DataProductLifeCycle      `json:"lifecycle"`
	DataProductSettings []DataProductSettingValue `json:"data_product_settings" validate:"required"`
	About               string                    `json:"about"`
}

func (g GetDataProductResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(g.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(g.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range g.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductRolledUpTagsResponse struct {
	RolledUpTags []Tag `json:"rolled_up_tags" validate:"required"`
}

func (g GetDataProductRolledUpTagsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.RolledUpTags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RolledUpTags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductsResponse struct {
	DataProducts []GetDataProductsResponseItem `json:"data_products" validate:"required"`
}

func (g GetDataProductsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.DataProducts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProducts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDataProductsResponseItem struct {
	ID                  uuid.UUID                 `json:"id" validate:"required"`
	Name                string                    `json:"name" validate:"required"`
	Description         string                    `json:"description" validate:"required"`
	Namespace           string                    `json:"namespace" validate:"required"`
	Status              DataProductStatus         `json:"status" validate:"required"`
	Tags                []Tag                     `json:"tags" validate:"required"`
	Usage               string                    `json:"usage"`
	Domain              Domain                    `json:"domain"`
	Type                DataProductType           `json:"type"`
	Lifecycle           DataProductLifeCycle      `json:"lifecycle"`
	DataProductSettings []DataProductSettingValue `json:"data_product_settings" validate:"required"`
	UserCount           int                       `json:"user_count" validate:"required"`
	OutputPortCount     int                       `json:"output_port_count" validate:"required"`
	TechnicalAssetCount int                       `json:"technical_asset_count" validate:"required"`
}

func (g GetDataProductsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(g.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(g.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if v, ok := any(g.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range g.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(g.UserCount, "required"); err != nil {
		errors = errors.Append("UserCount", err)
	}
	if err := typesValidator.Var(g.OutputPortCount, "required"); err != nil {
		errors = errors.Append("OutputPortCount", err)
	}
	if err := typesValidator.Var(g.TechnicalAssetCount, "required"); err != nil {
		errors = errors.Append("TechnicalAssetCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDatabricksWorkspaceURLResponse struct {
	DatabricksWorkspaceURL string `json:"databricks_workspace_url" validate:"required"`
}

func (g GetDatabricksWorkspaceURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetDomainResponse struct {
	ID           uuid.UUID     `json:"id" validate:"required"`
	Name         string        `json:"name" validate:"required"`
	Description  string        `json:"description" validate:"required"`
	DataProducts []DataProduct `json:"data_products" validate:"required"`
	OutputPorts  []OutputPort  `json:"output_ports" validate:"required"`
}

func (g GetDomainResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	for i, item := range g.DataProducts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProducts[%d]", i), err)
			}
		}
	}
	for i, item := range g.OutputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDomainsItem struct {
	ID               uuid.UUID `json:"id" validate:"required"`
	Name             string    `json:"name" validate:"required"`
	Description      string    `json:"description" validate:"required"`
	DataProductCount int       `json:"data_product_count" validate:"required"`
	OutputPortCount  int       `json:"output_port_count" validate:"required"`
}

func (g GetDomainsItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.DataProductCount, "required"); err != nil {
		errors = errors.Append("DataProductCount", err)
	}
	if err := typesValidator.Var(g.OutputPortCount, "required"); err != nil {
		errors = errors.Append("OutputPortCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetDomainsResponse struct {
	Domains []GetDomainsItem `json:"domains" validate:"required"`
}

func (g GetDomainsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Domains {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Domains[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEventHistoryResponse struct {
	Events []GetEventHistoryResponseItem `json:"events" validate:"required"`
}

func (g GetEventHistoryResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Events {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Events[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetEventHistoryResponseItem struct {
	ID                       uuid.UUID             `json:"id" validate:"required"`
	Name                     string                `json:"name" validate:"required"`
	SubjectID                uuid.UUID             `json:"subject_id" validate:"required"`
	TargetID                 *uuid.UUID            `json:"target_id,omitempty"`
	SubjectType              EventReferenceEntity  `json:"subject_type" validate:"required"`
	TargetType               *EventReferenceEntity `json:"target_type,omitempty"`
	ActorID                  uuid.UUID             `json:"actor_id" validate:"required"`
	CreatedOn                time.Time             `json:"created_on" validate:"required"`
	DeletedSubjectIdentifier *string               `json:"deleted_subject_identifier,omitempty"`
	DeletedTargetIdentifier  *string               `json:"deleted_target_identifier,omitempty"`
	Actor                    User                  `json:"actor"`
	DataProduct              *DataProduct          `json:"data_product,omitempty"`
	User                     *User                 `json:"user,omitempty"`
	OutputPort               *OutputPort           `json:"output_port,omitempty"`
	TechnicalAsset           *TechnicalAsset       `json:"technical_asset,omitempty"`
}

func (g GetEventHistoryResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(g.SubjectID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SubjectID", err)
		}
	}
	if g.TargetID != nil {
		if v, ok := any(g.TargetID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TargetID", err)
			}
		}
	}
	if v, ok := any(g.SubjectType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("SubjectType", err)
		}
	}
	if g.TargetType != nil {
		if v, ok := any(g.TargetType).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TargetType", err)
			}
		}
	}
	if v, ok := any(g.ActorID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ActorID", err)
		}
	}
	if err := typesValidator.Var(g.CreatedOn, "required"); err != nil {
		errors = errors.Append("CreatedOn", err)
	}
	if v, ok := any(g.Actor).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Actor", err)
		}
	}
	if g.DataProduct != nil {
		if v, ok := any(g.DataProduct).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DataProduct", err)
			}
		}
	}
	if g.User != nil {
		if v, ok := any(g.User).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("User", err)
			}
		}
	}
	if g.OutputPort != nil {
		if v, ok := any(g.OutputPort).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("OutputPort", err)
			}
		}
	}
	if g.TechnicalAsset != nil {
		if v, ok := any(g.TechnicalAsset).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TechnicalAsset", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetOutputPortResponse struct {
	ID                  uuid.UUID                `json:"id" validate:"required"`
	Namespace           string                   `json:"namespace" validate:"required"`
	Name                string                   `json:"name" validate:"required"`
	Description         string                   `json:"description" validate:"required"`
	Status              OutputPortStatus         `json:"status" validate:"required"`
	Usage               string                   `json:"usage"`
	AccessType          OutputPortAccessType     `json:"access_type" validate:"required"`
	DataProductID       uuid.UUID                `json:"data_product_id" validate:"required"`
	Tags                []Tag                    `json:"tags" validate:"required"`
	Domain              Domain                   `json:"domain"`
	Lifecycle           DataProductLifeCycle     `json:"lifecycle"`
	DataProductSettings []OutputPortSettingValue `json:"data_product_settings" validate:"required"`
	TechnicalAssetLinks []TechnicalAssetLink     `json:"technical_asset_links" validate:"required"`
	About               string                   `json:"about"`
	RolledUpTags        []Tag                    `json:"rolled_up_tags" validate:"required"`
}

func (g GetOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(g.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if v, ok := any(g.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(g.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(g.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range g.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	for i, item := range g.TechnicalAssetLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalAssetLinks[%d]", i), err)
			}
		}
	}
	for i, item := range g.RolledUpTags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RolledUpTags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetPlatformServicesResponse struct {
	PlatformServices []PlatformService `json:"platform_services" validate:"required"`
}

func (g GetPlatformServicesResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.PlatformServices {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("PlatformServices[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetRolesResponse struct {
	Roles []Role `json:"roles" validate:"required"`
}

func (g GetRolesResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Roles {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Roles[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetSigninURLResponse struct {
	SigninURL string `json:"signin_url" validate:"required"`
}

func (g GetSigninURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetSnowflakeURLResponse struct {
	SnowflakeURL string `json:"snowflake_url" validate:"required"`
}

func (g GetSnowflakeURLResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetTechnicalAssetsResponse struct {
	TechnicalAssets []GetTechnicalAssetsResponseItem `json:"technical_assets" validate:"required"`
}

func (g GetTechnicalAssetsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.TechnicalAssets {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalAssets[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetsResponseItem struct {
	ID              uuid.UUID                                    `json:"id" validate:"required"`
	Name            string                                       `json:"name" validate:"required"`
	Description     string                                       `json:"description" validate:"required"`
	Namespace       string                                       `json:"namespace" validate:"required"`
	OwnerID         uuid.UUID                                    `json:"owner_id" validate:"required"`
	PlatformID      uuid.UUID                                    `json:"platform_id" validate:"required"`
	ServiceID       uuid.UUID                                    `json:"service_id" validate:"required"`
	Status          TechnicalAssetStatus                         `json:"status" validate:"required"`
	SourceAligned   bool                                         `json:"sourceAligned"`
	Configuration   GetTechnicalAssetsResponseItem_Configuration `json:"configuration"`
	Owner           DataProduct                                  `json:"owner"`
	OutputPortLinks []OutputPortLink                             `json:"output_port_links" validate:"required"`
	Tags            []Tag                                        `json:"tags" validate:"required"`
	ResultString    *string                                      `json:"result_string,omitempty"`
	TechnicalInfo   []TechnicalInfo                              `json:"technical_info,omitempty"`
}

func (g GetTechnicalAssetsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(g.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(g.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if err := typesValidator.Var(g.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if v, ok := any(g.OwnerID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OwnerID", err)
		}
	}
	if v, ok := any(g.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(g.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if v, ok := any(g.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(g.Configuration).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Configuration", err)
		}
	}
	if v, ok := any(g.Owner).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Owner", err)
		}
	}
	for i, item := range g.OutputPortLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortLinks[%d]", i), err)
			}
		}
	}
	for i, item := range g.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	for i, item := range g.TechnicalInfo {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalInfo[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetTechnicalAssetsResponseItem_Configuration struct {
	GetTechnicalAssetsResponseItem_Configuration_OneOf *GetTechnicalAssetsResponseItem_Configuration_OneOf `json:"-"`
}

func (g GetTechnicalAssetsResponseItem_Configuration) Validate() error {
	var errors runtime.ValidationErrors
	if g.GetTechnicalAssetsResponseItem_Configuration_OneOf != nil {
		if v, ok := any(g.GetTechnicalAssetsResponseItem_Configuration_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("GetTechnicalAssetsResponseItem_Configuration_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (g GetTechnicalAssetsResponseItem_Configuration) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(g.GetTechnicalAssetsResponseItem_Configuration_OneOf)
		if err != nil {
			return nil, fmt.Errorf("GetTechnicalAssetsResponseItem_Configuration_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (g *GetTechnicalAssetsResponseItem_Configuration) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if g.GetTechnicalAssetsResponseItem_Configuration_OneOf == nil {
		g.GetTechnicalAssetsResponseItem_Configuration_OneOf = &GetTechnicalAssetsResponseItem_Configuration_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, g.GetTechnicalAssetsResponseItem_Configuration_OneOf); err != nil {
		return fmt.Errorf("GetTechnicalAssetsResponseItem_Configuration_OneOf unmarshal: %w", err)
	}

	return nil
}

type GetUsersResponse struct {
	Users []UsersGet `json:"users" validate:"required"`
}

func (g GetUsersResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Users {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Users[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GlueDataOutput struct {
	ConfigurationType string  `json:"configuration_type" validate:"required"`
	Database          string  `json:"database" validate:"required"`
	DatabaseSuffix    *string `json:"database_suffix,omitempty"`
	Table             *string `json:"table,omitempty"`
	BucketIdentifier  *string `json:"bucket_identifier,omitempty"`
	DatabasePath      *string `json:"database_path,omitempty"`
	TablePath         *string `json:"table_path,omitempty"`
}

func (g GlueDataOutput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type Graph struct {
	Edges []Edge `json:"edges" validate:"required"`
	Nodes []Node `json:"nodes" validate:"required"`
}

func (g Graph) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range g.Edges {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Edges[%d]", i), err)
			}
		}
	}
	for i, item := range g.Nodes {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Nodes[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type HTTPValidationError struct {
	Detail []ValidationError `json:"detail,omitempty"`
}

func (h HTTPValidationError) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range h.Detail {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Detail[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (s HTTPValidationError) Error() string {
	return "unmapped client error"
}

type InputPort struct {
	ID            uuid.UUID      `json:"id" validate:"required"`
	Justification string         `json:"justification" validate:"required"`
	DataProductID uuid.UUID      `json:"data_product_id" validate:"required"`
	OutputPortID  uuid.UUID      `json:"output_port_id" validate:"required"`
	Status        DecisionStatus `json:"status" validate:"required"`
	InputPort     OutputPort     `json:"input_port"`
}

func (i InputPort) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(i.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(i.Justification, "required"); err != nil {
		errors = errors.Append("Justification", err)
	}
	if v, ok := any(i.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(i.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(i.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(i.InputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("InputPort", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type IsAdminResponse struct {
	IsAdmin bool    `json:"is_admin"`
	Time    *string `json:"time,omitempty"`
}

type LinkInputPortsToDataProduct struct {
	InputPorts    []uuid.UUID `json:"input_ports" validate:"required"`
	Justification string      `json:"justification" validate:"required"`
}

func (l LinkInputPortsToDataProduct) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.InputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("InputPorts[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(l.Justification, "required"); err != nil {
		errors = errors.Append("Justification", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkInputPortsToDataProductPost struct {
	InputPortLinks []uuid.UUID `json:"input_port_links" validate:"required"`
}

func (l LinkInputPortsToDataProductPost) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range l.InputPortLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("InputPortLinks[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkTechnicalAssetToOutputPortRequest struct {
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
}

func (l LinkTechnicalAssetToOutputPortRequest) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type LinkTechnicalAssetsToOutputPortResponse struct {
	LinkID uuid.UUID `json:"link_id" validate:"required"`
}

func (l LinkTechnicalAssetsToOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(l.LinkID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("LinkID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NamespaceLengthLimits struct {
	MaxLength int `json:"max_length" validate:"required"`
}

func (n NamespaceLengthLimits) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(n))
}

type NamespaceSuggestion struct {
	Namespace string `json:"namespace" validate:"required"`
}

func (n NamespaceSuggestion) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(n))
}

type NamespaceValidation struct {
	Validity NamespaceValidityType `json:"validity" validate:"required"`
}

func (n NamespaceValidation) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(n.Validity).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Validity", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Node struct {
	ID     Node_ID  `json:"id"`
	Data   NodeData `json:"data"`
	Type   NodeType `json:"type" validate:"required"`
	IsMain *bool    `json:"isMain,omitempty"`
}

func (n Node) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(n.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(n.Data).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Data", err)
		}
	}
	if v, ok := any(n.Type).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Type", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Node_ID struct {
	Node_ID_AnyOf *Node_ID_AnyOf `json:"-"`
}

func (n Node_ID) Validate() error {
	var errors runtime.ValidationErrors
	if n.Node_ID_AnyOf != nil {
		if v, ok := any(n.Node_ID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Node_ID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n Node_ID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.Node_ID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("Node_ID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *Node_ID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.Node_ID_AnyOf == nil {
		n.Node_ID_AnyOf = &Node_ID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.Node_ID_AnyOf); err != nil {
		return fmt.Errorf("Node_ID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData struct {
	ID          NodeData_ID           `json:"id"`
	Name        string                `json:"name" validate:"required"`
	LinkToID    *NodeData_LinkToID    `json:"link_to_id,omitempty"`
	IconKey     *string               `json:"icon_key,omitempty"`
	Domain      *string               `json:"domain,omitempty"`
	DomainID    *NodeData_DomainID    `json:"domain_id,omitempty"`
	Description *string               `json:"description,omitempty"`
	Assignments *NodeData_Assignments `json:"assignments,omitempty"`
}

func (n NodeData) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(n.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(n.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if n.LinkToID != nil {
		if v, ok := any(n.LinkToID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("LinkToID", err)
			}
		}
	}
	if n.DomainID != nil {
		if v, ok := any(n.DomainID).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("DomainID", err)
			}
		}
	}
	if n.Assignments != nil {
		if v, ok := any(n.Assignments).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Assignments", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NodeData_ID struct {
	NodeData_ID_AnyOf *NodeData_ID_AnyOf `json:"-"`
}

func (n NodeData_ID) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_ID_AnyOf != nil {
		if v, ok := any(n.NodeData_ID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_ID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_ID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_ID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_ID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_ID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_ID_AnyOf == nil {
		n.NodeData_ID_AnyOf = &NodeData_ID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_ID_AnyOf); err != nil {
		return fmt.Errorf("NodeData_ID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData_LinkToID struct {
	NodeData_LinkToID_AnyOf *NodeData_LinkToID_AnyOf `json:"-"`
}

func (n NodeData_LinkToID) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_LinkToID_AnyOf != nil {
		if v, ok := any(n.NodeData_LinkToID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_LinkToID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_LinkToID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_LinkToID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_LinkToID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_LinkToID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_LinkToID_AnyOf == nil {
		n.NodeData_LinkToID_AnyOf = &NodeData_LinkToID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_LinkToID_AnyOf); err != nil {
		return fmt.Errorf("NodeData_LinkToID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData_DomainID struct {
	NodeData_DomainID_AnyOf *NodeData_DomainID_AnyOf `json:"-"`
}

func (n NodeData_DomainID) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_DomainID_AnyOf != nil {
		if v, ok := any(n.NodeData_DomainID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_DomainID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_DomainID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_DomainID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_DomainID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_DomainID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_DomainID_AnyOf == nil {
		n.NodeData_DomainID_AnyOf = &NodeData_DomainID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_DomainID_AnyOf); err != nil {
		return fmt.Errorf("NodeData_DomainID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type NodeData_Assignments []NodeData_Assignments_AnyOf_Item

func (n NodeData_Assignments) Validate() error {
	if n == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	for i, item := range n {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type NodeData_Assignments_AnyOf_Item struct {
	NodeData_Assignments_AnyOf_AnyOf *NodeData_Assignments_AnyOf_AnyOf `json:"-"`
}

func (n NodeData_Assignments_AnyOf_Item) Validate() error {
	var errors runtime.ValidationErrors
	if n.NodeData_Assignments_AnyOf_AnyOf != nil {
		if v, ok := any(n.NodeData_Assignments_AnyOf_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NodeData_Assignments_AnyOf_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (n NodeData_Assignments_AnyOf_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(n.NodeData_Assignments_AnyOf_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("NodeData_Assignments_AnyOf_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (n *NodeData_Assignments_AnyOf_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if n.NodeData_Assignments_AnyOf_AnyOf == nil {
		n.NodeData_Assignments_AnyOf_AnyOf = &NodeData_Assignments_AnyOf_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, n.NodeData_Assignments_AnyOf_AnyOf); err != nil {
		return fmt.Errorf("NodeData_Assignments_AnyOf_AnyOf unmarshal: %w", err)
	}

	return nil
}

type OutputPort struct {
	ID            uuid.UUID            `json:"id" validate:"required"`
	Name          string               `json:"name" validate:"required"`
	Namespace     string               `json:"namespace" validate:"required"`
	Description   string               `json:"description" validate:"required"`
	Status        OutputPortStatus     `json:"status" validate:"required"`
	AccessType    OutputPortAccessType `json:"access_type" validate:"required"`
	DataProductID uuid.UUID            `json:"data_product_id" validate:"required"`
	Tags          []Tag                `json:"tags" validate:"required"`
}

func (o OutputPort) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(o.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(o.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(o.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(o.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(o.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if v, ok := any(o.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	for i, item := range o.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQueries struct {
	OutputPortCuratedQueries []OutputPortCuratedQuery `json:"output_port_curated_queries" validate:"required"`
}

func (o OutputPortCuratedQueries) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range o.OutputPortCuratedQueries {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortCuratedQueries[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQueriesUpdate struct {
	CuratedQueries []OutputPortCuratedQueryInput `json:"curated_queries" validate:"required"`
}

func (o OutputPortCuratedQueriesUpdate) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range o.CuratedQueries {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("CuratedQueries[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQuery struct {
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
	SortOrder    int       `json:"sort_order" validate:"required"`
	Title        string    `json:"title" validate:"required"`
	Description  string    `json:"description"`
	QueryText    string    `json:"query_text" validate:"required"`
	CreatedAt    time.Time `json:"created_at" validate:"required"`
	UpdatedAt    time.Time `json:"updated_at"`
}

func (o OutputPortCuratedQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if err := typesValidator.Var(o.SortOrder, "required"); err != nil {
		errors = errors.Append("SortOrder", err)
	}
	if err := typesValidator.Var(o.Title, "required"); err != nil {
		errors = errors.Append("Title", err)
	}
	if err := typesValidator.Var(o.QueryText, "required"); err != nil {
		errors = errors.Append("QueryText", err)
	}
	if err := typesValidator.Var(o.CreatedAt, "required"); err != nil {
		errors = errors.Append("CreatedAt", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortCuratedQueryInput struct {
	Title       string  `json:"title" validate:"required"`
	Description *string `json:"description,omitempty"`
	QueryText   string  `json:"query_text" validate:"required"`
}

func (o OutputPortCuratedQueryInput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(o))
}

type OutputPortLink struct {
	ID               uuid.UUID      `json:"id" validate:"required"`
	OutputPortID     uuid.UUID      `json:"output_port_id" validate:"required"`
	TechnicalAssetID uuid.UUID      `json:"technical_asset_id" validate:"required"`
	Status           DecisionStatus `json:"status" validate:"required"`
	Output           OutputPort     `json:"output"`
}

func (o OutputPortLink) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(o.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(o.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if v, ok := any(o.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(o.Output).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Output", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsDelete struct {
	Date                  string    `json:"date" validate:"required"`
	ConsumerDataProductID uuid.UUID `json:"consumer_data_product_id" validate:"required"`
}

func (o OutputPortQueryStatsDelete) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.Date, "required"); err != nil {
		errors = errors.Append("Date", err)
	}
	if v, ok := any(o.ConsumerDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumerDataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsResponse struct {
	Date                    runtime.Date `json:"date" validate:"required"`
	ConsumerDataProductID   uuid.UUID    `json:"consumer_data_product_id" validate:"required"`
	QueryCount              int          `json:"query_count" validate:"required"`
	ConsumerDataProductName *string      `json:"consumer_data_product_name,omitempty"`
}

func (o OutputPortQueryStatsResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.Date).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Date", err)
		}
	}
	if v, ok := any(o.ConsumerDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumerDataProductID", err)
		}
	}
	if err := typesValidator.Var(o.QueryCount, "required"); err != nil {
		errors = errors.Append("QueryCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsResponses struct {
	OutputPortQueryStatsResponses []OutputPortQueryStatsResponse `json:"output_port_query_stats_responses" validate:"required"`
}

func (o OutputPortQueryStatsResponses) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range o.OutputPortQueryStatsResponses {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortQueryStatsResponses[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortQueryStatsUpdate struct {
	Date                  string    `json:"date" validate:"required"`
	ConsumerDataProductID uuid.UUID `json:"consumer_data_product_id" validate:"required"`
	QueryCount            int       `json:"query_count" validate:"required"`
}

func (o OutputPortQueryStatsUpdate) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.Date, "required"); err != nil {
		errors = errors.Append("Date", err)
	}
	if v, ok := any(o.ConsumerDataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ConsumerDataProductID", err)
		}
	}
	if err := typesValidator.Var(o.QueryCount, "required"); err != nil {
		errors = errors.Append("QueryCount", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type OutputPortSettingValue struct {
	ID                   uuid.UUID          `json:"id" validate:"required"`
	DataProductSettingID uuid.UUID          `json:"data_product_setting_id" validate:"required"`
	Value                string             `json:"value" validate:"required"`
	DataProductSetting   DataProductSetting `json:"data_product_setting"`
	OutputPortID         uuid.UUID          `json:"output_port_id" validate:"required"`
}

func (o OutputPortSettingValue) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(o.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(o.DataProductSettingID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSettingID", err)
		}
	}
	if err := typesValidator.Var(o.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if v, ok := any(o.DataProductSetting).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductSetting", err)
		}
	}
	if v, ok := any(o.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Platform struct {
	ID   uuid.UUID `json:"id" validate:"required"`
	Name string    `json:"name" validate:"required"`
}

func (p Platform) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(p.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PlatformService struct {
	ID                    uuid.UUID `json:"id" validate:"required"`
	Name                  string    `json:"name" validate:"required"`
	Platform              Platform  `json:"platform"`
	ResultStringTemplate  string    `json:"result_string_template" validate:"required"`
	TechnicalInfoTemplate string    `json:"technical_info_template" validate:"required"`
}

func (p PlatformService) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(p.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(p.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if err := typesValidator.Var(p.ResultStringTemplate, "required"); err != nil {
		errors = errors.Append("ResultStringTemplate", err)
	}
	if err := typesValidator.Var(p.TechnicalInfoTemplate, "required"); err != nil {
		errors = errors.Append("TechnicalInfoTemplate", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type PlatformServiceConfiguration struct {
	ID       uuid.UUID       `json:"id" validate:"required"`
	Platform Platform        `json:"platform"`
	Service  PlatformService `json:"service"`
	Config   []string        `json:"config" validate:"required"`
}

func (p PlatformServiceConfiguration) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(p.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(p.Platform).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Platform", err)
		}
	}
	if v, ok := any(p.Service).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Service", err)
		}
	}
	if err := typesValidator.Var(p.Config, "required"); err != nil {
		errors = errors.Append("Config", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type RedshiftConfig struct {
	Identifier       string `json:"identifier" validate:"required"`
	DatabaseName     string `json:"database_name" validate:"required"`
	BucketIdentifier string `json:"bucket_identifier" validate:"required"`
	S3Path           string `json:"s3_path" validate:"required"`
}

func (r RedshiftConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type RedshiftDataOutput struct {
	ConfigurationType string  `json:"configuration_type" validate:"required"`
	Database          string  `json:"database" validate:"required"`
	Schema            *string `json:"schema,omitempty"`
	Table             *string `json:"table,omitempty"`
	BucketIdentifier  *string `json:"bucket_identifier,omitempty"`
	DatabasePath      *string `json:"database_path,omitempty"`
	TablePath         *string `json:"table_path,omitempty"`
}

func (r RedshiftDataOutput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(r))
}

type Role struct {
	Name        string                `json:"name" validate:"required"`
	Scope       Scope                 `json:"scope" validate:"required"`
	Description string                `json:"description" validate:"required"`
	Permissions []AuthorizationAction `json:"permissions" validate:"required"`
	ID          uuid.UUID             `json:"id" validate:"required"`
	Prototype   Prototype             `json:"prototype" validate:"required"`
}

func (r Role) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(r.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(r.Scope).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Scope", err)
		}
	}
	if err := typesValidator.Var(r.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	for i, item := range r.Permissions {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Permissions[%d]", i), err)
			}
		}
	}
	if v, ok := any(r.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(r.Prototype).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Prototype", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type S3DataOutput struct {
	ConfigurationType string  `json:"configuration_type" validate:"required"`
	Bucket            string  `json:"bucket" validate:"required"`
	Suffix            *string `json:"suffix,omitempty"`
	Path              string  `json:"path" validate:"required"`
}

func (s S3DataOutput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SearchOutputPortsResponse struct {
	OutputPorts []SearchOutputPortsResponseItem `json:"output_ports" validate:"required"`
}

func (s SearchOutputPortsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range s.OutputPorts {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPorts[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SearchOutputPortsResponseItem struct {
	ID                  uuid.UUID                `json:"id" validate:"required"`
	Namespace           string                   `json:"namespace" validate:"required"`
	Name                string                   `json:"name" validate:"required"`
	Description         string                   `json:"description" validate:"required"`
	Status              OutputPortStatus         `json:"status" validate:"required"`
	Usage               string                   `json:"usage"`
	AccessType          OutputPortAccessType     `json:"access_type" validate:"required"`
	DataProductID       uuid.UUID                `json:"data_product_id" validate:"required"`
	Tags                []Tag                    `json:"tags" validate:"required"`
	Domain              Domain                   `json:"domain"`
	Lifecycle           DataProductLifeCycle     `json:"lifecycle"`
	DataProductSettings []OutputPortSettingValue `json:"data_product_settings" validate:"required"`
	TechnicalAssetLinks []TechnicalAssetLink     `json:"technical_asset_links" validate:"required"`
	DataProductCount    int                      `json:"data_product_count" validate:"required"`
	DataProductName     string                   `json:"data_product_name" validate:"required"`
	Rank                float32                  `json:"rank" validate:"required"`
}

func (s SearchOutputPortsResponseItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(s.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(s.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(s.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(s.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(s.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(s.AccessType).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("AccessType", err)
		}
	}
	if v, ok := any(s.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	for i, item := range s.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if v, ok := any(s.Domain).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Domain", err)
		}
	}
	if v, ok := any(s.Lifecycle).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Lifecycle", err)
		}
	}
	for i, item := range s.DataProductSettings {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("DataProductSettings[%d]", i), err)
			}
		}
	}
	for i, item := range s.TechnicalAssetLinks {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("TechnicalAssetLinks[%d]", i), err)
			}
		}
	}
	if err := typesValidator.Var(s.DataProductCount, "required"); err != nil {
		errors = errors.Append("DataProductCount", err)
	}
	if err := typesValidator.Var(s.DataProductName, "required"); err != nil {
		errors = errors.Append("DataProductName", err)
	}
	if err := typesValidator.Var(s.Rank, "required"); err != nil {
		errors = errors.Append("Rank", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type SnowflakeConfig struct {
	Identifier   string `json:"identifier" validate:"required"`
	DatabaseName string `json:"database_name" validate:"required"`
}

func (s SnowflakeConfig) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type SnowflakeDataOutput struct {
	ConfigurationType string  `json:"configuration_type" validate:"required"`
	Database          string  `json:"database" validate:"required"`
	Schema            *string `json:"schema,omitempty"`
	Table             *string `json:"table,omitempty"`
	BucketIdentifier  *string `json:"bucket_identifier,omitempty"`
	DatabasePath      *string `json:"database_path,omitempty"`
	TablePath         *string `json:"table_path,omitempty"`
}

func (s SnowflakeDataOutput) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type Tag struct {
	ID    uuid.UUID `json:"id" validate:"required"`
	Value string    `json:"value" validate:"required"`
}

func (t Tag) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(t.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TagCreate struct {
	Value string `json:"value" validate:"required"`
}

func (t TagCreate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type TagUpdate struct {
	Value string `json:"value" validate:"required"`
}

func (t TagUpdate) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type TagsGet struct {
	Tags []TagsGetItem `json:"tags" validate:"required"`
}

func (t TagsGet) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range t.Tags {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Tags[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TagsGetItem struct {
	ID    uuid.UUID `json:"id" validate:"required"`
	Value string    `json:"value" validate:"required"`
}

func (t TagsGetItem) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(t.Value, "required"); err != nil {
		errors = errors.Append("Value", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalAsset struct {
	ID            uuid.UUID                    `json:"id" validate:"required"`
	Name          string                       `json:"name" validate:"required"`
	Namespace     string                       `json:"namespace" validate:"required"`
	Description   string                       `json:"description" validate:"required"`
	Status        TechnicalAssetStatus         `json:"status" validate:"required"`
	SourceAligned bool                         `json:"sourceAligned"`
	OwnerID       uuid.UUID                    `json:"owner_id" validate:"required"`
	PlatformID    uuid.UUID                    `json:"platform_id" validate:"required"`
	ServiceID     uuid.UUID                    `json:"service_id" validate:"required"`
	Configuration TechnicalAsset_Configuration `json:"configuration"`
}

func (t TechnicalAsset) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if err := typesValidator.Var(t.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if err := typesValidator.Var(t.Namespace, "required"); err != nil {
		errors = errors.Append("Namespace", err)
	}
	if err := typesValidator.Var(t.Description, "required"); err != nil {
		errors = errors.Append("Description", err)
	}
	if v, ok := any(t.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(t.OwnerID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OwnerID", err)
		}
	}
	if v, ok := any(t.PlatformID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("PlatformID", err)
		}
	}
	if v, ok := any(t.ServiceID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ServiceID", err)
		}
	}
	if v, ok := any(t.Configuration).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Configuration", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalAsset_Configuration struct {
	TechnicalAsset_Configuration_OneOf *TechnicalAsset_Configuration_OneOf `json:"-"`
}

func (t TechnicalAsset_Configuration) Validate() error {
	var errors runtime.ValidationErrors
	if t.TechnicalAsset_Configuration_OneOf != nil {
		if v, ok := any(t.TechnicalAsset_Configuration_OneOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("TechnicalAsset_Configuration_OneOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (t TechnicalAsset_Configuration) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(t.TechnicalAsset_Configuration_OneOf)
		if err != nil {
			return nil, fmt.Errorf("TechnicalAsset_Configuration_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (t *TechnicalAsset_Configuration) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if t.TechnicalAsset_Configuration_OneOf == nil {
		t.TechnicalAsset_Configuration_OneOf = &TechnicalAsset_Configuration_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, t.TechnicalAsset_Configuration_OneOf); err != nil {
		return fmt.Errorf("TechnicalAsset_Configuration_OneOf unmarshal: %w", err)
	}

	return nil
}

type TechnicalAssetLink struct {
	ID               uuid.UUID      `json:"id" validate:"required"`
	OutputPortID     uuid.UUID      `json:"output_port_id" validate:"required"`
	TechnicalAssetID uuid.UUID      `json:"technical_asset_id" validate:"required"`
	Status           DecisionStatus `json:"status" validate:"required"`
	TechnicalAsset   TechnicalAsset `json:"technical_asset"`
}

func (t TechnicalAssetLink) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(t.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(t.TechnicalAssetID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAssetID", err)
		}
	}
	if v, ok := any(t.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(t.TechnicalAsset).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("TechnicalAsset", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type TechnicalInfo struct {
	EnvironmentID uuid.UUID `json:"environment_id" validate:"required"`
	Environment   string    `json:"environment" validate:"required"`
	Info          string    `json:"info"`
}

func (t TechnicalInfo) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(t.EnvironmentID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("EnvironmentID", err)
		}
	}
	if err := typesValidator.Var(t.Environment, "required"); err != nil {
		errors = errors.Append("Environment", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ThemeSettings struct {
	PortalName string `json:"portal_name" validate:"required"`
}

func (t ThemeSettings) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type UpdateDataProductLifeCycleResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductLifeCycleResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductSettingResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductSettingResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDataProductTypeResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDataProductTypeResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateDomainResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateDomainResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortQueryStatus struct {
	OutputPortQueryStatsUpdates []OutputPortQueryStatsUpdate `json:"output_port_query_stats_updates" validate:"required"`
}

func (u UpdateOutputPortQueryStatus) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.OutputPortQueryStatsUpdates {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("OutputPortQueryStatsUpdates[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateOutputPortResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateOutputPortResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateRole struct {
	Name        *string               `json:"name,omitempty"`
	Description *string               `json:"description,omitempty"`
	Permissions []AuthorizationAction `json:"permissions,omitempty"`
}

func (u UpdateRole) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range u.Permissions {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Permissions[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UpdateTagResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UpdateTagResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type User struct {
	ID             uuid.UUID     `json:"id" validate:"required"`
	Email          runtime.Email `json:"email" validate:"required"`
	ExternalID     string        `json:"external_id" validate:"required"`
	FirstName      string        `json:"first_name" validate:"required"`
	LastName       string        `json:"last_name" validate:"required"`
	HasSeenTour    bool          `json:"has_seen_tour"`
	CanBecomeAdmin bool          `json:"can_become_admin"`
	AdminExpiry    *time.Time    `json:"admin_expiry,omitempty"`
}

func (u User) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.ExternalID, "required"); err != nil {
		errors = errors.Append("ExternalID", err)
	}
	if err := typesValidator.Var(u.FirstName, "required"); err != nil {
		errors = errors.Append("FirstName", err)
	}
	if err := typesValidator.Var(u.LastName, "required"); err != nil {
		errors = errors.Append("LastName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserCreate struct {
	Email      runtime.Email `json:"email" validate:"required"`
	ExternalID string        `json:"external_id" validate:"required"`
	FirstName  string        `json:"first_name" validate:"required"`
	LastName   string        `json:"last_name" validate:"required"`
}

func (u UserCreate) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.ExternalID, "required"); err != nil {
		errors = errors.Append("ExternalID", err)
	}
	if err := typesValidator.Var(u.FirstName, "required"); err != nil {
		errors = errors.Append("FirstName", err)
	}
	if err := typesValidator.Var(u.LastName, "required"); err != nil {
		errors = errors.Append("LastName", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UserCreateResponse struct {
	ID uuid.UUID `json:"id" validate:"required"`
}

func (u UserCreateResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UsersGet struct {
	ID             uuid.UUID                                                         `json:"id" validate:"required"`
	Email          runtime.Email                                                     `json:"email" validate:"required"`
	ExternalID     string                                                            `json:"external_id" validate:"required"`
	FirstName      string                                                            `json:"first_name" validate:"required"`
	LastName       string                                                            `json:"last_name" validate:"required"`
	HasSeenTour    bool                                                              `json:"has_seen_tour"`
	CanBecomeAdmin bool                                                              `json:"can_become_admin"`
	AdminExpiry    *time.Time                                                        `json:"admin_expiry,omitempty"`
	GlobalRole     AppAuthorizationRoleAssignmentsGlobalSchemaRoleAssignmentResponse `json:"global_role"`
}

func (u UsersGet) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(u.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(u.Email).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Email", err)
		}
	}
	if err := typesValidator.Var(u.ExternalID, "required"); err != nil {
		errors = errors.Append("ExternalID", err)
	}
	if err := typesValidator.Var(u.FirstName, "required"); err != nil {
		errors = errors.Append("FirstName", err)
	}
	if err := typesValidator.Var(u.LastName, "required"); err != nil {
		errors = errors.Append("LastName", err)
	}
	if v, ok := any(u.GlobalRole).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("GlobalRole", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError struct {
	Loc  ValidationError_Loc `json:"loc" validate:"required"`
	Msg  string              `json:"msg" validate:"required"`
	Type string              `json:"type" validate:"required"`
}

func (v ValidationError) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(v.Loc).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Loc", err)
		}
	}
	if err := typesValidator.Var(v.Msg, "required"); err != nil {
		errors = errors.Append("Msg", err)
	}
	if err := typesValidator.Var(v.Type, "required"); err != nil {
		errors = errors.Append("Type", err)
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError_Loc []ValidationError_Loc_Item

func (v ValidationError_Loc) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range v {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError_Loc_Item struct {
	ValidationError_Loc_AnyOf *ValidationError_Loc_AnyOf `json:"-"`
}

func (v ValidationError_Loc_Item) Validate() error {
	var errors runtime.ValidationErrors
	if v.ValidationError_Loc_AnyOf != nil {
		if v, ok := any(v.ValidationError_Loc_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("ValidationError_Loc_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (v ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(v.ValidationError_Loc_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("ValidationError_Loc_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (v *ValidationError_Loc_Item) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if v.ValidationError_Loc_AnyOf == nil {
		v.ValidationError_Loc_AnyOf = &ValidationError_Loc_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, v.ValidationError_Loc_AnyOf); err != nil {
		return fmt.Errorf("ValidationError_Loc_AnyOf unmarshal: %w", err)
	}

	return nil
}

type AppAuthorizationRoleAssignmentsDataProductSchemaCreateRoleAssignment struct {
	UserID        uuid.UUID `json:"user_id" validate:"required"`
	RoleID        uuid.UUID `json:"role_id" validate:"required"`
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaCreateRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsDataProductSchemaListRoleAssignmentsResponse struct {
	RoleAssignments []AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignmentResponse `json:"role_assignments" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaListRoleAssignmentsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range a.RoleAssignments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RoleAssignments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsDataProductSchemaModifyRoleAssignment struct {
	RoleID uuid.UUID `json:"role_id" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaModifyRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsDataProductSchemaRequestRoleAssignment struct {
	UserID        uuid.UUID `json:"user_id" validate:"required"`
	RoleID        uuid.UUID `json:"role_id" validate:"required"`
	DataProductID uuid.UUID `json:"data_product_id" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaRequestRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignment struct {
	ID            uuid.UUID      `json:"id" validate:"required"`
	DataProduct   DataProduct    `json:"data_product"`
	User          User           `json:"user"`
	Role          Role           `json:"role"`
	Decision      DecisionStatus `json:"decision" validate:"required"`
	RequestedOn   time.Time      `json:"requested_on"`
	RequestedBy   User           `json:"requested_by"`
	DecidedOn     time.Time      `json:"decided_on"`
	DecidedBy     User           `json:"decided_by"`
	DataProductID uuid.UUID      `json:"data_product_id" validate:"required"`
	UserID        uuid.UUID      `json:"user_id" validate:"required"`
	RoleID        uuid.UUID      `json:"role_id"`
	RequestedByID uuid.UUID      `json:"requested_by_id"`
	DecidedByID   uuid.UUID      `json:"decided_by_id"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(a.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(a.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(a.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(a.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(a.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if v, ok := any(a.DataProductID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProductID", err)
		}
	}
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.RequestedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedByID", err)
		}
	}
	if v, ok := any(a.DecidedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedByID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignmentResponse struct {
	ID          uuid.UUID      `json:"id" validate:"required"`
	DataProduct DataProduct    `json:"data_product"`
	User        User           `json:"user"`
	Role        Role           `json:"role"`
	Decision    DecisionStatus `json:"decision" validate:"required"`
	RequestedOn time.Time      `json:"requested_on"`
	RequestedBy User           `json:"requested_by"`
	DecidedOn   time.Time      `json:"decided_on"`
	DecidedBy   User           `json:"decided_by"`
}

func (a AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(a.DataProduct).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DataProduct", err)
		}
	}
	if v, ok := any(a.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(a.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(a.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(a.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment struct {
	UserID uuid.UUID                                                              `json:"user_id" validate:"required"`
	RoleID AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID `json:"role_id"`
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID struct {
	AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf *AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf `json:"-"`
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID) Validate() error {
	var errors runtime.ValidationErrors
	if a.AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf != nil {
		if v, ok := any(a.AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(a.AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (a *AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if a.AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf == nil {
		a.AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf = &AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, a.AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf); err != nil {
		return fmt.Errorf("AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type AppAuthorizationRoleAssignmentsGlobalSchemaListRoleAssignmentsResponse struct {
	RoleAssignments []AppAuthorizationRoleAssignmentsGlobalSchemaRoleAssignmentResponse `json:"role_assignments" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaListRoleAssignmentsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range a.RoleAssignments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RoleAssignments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment struct {
	RoleID AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID `json:"role_id"`
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID struct {
	AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf *AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf `json:"-"`
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID) Validate() error {
	var errors runtime.ValidationErrors
	if a.AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf != nil {
		if v, ok := any(a.AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(a.AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf)
		if err != nil {
			return nil, fmt.Errorf("AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (a *AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if a.AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf == nil {
		a.AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf = &AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf{}
	}

	if err := runtime.UnmarshalJSON(data, a.AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf); err != nil {
		return fmt.Errorf("AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf unmarshal: %w", err)
	}

	return nil
}

type AppAuthorizationRoleAssignmentsGlobalSchemaRoleAssignmentResponse struct {
	ID          uuid.UUID      `json:"id" validate:"required"`
	User        User           `json:"user"`
	Role        Role           `json:"role"`
	Decision    DecisionStatus `json:"decision" validate:"required"`
	RequestedOn time.Time      `json:"requested_on"`
	RequestedBy User           `json:"requested_by"`
	DecidedOn   time.Time      `json:"decided_on"`
	DecidedBy   User           `json:"decided_by"`
}

func (a AppAuthorizationRoleAssignmentsGlobalSchemaRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(a.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(a.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(a.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(a.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaCreateRoleAssignment struct {
	UserID       uuid.UUID `json:"user_id" validate:"required"`
	RoleID       uuid.UUID `json:"role_id" validate:"required"`
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaCreateRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaDecideRoleAssignment struct {
	Decision DecisionStatus `json:"decision" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaDecideRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaListRoleAssignmentsResponse struct {
	RoleAssignments []AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignmentResponse `json:"role_assignments" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaListRoleAssignmentsResponse) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range a.RoleAssignments {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("RoleAssignments[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaModifyRoleAssignment struct {
	RoleID uuid.UUID `json:"role_id" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaModifyRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaRequestRoleAssignment struct {
	UserID       uuid.UUID `json:"user_id" validate:"required"`
	RoleID       uuid.UUID `json:"role_id" validate:"required"`
	OutputPortID uuid.UUID `json:"output_port_id" validate:"required"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaRequestRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignment struct {
	ID            uuid.UUID      `json:"id" validate:"required"`
	OutputPort    OutputPort     `json:"output_port"`
	User          User           `json:"user"`
	Role          Role           `json:"role"`
	Decision      DecisionStatus `json:"decision" validate:"required"`
	RequestedOn   time.Time      `json:"requested_on"`
	RequestedBy   User           `json:"requested_by"`
	DecidedOn     time.Time      `json:"decided_on"`
	DecidedBy     User           `json:"decided_by"`
	OutputPortID  uuid.UUID      `json:"output_port_id" validate:"required"`
	UserID        uuid.UUID      `json:"user_id" validate:"required"`
	RoleID        uuid.UUID      `json:"role_id"`
	RequestedByID uuid.UUID      `json:"requested_by_id"`
	DecidedByID   uuid.UUID      `json:"decided_by_id"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignment) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(a.OutputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPort", err)
		}
	}
	if v, ok := any(a.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(a.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(a.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(a.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if v, ok := any(a.OutputPortID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPortID", err)
		}
	}
	if v, ok := any(a.UserID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("UserID", err)
		}
	}
	if v, ok := any(a.RoleID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RoleID", err)
		}
	}
	if v, ok := any(a.RequestedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedByID", err)
		}
	}
	if v, ok := any(a.DecidedByID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedByID", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignmentResponse struct {
	ID          uuid.UUID      `json:"id" validate:"required"`
	OutputPort  OutputPort     `json:"output_port"`
	User        User           `json:"user"`
	Role        Role           `json:"role"`
	Decision    DecisionStatus `json:"decision" validate:"required"`
	RequestedOn time.Time      `json:"requested_on"`
	RequestedBy User           `json:"requested_by"`
	DecidedOn   time.Time      `json:"decided_on"`
	DecidedBy   User           `json:"decided_by"`
}

func (a AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignmentResponse) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(a.ID).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("ID", err)
		}
	}
	if v, ok := any(a.OutputPort).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("OutputPort", err)
		}
	}
	if v, ok := any(a.User).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("User", err)
		}
	}
	if v, ok := any(a.Role).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Role", err)
		}
	}
	if v, ok := any(a.Decision).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Decision", err)
		}
	}
	if v, ok := any(a.RequestedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("RequestedBy", err)
		}
	}
	if v, ok := any(a.DecidedBy).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("DecidedBy", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Edge_ID_AnyOf_1 = uuid.UUID

type Edge_Source_AnyOf_1 = uuid.UUID

type Edge_Target_AnyOf_1 = uuid.UUID

type Node_ID_AnyOf_1 = uuid.UUID

type NodeData_ID_AnyOf_1 = uuid.UUID

type NodeData_LinkToID_AnyOf_1 = uuid.UUID

type NodeData_DomainID_AnyOf_1 = uuid.UUID

type AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf_0 = uuid.UUID

type AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf_0 = uuid.UUID

type CreateTechnicalAssetRequest_Configuration_OneOf struct {
	union json.RawMessage
}

func (c *CreateTechnicalAssetRequest_Configuration_OneOf) Validate() error {
	// NOTE: Validation is not supported for unions with more than 2 elements.
	// Validating would require unmarshaling against each possible type, which is inefficient.
	// Use AsValidated<Type>() methods to validate after retrieving the specific type.
	return nil
}

// Raw returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as bytes
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) Raw() json.RawMessage {
	return c.union
}

// AsS3DataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a S3DataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsS3DataOutput() (S3DataOutput, error) {
	return runtime.UnmarshalAs[S3DataOutput](c.union)
}

// AsValidatedS3DataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated S3DataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedS3DataOutput() (S3DataOutput, error) {
	val, err := c.AsS3DataOutput()
	if err != nil {
		var zero S3DataOutput
		return zero, err
	}
	if err := c.validateS3DataOutput(val); err != nil {
		var zero S3DataOutput
		return zero, err
	}
	return val, nil
}

// FromS3DataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided S3DataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromS3DataOutput(val S3DataOutput) error {
	// Validate before storing
	if err := c.validateS3DataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// AsGlueDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a GlueDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsGlueDataOutput() (GlueDataOutput, error) {
	return runtime.UnmarshalAs[GlueDataOutput](c.union)
}

// AsValidatedGlueDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated GlueDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedGlueDataOutput() (GlueDataOutput, error) {
	val, err := c.AsGlueDataOutput()
	if err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	if err := c.validateGlueDataOutput(val); err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	return val, nil
}

// FromGlueDataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided GlueDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromGlueDataOutput(val GlueDataOutput) error {
	// Validate before storing
	if err := c.validateGlueDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// AsDatabricksDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a DatabricksDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsDatabricksDataOutput() (DatabricksDataOutput, error) {
	return runtime.UnmarshalAs[DatabricksDataOutput](c.union)
}

// AsValidatedDatabricksDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated DatabricksDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedDatabricksDataOutput() (DatabricksDataOutput, error) {
	val, err := c.AsDatabricksDataOutput()
	if err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	if err := c.validateDatabricksDataOutput(val); err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	return val, nil
}

// FromDatabricksDataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided DatabricksDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromDatabricksDataOutput(val DatabricksDataOutput) error {
	// Validate before storing
	if err := c.validateDatabricksDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// AsSnowflakeDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a SnowflakeDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	return runtime.UnmarshalAs[SnowflakeDataOutput](c.union)
}

// AsValidatedSnowflakeDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated SnowflakeDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	val, err := c.AsSnowflakeDataOutput()
	if err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	if err := c.validateSnowflakeDataOutput(val); err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	return val, nil
}

// FromSnowflakeDataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided SnowflakeDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromSnowflakeDataOutput(val SnowflakeDataOutput) error {
	// Validate before storing
	if err := c.validateSnowflakeDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// AsRedshiftDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a RedshiftDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsRedshiftDataOutput() (RedshiftDataOutput, error) {
	return runtime.UnmarshalAs[RedshiftDataOutput](c.union)
}

// AsValidatedRedshiftDataOutput returns the union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as a validated RedshiftDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) AsValidatedRedshiftDataOutput() (RedshiftDataOutput, error) {
	val, err := c.AsRedshiftDataOutput()
	if err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	if err := c.validateRedshiftDataOutput(val); err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	return val, nil
}

// FromRedshiftDataOutput overwrites any union data inside the CreateTechnicalAssetRequest_Configuration_OneOf as the provided RedshiftDataOutput
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) FromRedshiftDataOutput(val RedshiftDataOutput) error {
	// Validate before storing
	if err := c.validateRedshiftDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	c.union = bts
	return err
}

// validateS3DataOutput validates a S3DataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateS3DataOutput(val S3DataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateGlueDataOutput validates a GlueDataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateGlueDataOutput(val GlueDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateDatabricksDataOutput validates a DatabricksDataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateDatabricksDataOutput(val DatabricksDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateSnowflakeDataOutput validates a SnowflakeDataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateSnowflakeDataOutput(val SnowflakeDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateRedshiftDataOutput validates a RedshiftDataOutput value
func (c *CreateTechnicalAssetRequest_Configuration_OneOf) validateRedshiftDataOutput(val RedshiftDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

func (c CreateTechnicalAssetRequest_Configuration_OneOf) discriminator(data []byte) (string, error) {
	var discriminator struct {
		Value string `json:"configuration_type"`
	}
	if err := json.Unmarshal(data, &discriminator); err != nil {
		return "", err
	}
	return discriminator.Value, nil
}

func (c CreateTechnicalAssetRequest_Configuration_OneOf) ValueByDiscriminator() (any, error) {
	discriminator, err := c.discriminator(c.union)
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DatabricksDataOutput":
		return c.AsDatabricksDataOutput()
	case "GlueDataOutput":
		return c.AsGlueDataOutput()
	case "RedshiftDataOutput":
		return c.AsRedshiftDataOutput()
	case "S3DataOutput":
		return c.AsS3DataOutput()
	case "SnowflakeDataOutput":
		return c.AsSnowflakeDataOutput()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (c CreateTechnicalAssetRequest_Configuration_OneOf) MarshalJSON() ([]byte, error) {
	bts, err := c.union.MarshalJSON()

	return bts, err
}

func (c *CreateTechnicalAssetRequest_Configuration_OneOf) UnmarshalJSON(bts []byte) error {
	err := c.union.UnmarshalJSON(bts)

	return err
}

type Edge_ID_AnyOf struct {
	runtime.Either[string, Edge_ID_AnyOf_1]
}

func (e *Edge_ID_AnyOf) Validate() error {
	if e.IsA() {
		if v, ok := any(e.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if e.IsB() {
		if v, ok := any(e.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type Edge_Source_AnyOf struct {
	runtime.Either[string, Edge_Source_AnyOf_1]
}

func (e *Edge_Source_AnyOf) Validate() error {
	if e.IsA() {
		if v, ok := any(e.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if e.IsB() {
		if v, ok := any(e.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type Edge_Target_AnyOf struct {
	runtime.Either[string, Edge_Target_AnyOf_1]
}

func (e *Edge_Target_AnyOf) Validate() error {
	if e.IsA() {
		if v, ok := any(e.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if e.IsB() {
		if v, ok := any(e.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type EnvironmentConfigsGetItem_Config_AnyOf struct {
	union json.RawMessage
}

func (e *EnvironmentConfigsGetItem_Config_AnyOf) Validate() error {
	// NOTE: Validation is not supported for unions with more than 2 elements.
	// Validating would require unmarshaling against each possible type, which is inefficient.
	// Use AsValidated<Type>() methods to validate after retrieving the specific type.
	return nil
}

// Raw returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as bytes
func (e *EnvironmentConfigsGetItem_Config_AnyOf) Raw() json.RawMessage {
	return e.union
}

// AsAWSS3Config returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a AWSS3Config
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsAWSS3Config() (AWSS3Config, error) {
	return runtime.UnmarshalAs[AWSS3Config](e.union)
}

// AsValidatedAWSS3Config returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated AWSS3Config
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedAWSS3Config() (AWSS3Config, error) {
	val, err := e.AsAWSS3Config()
	if err != nil {
		var zero AWSS3Config
		return zero, err
	}
	if err := e.validateAWSS3Config(val); err != nil {
		var zero AWSS3Config
		return zero, err
	}
	return val, nil
}

// FromAWSS3Config overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided AWSS3Config
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromAWSS3Config(val AWSS3Config) error {
	// Validate before storing
	if err := e.validateAWSS3Config(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// AsAWSGlueConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a AWSGlueConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsAWSGlueConfig() (AWSGlueConfig, error) {
	return runtime.UnmarshalAs[AWSGlueConfig](e.union)
}

// AsValidatedAWSGlueConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated AWSGlueConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedAWSGlueConfig() (AWSGlueConfig, error) {
	val, err := e.AsAWSGlueConfig()
	if err != nil {
		var zero AWSGlueConfig
		return zero, err
	}
	if err := e.validateAWSGlueConfig(val); err != nil {
		var zero AWSGlueConfig
		return zero, err
	}
	return val, nil
}

// FromAWSGlueConfig overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided AWSGlueConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromAWSGlueConfig(val AWSGlueConfig) error {
	// Validate before storing
	if err := e.validateAWSGlueConfig(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// AsDatabricksConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a DatabricksConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsDatabricksConfig() (DatabricksConfig, error) {
	return runtime.UnmarshalAs[DatabricksConfig](e.union)
}

// AsValidatedDatabricksConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated DatabricksConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedDatabricksConfig() (DatabricksConfig, error) {
	val, err := e.AsDatabricksConfig()
	if err != nil {
		var zero DatabricksConfig
		return zero, err
	}
	if err := e.validateDatabricksConfig(val); err != nil {
		var zero DatabricksConfig
		return zero, err
	}
	return val, nil
}

// FromDatabricksConfig overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided DatabricksConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromDatabricksConfig(val DatabricksConfig) error {
	// Validate before storing
	if err := e.validateDatabricksConfig(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// AsSnowflakeConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a SnowflakeConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsSnowflakeConfig() (SnowflakeConfig, error) {
	return runtime.UnmarshalAs[SnowflakeConfig](e.union)
}

// AsValidatedSnowflakeConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated SnowflakeConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedSnowflakeConfig() (SnowflakeConfig, error) {
	val, err := e.AsSnowflakeConfig()
	if err != nil {
		var zero SnowflakeConfig
		return zero, err
	}
	if err := e.validateSnowflakeConfig(val); err != nil {
		var zero SnowflakeConfig
		return zero, err
	}
	return val, nil
}

// FromSnowflakeConfig overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided SnowflakeConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromSnowflakeConfig(val SnowflakeConfig) error {
	// Validate before storing
	if err := e.validateSnowflakeConfig(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// AsRedshiftConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a RedshiftConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsRedshiftConfig() (RedshiftConfig, error) {
	return runtime.UnmarshalAs[RedshiftConfig](e.union)
}

// AsValidatedRedshiftConfig returns the union data inside the EnvironmentConfigsGetItem_Config_AnyOf as a validated RedshiftConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) AsValidatedRedshiftConfig() (RedshiftConfig, error) {
	val, err := e.AsRedshiftConfig()
	if err != nil {
		var zero RedshiftConfig
		return zero, err
	}
	if err := e.validateRedshiftConfig(val); err != nil {
		var zero RedshiftConfig
		return zero, err
	}
	return val, nil
}

// FromRedshiftConfig overwrites any union data inside the EnvironmentConfigsGetItem_Config_AnyOf as the provided RedshiftConfig
func (e *EnvironmentConfigsGetItem_Config_AnyOf) FromRedshiftConfig(val RedshiftConfig) error {
	// Validate before storing
	if err := e.validateRedshiftConfig(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	e.union = bts
	return err
}

// validateAWSS3Config validates a AWSS3Config value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateAWSS3Config(val AWSS3Config) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateAWSGlueConfig validates a AWSGlueConfig value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateAWSGlueConfig(val AWSGlueConfig) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateDatabricksConfig validates a DatabricksConfig value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateDatabricksConfig(val DatabricksConfig) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateSnowflakeConfig validates a SnowflakeConfig value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateSnowflakeConfig(val SnowflakeConfig) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateRedshiftConfig validates a RedshiftConfig value
func (e *EnvironmentConfigsGetItem_Config_AnyOf) validateRedshiftConfig(val RedshiftConfig) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

func (e EnvironmentConfigsGetItem_Config_AnyOf) MarshalJSON() ([]byte, error) {
	bts, err := e.union.MarshalJSON()

	return bts, err
}

func (e *EnvironmentConfigsGetItem_Config_AnyOf) UnmarshalJSON(bts []byte) error {
	err := e.union.UnmarshalJSON(bts)

	return err
}

type EnvironmentPlatformConfigGet_Config_AnyOf struct {
	runtime.Either[AWSEnvironmentPlatformConfiguration, DatabricksEnvironmentPlatformConfiguration]
}

func (e *EnvironmentPlatformConfigGet_Config_AnyOf) Validate() error {
	if e.IsA() {
		if v, ok := any(e.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if e.IsB() {
		if v, ok := any(e.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type GetTechnicalAssetsResponseItem_Configuration_OneOf struct {
	union json.RawMessage
}

func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) Validate() error {
	// NOTE: Validation is not supported for unions with more than 2 elements.
	// Validating would require unmarshaling against each possible type, which is inefficient.
	// Use AsValidated<Type>() methods to validate after retrieving the specific type.
	return nil
}

// Raw returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as bytes
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) Raw() json.RawMessage {
	return g.union
}

// AsS3DataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a S3DataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsS3DataOutput() (S3DataOutput, error) {
	return runtime.UnmarshalAs[S3DataOutput](g.union)
}

// AsValidatedS3DataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated S3DataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedS3DataOutput() (S3DataOutput, error) {
	val, err := g.AsS3DataOutput()
	if err != nil {
		var zero S3DataOutput
		return zero, err
	}
	if err := g.validateS3DataOutput(val); err != nil {
		var zero S3DataOutput
		return zero, err
	}
	return val, nil
}

// FromS3DataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided S3DataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromS3DataOutput(val S3DataOutput) error {
	// Validate before storing
	if err := g.validateS3DataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// AsGlueDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a GlueDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsGlueDataOutput() (GlueDataOutput, error) {
	return runtime.UnmarshalAs[GlueDataOutput](g.union)
}

// AsValidatedGlueDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated GlueDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedGlueDataOutput() (GlueDataOutput, error) {
	val, err := g.AsGlueDataOutput()
	if err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	if err := g.validateGlueDataOutput(val); err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	return val, nil
}

// FromGlueDataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided GlueDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromGlueDataOutput(val GlueDataOutput) error {
	// Validate before storing
	if err := g.validateGlueDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// AsDatabricksDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a DatabricksDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsDatabricksDataOutput() (DatabricksDataOutput, error) {
	return runtime.UnmarshalAs[DatabricksDataOutput](g.union)
}

// AsValidatedDatabricksDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated DatabricksDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedDatabricksDataOutput() (DatabricksDataOutput, error) {
	val, err := g.AsDatabricksDataOutput()
	if err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	if err := g.validateDatabricksDataOutput(val); err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	return val, nil
}

// FromDatabricksDataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided DatabricksDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromDatabricksDataOutput(val DatabricksDataOutput) error {
	// Validate before storing
	if err := g.validateDatabricksDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// AsSnowflakeDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a SnowflakeDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	return runtime.UnmarshalAs[SnowflakeDataOutput](g.union)
}

// AsValidatedSnowflakeDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated SnowflakeDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	val, err := g.AsSnowflakeDataOutput()
	if err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	if err := g.validateSnowflakeDataOutput(val); err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	return val, nil
}

// FromSnowflakeDataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided SnowflakeDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromSnowflakeDataOutput(val SnowflakeDataOutput) error {
	// Validate before storing
	if err := g.validateSnowflakeDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// AsRedshiftDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a RedshiftDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsRedshiftDataOutput() (RedshiftDataOutput, error) {
	return runtime.UnmarshalAs[RedshiftDataOutput](g.union)
}

// AsValidatedRedshiftDataOutput returns the union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as a validated RedshiftDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) AsValidatedRedshiftDataOutput() (RedshiftDataOutput, error) {
	val, err := g.AsRedshiftDataOutput()
	if err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	if err := g.validateRedshiftDataOutput(val); err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	return val, nil
}

// FromRedshiftDataOutput overwrites any union data inside the GetTechnicalAssetsResponseItem_Configuration_OneOf as the provided RedshiftDataOutput
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) FromRedshiftDataOutput(val RedshiftDataOutput) error {
	// Validate before storing
	if err := g.validateRedshiftDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	g.union = bts
	return err
}

// validateS3DataOutput validates a S3DataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateS3DataOutput(val S3DataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateGlueDataOutput validates a GlueDataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateGlueDataOutput(val GlueDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateDatabricksDataOutput validates a DatabricksDataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateDatabricksDataOutput(val DatabricksDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateSnowflakeDataOutput validates a SnowflakeDataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateSnowflakeDataOutput(val SnowflakeDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateRedshiftDataOutput validates a RedshiftDataOutput value
func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) validateRedshiftDataOutput(val RedshiftDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

func (g GetTechnicalAssetsResponseItem_Configuration_OneOf) discriminator(data []byte) (string, error) {
	var discriminator struct {
		Value string `json:"configuration_type"`
	}
	if err := json.Unmarshal(data, &discriminator); err != nil {
		return "", err
	}
	return discriminator.Value, nil
}

func (g GetTechnicalAssetsResponseItem_Configuration_OneOf) ValueByDiscriminator() (any, error) {
	discriminator, err := g.discriminator(g.union)
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DatabricksDataOutput":
		return g.AsDatabricksDataOutput()
	case "GlueDataOutput":
		return g.AsGlueDataOutput()
	case "RedshiftDataOutput":
		return g.AsRedshiftDataOutput()
	case "S3DataOutput":
		return g.AsS3DataOutput()
	case "SnowflakeDataOutput":
		return g.AsSnowflakeDataOutput()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (g GetTechnicalAssetsResponseItem_Configuration_OneOf) MarshalJSON() ([]byte, error) {
	bts, err := g.union.MarshalJSON()

	return bts, err
}

func (g *GetTechnicalAssetsResponseItem_Configuration_OneOf) UnmarshalJSON(bts []byte) error {
	err := g.union.UnmarshalJSON(bts)

	return err
}

type Node_ID_AnyOf struct {
	runtime.Either[string, Node_ID_AnyOf_1]
}

func (n *Node_ID_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type NodeData_ID_AnyOf struct {
	runtime.Either[string, NodeData_ID_AnyOf_1]
}

func (n *NodeData_ID_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type NodeData_LinkToID_AnyOf struct {
	runtime.Either[string, NodeData_LinkToID_AnyOf_1]
}

func (n *NodeData_LinkToID_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type NodeData_DomainID_AnyOf struct {
	runtime.Either[string, NodeData_DomainID_AnyOf_1]
}

func (n *NodeData_DomainID_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type NodeData_Assignments_AnyOf_AnyOf struct {
	runtime.Either[AppAuthorizationRoleAssignmentsDataProductSchemaRoleAssignment, AppAuthorizationRoleAssignmentsOutputPortSchemaRoleAssignment]
}

func (n *NodeData_Assignments_AnyOf_AnyOf) Validate() error {
	if n.IsA() {
		if v, ok := any(n.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if n.IsB() {
		if v, ok := any(n.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type TechnicalAsset_Configuration_OneOf struct {
	union json.RawMessage
}

func (t *TechnicalAsset_Configuration_OneOf) Validate() error {
	// NOTE: Validation is not supported for unions with more than 2 elements.
	// Validating would require unmarshaling against each possible type, which is inefficient.
	// Use AsValidated<Type>() methods to validate after retrieving the specific type.
	return nil
}

// Raw returns the union data inside the TechnicalAsset_Configuration_OneOf as bytes
func (t *TechnicalAsset_Configuration_OneOf) Raw() json.RawMessage {
	return t.union
}

// AsS3DataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a S3DataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsS3DataOutput() (S3DataOutput, error) {
	return runtime.UnmarshalAs[S3DataOutput](t.union)
}

// AsValidatedS3DataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated S3DataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedS3DataOutput() (S3DataOutput, error) {
	val, err := t.AsS3DataOutput()
	if err != nil {
		var zero S3DataOutput
		return zero, err
	}
	if err := t.validateS3DataOutput(val); err != nil {
		var zero S3DataOutput
		return zero, err
	}
	return val, nil
}

// FromS3DataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided S3DataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromS3DataOutput(val S3DataOutput) error {
	// Validate before storing
	if err := t.validateS3DataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// AsGlueDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a GlueDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsGlueDataOutput() (GlueDataOutput, error) {
	return runtime.UnmarshalAs[GlueDataOutput](t.union)
}

// AsValidatedGlueDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated GlueDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedGlueDataOutput() (GlueDataOutput, error) {
	val, err := t.AsGlueDataOutput()
	if err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	if err := t.validateGlueDataOutput(val); err != nil {
		var zero GlueDataOutput
		return zero, err
	}
	return val, nil
}

// FromGlueDataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided GlueDataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromGlueDataOutput(val GlueDataOutput) error {
	// Validate before storing
	if err := t.validateGlueDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// AsDatabricksDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a DatabricksDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsDatabricksDataOutput() (DatabricksDataOutput, error) {
	return runtime.UnmarshalAs[DatabricksDataOutput](t.union)
}

// AsValidatedDatabricksDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated DatabricksDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedDatabricksDataOutput() (DatabricksDataOutput, error) {
	val, err := t.AsDatabricksDataOutput()
	if err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	if err := t.validateDatabricksDataOutput(val); err != nil {
		var zero DatabricksDataOutput
		return zero, err
	}
	return val, nil
}

// FromDatabricksDataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided DatabricksDataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromDatabricksDataOutput(val DatabricksDataOutput) error {
	// Validate before storing
	if err := t.validateDatabricksDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// AsSnowflakeDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a SnowflakeDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	return runtime.UnmarshalAs[SnowflakeDataOutput](t.union)
}

// AsValidatedSnowflakeDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated SnowflakeDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedSnowflakeDataOutput() (SnowflakeDataOutput, error) {
	val, err := t.AsSnowflakeDataOutput()
	if err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	if err := t.validateSnowflakeDataOutput(val); err != nil {
		var zero SnowflakeDataOutput
		return zero, err
	}
	return val, nil
}

// FromSnowflakeDataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided SnowflakeDataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromSnowflakeDataOutput(val SnowflakeDataOutput) error {
	// Validate before storing
	if err := t.validateSnowflakeDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// AsRedshiftDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a RedshiftDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsRedshiftDataOutput() (RedshiftDataOutput, error) {
	return runtime.UnmarshalAs[RedshiftDataOutput](t.union)
}

// AsValidatedRedshiftDataOutput returns the union data inside the TechnicalAsset_Configuration_OneOf as a validated RedshiftDataOutput
func (t *TechnicalAsset_Configuration_OneOf) AsValidatedRedshiftDataOutput() (RedshiftDataOutput, error) {
	val, err := t.AsRedshiftDataOutput()
	if err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	if err := t.validateRedshiftDataOutput(val); err != nil {
		var zero RedshiftDataOutput
		return zero, err
	}
	return val, nil
}

// FromRedshiftDataOutput overwrites any union data inside the TechnicalAsset_Configuration_OneOf as the provided RedshiftDataOutput
func (t *TechnicalAsset_Configuration_OneOf) FromRedshiftDataOutput(val RedshiftDataOutput) error {
	// Validate before storing
	if err := t.validateRedshiftDataOutput(val); err != nil {
		return err
	}
	bts, err := json.Marshal(val)
	t.union = bts
	return err
}

// validateS3DataOutput validates a S3DataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateS3DataOutput(val S3DataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateGlueDataOutput validates a GlueDataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateGlueDataOutput(val GlueDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateDatabricksDataOutput validates a DatabricksDataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateDatabricksDataOutput(val DatabricksDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateSnowflakeDataOutput validates a SnowflakeDataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateSnowflakeDataOutput(val SnowflakeDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

// validateRedshiftDataOutput validates a RedshiftDataOutput value
func (t *TechnicalAsset_Configuration_OneOf) validateRedshiftDataOutput(val RedshiftDataOutput) error {
	if v, ok := any(val).(runtime.Validator); ok {
		return v.Validate()
	}
	return nil
}

func (t TechnicalAsset_Configuration_OneOf) discriminator(data []byte) (string, error) {
	var discriminator struct {
		Value string `json:"configuration_type"`
	}
	if err := json.Unmarshal(data, &discriminator); err != nil {
		return "", err
	}
	return discriminator.Value, nil
}

func (t TechnicalAsset_Configuration_OneOf) ValueByDiscriminator() (any, error) {
	discriminator, err := t.discriminator(t.union)
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DatabricksDataOutput":
		return t.AsDatabricksDataOutput()
	case "GlueDataOutput":
		return t.AsGlueDataOutput()
	case "RedshiftDataOutput":
		return t.AsRedshiftDataOutput()
	case "S3DataOutput":
		return t.AsS3DataOutput()
	case "SnowflakeDataOutput":
		return t.AsSnowflakeDataOutput()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TechnicalAsset_Configuration_OneOf) MarshalJSON() ([]byte, error) {
	bts, err := t.union.MarshalJSON()

	return bts, err
}

func (t *TechnicalAsset_Configuration_OneOf) UnmarshalJSON(bts []byte) error {
	err := t.union.UnmarshalJSON(bts)

	return err
}

type ValidationError_Loc_AnyOf struct {
	runtime.Either[string, int]
}

func (v *ValidationError_Loc_AnyOf) Validate() error {
	if v.IsA() {
		if v, ok := any(v.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if v.IsB() {
		if v, ok := any(v.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf struct {
	runtime.Either[AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf_0, string]
}

func (a *AppAuthorizationRoleAssignmentsGlobalSchemaCreateRoleAssignment_RoleID_AnyOf) Validate() error {
	if a.IsA() {
		if v, ok := any(a.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if a.IsB() {
		if v, ok := any(a.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

type AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf struct {
	runtime.Either[AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf_0, string]
}

func (a *AppAuthorizationRoleAssignmentsGlobalSchemaModifyRoleAssignment_RoleID_AnyOf) Validate() error {
	if a.IsA() {
		if v, ok := any(a.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if a.IsB() {
		if v, ok := any(a.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
